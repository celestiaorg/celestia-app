syntax = "proto3";
package celestia.core.v1.proof;

option go_package = "github.com/celestiaorg/celestia-app/pkg/proof";

// ShareProof is an NMT proof that a set of shares exist in a set of rows and a
// Merkle proof that those rows exist in a Merkle tree with a given data root.
message ShareProof {
  repeated bytes data = 1;
  repeated NMTProof share_proofs = 2;
  bytes namespace_id = 3;
  RowProof row_proof = 4;
  uint32 namespace_version = 5;
}

// RowProof is a Merkle proof that a set of rows exist in a Merkle tree with a
// given data root.
message RowProof {
  repeated bytes row_roots = 1;
  repeated Proof proofs = 2;
  bytes root = 3;
  uint32 start_row = 4;
  uint32 end_row = 5;
}

// NMTProof is a proof of a namespace.ID in an NMT.
// In case this proof proves the absence of a namespace.ID
// in a tree it also contains the leaf hashes of the range
// where that namespace would be.
message NMTProof {
  // Start index of this proof.
  int32 start = 1;
  // End index of this proof.
  int32 end = 2;
  // Nodes that together with the corresponding leaf values can be used to
  // recompute the root and verify this proof. Nodes should consist of the max
  // and min namespaces along with the actual hash, resulting in each being 48
  // bytes each
  repeated bytes nodes = 3;
  // leafHash are nil if the namespace is present in the NMT. In case the
  // namespace to be proved is in the min/max range of the tree but absent, this
  // will contain the leaf hash necessary to verify the proof of absence. Leaf
  // hashes should consist of the namespace along with the actual hash,
  // resulting 40 bytes total.
  bytes leaf_hash = 4;
}

// Proof is taken from the merkle package
message Proof {
  int64 total = 1;
  int64 index = 2;
  bytes leaf_hash = 3;
  repeated bytes aunts = 4;
}