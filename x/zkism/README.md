# `x/zkism`

## Abstract

The `x/zkism` module implements a Hyperlane Interchain Security Module (ISM) that authorizes Hyperlane message processing verified by zeroâ€‘knowledge proofs.
The module implements a generic SP1 Groth16 proof verifier which is leveraged for verification of both state transition and state membership proofs generated by an off-chain proof system.

The module currently supports the following proof value types:

- `EvExecutionProofValues`: State transition of a remote chain (updates trusted state root and height).
- `EvHyperlaneProofValues`: State membership of Hyperlane message IDs (authorizes specific messages for later processing).

The module integrates with Hyperlane core via the keeperâ€™s `Verify` method. This is the integration point used by the Hyperlane ISM routing mechanism.
The `Verify` method consumes the stored message IDs and authorizes the message for processing.

## Concepts

- ZK Execution ISM: Onâ€‘chain record tracking a remote chainâ€™s trusted state and the ZK verifier configuration used to validate proof statements.
- SP1 Groth16 Proofs: Proofs are verified against the SP1 groth16 verifier key, providing an SP1 program verifier key commitment and public values as public witness.
- Authorization Set: A transient set of message IDs. Membership proofs add message IDs; the Hyperlane router consumes them during message verification.

## State

- `isms` (collections.Map[uint64, ZKExecutionISM], `types.IsmsKeyPrefix`): Stores perâ€‘ISM records containing trusted state and verifier configuration used during proof verification.
- `headers` (collections.Map[uint64, []byte], `types.HeadersKeyPrefix`): Celestia block `height -> header_hash`. Populated in `BeginBlocker`; pruned to `params.max_header_hashes`.
- `messages` (collections.KeySet[[]byte], `types.MessageKeyPrefix`): Authorized Hyperlane message IDs for oneâ€‘time consumption by `keeper.Verify`.
- `params` (collections.Item[Params], `types.ParamsKeyPrefix`): Module parameters (e.g., `MaxHeaderHashes`, default 50,000).

## Messages (Tx RPCs)

Protobuf definitions: [`proto/celestia/zkism/v1/tx.proto`](../../proto/celestia/zkism/v1/tx.proto)

- CreateZKExecutionISM: Creates an ISM with initial trusted state and verifier configuration.
- UpdateZKExecutionISM: Verifies a state transition proof, then updates the ISMâ€™s trusted `state_root` and `height`.
- SubmitMessages: Verifies a state membership proof and authorizes the listed message IDs for oneâ€‘time processing.
- UpdateParams: Authorityâ€‘gated parameter update.

## SP1 Groth16 Verifier

Purpose: Verifies SP1 Groth16 proofs for any SP1 program by binding proofs to a specific verifying key and checking the program commitment and public values.

```golang
// SP1Groth16Verifier encapsulates the state required to verify Groth16 proofs
// under the SP1 scheme. It stores a verifying key and its hash prefix, which
// are used to check proof integrity and correctness.
type SP1Groth16Verifier struct {
	prefix [PrefixLen]byte
	vk     groth16.VerifyingKey
}
```

### SP1 Proof Format

- Total size: 260 bytes = 4â€‘byte prefix + 256â€‘byte Groth16 proof payload.
- The proof prefix must equal `sha256(vkBytes)[:PrefixLen]`, otherwise `ErrInvalidProofPrefix` is returned.
- An invalid proof length results in `ErrInvalidProofLength`.

### Public Witness Construction

In zk-SNARK systems, ð”½áµ£ denotes the scalar field of the curve in use, i.e. the finite field of order equal to the curve's group order, for example in BN254 `r` (â‰ˆ2Â²âµâ´).
The function `Fr()` reduces a byte string into an element of this field.

- `vk_element = Fr(program_vk_commitment)`
  where `program_vk_commitment` is a 32-byte commitment for the specific SP1 program.
- `inputs_element = Fr(HashBN254(public_values_bytes))`
  where `HashBN254` is `sha256(public_values)`, with the top 3 bits masked and the result interpreted as a scalar in ð”½áµ£.
- The public witness is `[vk_element, inputs_element]` (see `groth16.NewPublicWitness`).

### Verification

The `SP1Groth16Verifier` leverages `github.com/consensys/gnark` for groth16 proof verification. All invocations to the library are encapsulated within the `internal/groth16` package of this module.

```golang
func VerifyProof(proofBz, programVk, publicValues []byte) error
```

The `VerifyProof` method does the following:

- Validate length and prefix.
- Deserialize Groth16 proof from `proofBz[PrefixLen:]`.
- Compute `vk_element` and `inputs_element` from `programVk` and `publicValues`.
- Build a public witness and call gnark `groth16.Verify`.
- On failure, returns `ErrInvalidProof` (wrapped with the underlying error).

Reusability across SP1 programs:

- The `SP1Groth16Verifier` can verify any SP1 Groth16 program as long as you supply the correct pair `(program_vk_commitment, public_values_bytes)` for that program and the proof that was produced with the same verifying key (`vkBytes`).
- Programâ€‘specific logic lives in how you construct `public_values_bytes` offâ€‘chain; onâ€‘chain the verifier treats it as an opaque byte string that is hashed into the field.

### Public Values Encoding

- The verifier treats public values as opaque bytes that are hashed into a BN254 field element for verification. For SP1 programs, payloads are bincodeâ€‘encoded in rust using the default configuration: (little-endian, fixed-width integers, length-prefixed slices).
- Invariants checked before verification ensure consistency with onâ€‘chain state, and thus must be decodable by the module in order to consume the proof values and validate them against a trusted anchor. (e.g. header hash, trusted root/height for state transitions; state root for membership).

## Hyperlane Integration - Message Processing

- Hyperlane core calls `Verify(ism_id, metadata, message)`.
- The module checks if `message.Id()` is present in the set of authorized message IDs.
- If present, the ID is consumed (removed) and the method returns `true` to authorize processing.
- If absent, returns `false` and Hyperlane core must not process the message.

Thus, the expected flow is:

1) Offâ€‘chain prover generates a state transition proof; submit via `UpdateZKExecutionISM`.
2) Offâ€‘chain prover generates a membership proof for specific messages; submit via `SubmitMessages`.
3) Hyperlane core invokes `Verify` per message; the module authorizes exactly those preâ€‘submitted message IDs.

## Queries (gRPC/REST)

Protobuf definitions: [`proto/celestia/zkism/v1/query.proto`](../../proto/celestia/zkism/v1/query.proto)

- `Ism(id) -> ZKExecutionISM` â€” `GET /celestia/zkism/v1/isms/{id}`
- `Isms(pagination) -> [ZKExecutionISM]` â€” `GET /celestia/zkism/v1/isms`
- `Params() -> Params` â€” `GET /celestia/zkism/v1/params`

## Events

- `EventCreateZKExecutionISM` emitted on creation with all ISM fields.
- TODO: add event emission for proof submission rpcs.

## ABCI and Retention

The `x/zkism` module leverages the `BeginBlocker` lifecycle method of ABCI. For each block, it stores `header_hash` keyed by block `height` and prunes to `max_header_hashes` entries.

## Security Considerations

### Threat Model

The `x/zkism` module is designed under the assumption that:

- The on-chain verifier (`SP1Groth16Verifier`) is correct, deterministic, and cannot be subverted by malformed proofs.
- Cryptographic primitives (BN254 pairing operations, SHA-256, Groth16) are secure under their standard hardness assumptions.
- The off-chain prover is honest but untrusted: the verifier must reject any invalid or malformed proof.
- Hyperlane core will only process messages that the module explicitly authorizes.

Potential adversaries include:

- Malicious actors attempting to forge proofs or replay stale proofs.
- Entities submitting malformed or oversized inputs to trigger denial-of-service conditions.
- Adversaries attempting to exploit prover liveness delays to censor or stall message authorization.

### Security Assumptions

- Correctness of gnark's Groth16 implementation and its integration within the module.
- Collision resistance of SHA-256, used for both verifying key prefixes and hashing public values into field elements.
- Availability of trusted Celestia header hashes (populated in `BeginBlocker`) as an anchor for verifying state transition proofs.
- Off-chain SP1 program correctness: the verifier assumes public values were produced correctly by the corresponding SP1 program.

### Invariants

The module enforces the following invariants:

- Proof prefix must match the expected verifying key hash prefix.
- Proof length must be exactly 256 bytes + the 4 byte prefix, equalling a total of 260 bytes.
- State transition proofs must update trusted state monotonically: new height and associated state root replace prior values.
- State membership proofs must bind to a trusted root and authorize exactly the listed message IDs, which can each be consumed once.
- Once consumed, message IDs cannot be reused, preventing replay of previously authorized messages. Note that replay protection is also enforced by the [Hyperlane Mailbox](https://docs.hyperlane.xyz/docs/protocol/core/mailbox) configured with the ISM.

### Liveness and Availability Risks

- If the off-chain prover is delayed or unavailable, message authorization halts. Hyperlane will be unable to process new messages until valid proofs are submitted.
- The system does not guarantee liveness independently; availability is contingent on timely prover operation and proof relay.
- While delayed proofs cannot compromise safety (invalid messages will not be authorized), they may result in service degradation if provers are prevented from submitting in time.
- Mitigation relies on redundant or decentralized prover infrastructure to reduce single points of failure.

### Additional Considerations

- Parameters such as `MaxHeaderHashes` bound memory growth but also constrain the look-back window for valid proofs. This parameter should be tuned to balance liveness and resource limits.
- In the event of a prover liveness issue, the prover will be required to prove from beyond the look-back window up to an available header hash resume operation.
- Future extension to multiple proof systems will require addition of new public values types and validation against an on-chain trusted state anchor.

## Notes & TODOs

- [ ] CLI commands for proof submission rpcs are required, CLI for ism creation must be updated.
- [ ] Extension of the module to support consumption of other proof system types. Currently we only support Evolve's `ev-reth` execution.
- [ ] The Evolve `ev-reth` execution client can encapsulate the `Namespace` and `SequencerPublicKey` values within its state root, eliminating the need for validation within this verifier module.
