# `x/zkism`

## Abstract

The `x/zkism` module implements a Hyperlane Interchain Security Module (ISM) that authorizes Hyperlane message processing verified by zero‑knowledge proofs. 
The module implements a generic SP1 Groth16 proof verifier which is leveraged for verification of both state transition and state membership proofs generated by an off-chain proof system.

The module currently supports the following proof value types:
- `EvExectionProofValues`: State transition of a remote chain (updates trusted state root and height).
- `EvHyperlaneProofValues`: State membership of Hyperlane message IDs (authorizes specific messages for later processing).

The module integrates with Hyperlane core via the keeper’s `Verify` method. This is the integration point used by the Hyperlane ISM routing mechanism.
The `Verify` method consumes the stored message IDs and authorizes the message for processing.

## Concepts

- ZK Execution ISM: On‑chain record tracking a remote chain’s trusted state and the ZK verifier configuration used to validate proof statements.
- SP1 Groth16 Proofs: Proofs are verified against the SP1 groth16 verifier key, providing an SP1 program verifier key commitment and public values as public witness.
- Authorization Set: A transient set of message IDs. Membership proofs add message IDs; the Hyperlane router consumes them during message verification.

## State

- `isms` (collections.Map[uint64, ZKExecutionISM], `types.IsmsKeyPrefix`): Stores per‑ISM records containing trusted state and verifier configuration used during proof verification.
- `headers` (collections.Map[uint64, []byte], `types.HeadersKeyPrefix`): Celestia block `height -> header_hash`. Populated in `BeginBlocker`; pruned to `params.max_header_hashes`.
- `messages` (collections.KeySet[[]byte], `types.MessageKeyPrefix`): Authorized Hyperlane message IDs for one‑time consumption by `keeper.Verify`.
- `params` (collections.Item[Params], `types.ParamsKeyPrefix`): Module parameters (e.g., `MaxHeaderHashes`, default 50,000).

## Messages (Tx RPCs)

Protobuf definitions: [`proto/celestia/zkism/v1/tx.proto`](../../proto/celestia/zkism/v1/tx.proto)

- CreateZKExecutionISM: Creates an ISM with initial trusted state and verifier configuration.
- UpdateZKExecutionISM: Verifies a state transition proof, then updates the ISM’s trusted `state_root` and `height`.
- SubmitMessages: Verifies a state membership proof and authorizes the listed message IDs for one‑time processing.
- UpdateParams: Authority‑gated parameter update.

## SP1 Groth16 Verifier

Purpose: Verifies SP1 Groth16 proofs for any SP1 program by binding proofs to a specific verifying key and checking the program commitment and public values.

```golang
// SP1Groth16Verifier encapsulates the state required to verify Groth16 proofs
// under the SP1 scheme. It stores a verifying key and its hash prefix, which
// are used to check proof integrity and correctness.
type SP1Groth16Verifier struct {
	prefix [PrefixLen]byte
	vk     groth16.VerifyingKey
}
```

### SP1 Proof Format

- Total size: 260 bytes = 4‑byte prefix + 256‑byte Groth16 proof payload.
- The proof prefix must equal `sha256(vkBytes)[:PrefixLen]`, otherwise `ErrInvalidProofPrefix` is returned.
- An invalid proof length results in `ErrInvalidProofLength`.

- Public witness construction:
  - `vk_element = Fr(program_vk_commitment)` where `program_vk_commitment` is a 32‑byte commitment for the specific SP1 program.
  - `inputs_element = Fr(HashBN254(public_values_bytes))` where `HashBN254` is `sha256(public_values)`, with the top 3 bits masked, interpreted as a BN254 scalar.
  - The public witness is `[vk_element, inputs_element]` (see `groth16.NewPublicWitness`).

### Verification algorithm

The `SP1Groth16Verifier` leverages `github.com/consensys/gnark` for groth16 proof verification. All invocations to the library are encapsulated within the `internal/groth16` package of this module.

```golang
func VerifyProof(proofBz, programVk, publicValues []byte) error
```

The `VerifyProof` method does the following:
- Validate length and prefix.
- Deserialize Groth16 proof from `proofBz[PrefixLen:]`.
- Compute `vk_element` and `inputs_element` from `programVk` and `publicValues`.
- Build a public witness and call gnark `groth16.Verify`.
- On failure, returns `ErrInvalidProof` (wrapped with the underlying error).

Reusability across SP1 programs:
- The `SP1Groth16Verifier` can verify any SP1 Groth16 program as long as you supply the correct pair `(program_vk_commitment, public_values_bytes)` for that program and the proof that was produced with the same verifying key (`vkBytes`).
- Program‑specific logic lives in how you construct `public_values_bytes` off‑chain; on‑chain the verifier treats it as an opaque byte string that is hashed into the field.

### Public Values Encoding

- The verifier treats public values as opaque bytes that are hashed into a BN254 field element for verification. For SP1 programs, payloads are bincode‑encoded in rust using the default configuration: (little-endian, fixed-width integers, length-prefixed slices).
- Invariants checked before verification ensure consistency with on‑chain state, and thus must be decodable by the module in order to consume the proof values and validate them against a trusted anchor. (e.g. header hash, trusted root/height for state transitions; state root for membership).

## Hyperlane Integration - Message Processing

- Hyperlane core calls `Verify(ism_id, metadata, message)`.
- The module checks if `message.Id()` is present in the set of authorized message IDs.
- If present, the ID is consumed (removed) and the method returns `true` to authorize processing.
- If absent, returns `false` and Hyperlane core must not process the message.

Thus, the expected flow is:
1) Off‑chain prover generates a state transition proof; submit via `UpdateZKExecutionISM`.
2) Off‑chain prover generates a membership proof for specific messages; submit via `SubmitMessages`.
3) Hyperlane core invokes `Verify` per message; the module authorizes exactly those pre‑submitted message IDs.

## Queries (gRPC/REST)

Protobuf definitions: [`proto/celestia/zkism/v1/query.proto`](../../proto/celestia/zkism/v1/query.proto)

- `Ism(id) -> ZKExecutionISM` — `GET /celestia/zkism/v1/isms/{id}`
- `Isms(pagination) -> [ZKExecutionISM]` — `GET /celestia/zkism/v1/isms`
- `Params() -> Params` — `GET /celestia/zkism/v1/params`

## Events

- `EventCreateZKExecutionISM` emitted on creation with all ISM fields.
- TODO: add event emission for proof submission rpcs.

## ABCI and Retention

The `x/zkism` module leverages the `BeginBlocker` lifecycle method of ABCI. For each block, it stores `header_hash` keyed by block `height` and prunes to `max_header_hashes` entries.

## Notes & TODOs

- SubmitMessages currently checks only `public_values.StateRoot == ism.state_root` prior to verification
  - In order to prevent missing a proof submission window we must allow state root lookup against a historical height(see inline TODO in `msg_server.go`).
- CLI `create` command is scaffolded and needs additional flags for full ISM configuration.
- CLI commands for proof submission rpcs are required.
- Extension of the module to support consumption of other proof system types. Currently we only support Evolve `ev-reth` execution.
