package types

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
)

type StateTransitionPublicValues struct {
	// TrustedState is the trusted state before the state transition.
	TrustedState []byte
	// StateSize is the size of the trusted state.
	NewTrustedState []byte
}

// String implements the fmt.Stringer interface.
func (p *StateTransitionPublicValues) String() string {
	return fmt.Sprintf(`PublicInputs{
	TrustedState: %s,
	NewTrustedState:     %s,
}`,
		hex.EncodeToString(p.TrustedState[:]),
		hex.EncodeToString(p.TrustedState[:]),
	)
}

func (pi *StateTransitionPublicValues) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	// write length of TrustedState
	l := uint64(len(pi.TrustedState))
	if err := binary.Write(&buf, binary.LittleEndian, l); err != nil {
		return nil, err
	}

	// write TrustedState
	if _, err := buf.Write(pi.TrustedState); err != nil {
		return nil, err
	}

	// write NewTrustedState
	if _, err := buf.Write(pi.NewTrustedState); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (pi *StateTransitionPublicValues) Unmarshal(data []byte) error {
	buf := bytes.NewReader(data)

	// read length of TrustedState
	var l uint64
	if err := binary.Read(buf, binary.LittleEndian, &l); err != nil {
		return err
	}

	// read TrustedState
	pi.TrustedState = make([]byte, l)
	if _, err := io.ReadFull(buf, pi.TrustedState); err != nil {
		return err
	}

	// everything else becomes NewTrustedState
	remaining, err := io.ReadAll(buf)
	if err != nil {
		return err
	}
	pi.NewTrustedState = remaining

	return nil
}

// EvExecutionPublicValues defines the set of public values associated with a proof generated by a ZK program.
type EvExecutionPublicValues struct {
	// PrevCelestiaHeaderHash is the hash of the celestia header at which previous_height is available.
	PrevCelestiaHeaderHash [32]byte
	// PreviousCelestiaHeight is the height of the celestia header at which previous_height is available.
	PrevCelestiaHeight uint64
	// CelestiaHeaderHash is the hash of the celestia header at which new_height is available.
	CelestiaHeaderHash [32]byte
	// CelestiaHeight is the height of the celestia header at which new_height is available.
	CelestiaHeight uint64
	// TrustedHeight is the trusted block height from which we are updating.
	TrustedHeight uint64
	// TrustedStateRoot is the trusted state root from which we are updating.
	TrustedStateRoot [32]byte
	// NewHeight is the block height associated with the new header.
	NewHeight uint64
	// NewStateRoot is the resulting state root after applying the state transition.
	NewStateRoot [32]byte
	// Namespace is the celestia namespace used by the application.
	Namespace [29]byte
	// PublicKey is the public key of the sequencer.
	PublicKey [32]byte
}

// String implements the fmt.Stringer interface.
func (p *EvExecutionPublicValues) String() string {
	return fmt.Sprintf(`PublicInputs{
	PrevCelestiaHeaderHash: %s,
	PrevCelestiaHeight:     %d,
	CelestiaHeaderHash: %s,
	CelestiaHeight:     %d,
	TrustedHeight:      %d,
	TrustedStateRoot:   %s,
	NewHeight:          %d,
	NewStateRoot:       %s,
	Namespace:          %s,
	PublicKey:          %s,
}`,
		hex.EncodeToString(p.PrevCelestiaHeaderHash[:]),
		p.PrevCelestiaHeight,
		hex.EncodeToString(p.CelestiaHeaderHash[:]),
		p.CelestiaHeight,
		p.TrustedHeight,
		hex.EncodeToString(p.TrustedStateRoot[:]),
		p.NewHeight,
		hex.EncodeToString(p.NewStateRoot[:]),
		hex.EncodeToString(p.Namespace[:]),
		hex.EncodeToString(p.PublicKey[:]),
	)
}

// Marshal encodes the EvExecutionPublicValues struct into a bincode-compatible byte slice.
// The output format uses Rust bincode's default configuration: (little-endian, fixed-width integers, length-prefixed slices).
func (pi *EvExecutionPublicValues) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	if err := writeBytes(&buf, pi.PrevCelestiaHeaderHash[:]); err != nil {
		return nil, fmt.Errorf("write PrevCelestiaHeaderHash: %w", err)
	}

	if err := binary.Write(&buf, binary.LittleEndian, pi.PrevCelestiaHeight); err != nil {
		return nil, fmt.Errorf("write PreviousCelestiaHeight: %w", err)
	}

	if err := writeBytes(&buf, pi.CelestiaHeaderHash[:]); err != nil {
		return nil, fmt.Errorf("write CelestiaHeaderHash: %w", err)
	}

	if err := binary.Write(&buf, binary.LittleEndian, pi.CelestiaHeight); err != nil {
		return nil, fmt.Errorf("write NewCelestiaHeight: %w", err)
	}

	if err := binary.Write(&buf, binary.LittleEndian, pi.TrustedHeight); err != nil {
		return nil, fmt.Errorf("write TrustedHeight: %w", err)
	}

	if err := writeBytes(&buf, pi.TrustedStateRoot[:]); err != nil {
		return nil, fmt.Errorf("write TrustedStateRoot: %w", err)
	}

	if err := binary.Write(&buf, binary.LittleEndian, pi.NewHeight); err != nil {
		return nil, fmt.Errorf("write NewHeight: %w", err)
	}

	if err := writeBytes(&buf, pi.NewStateRoot[:]); err != nil {
		return nil, fmt.Errorf("write NewStateRoot: %w", err)
	}

	if err := writeBytes(&buf, pi.Namespace[:]); err != nil {
		return nil, fmt.Errorf("write Namespace: %w", err)
	}

	if err := writeBytes(&buf, pi.PublicKey[:]); err != nil {
		return nil, fmt.Errorf("write PublicKey: %w", err)
	}

	return buf.Bytes(), nil
}

// Unmarshal decodes a bincode-serialized EvExecutionPublicValues struct.
// This function expects the input byte slice to be encoded using Rust bincode's
// default configuration: (little-endian, fixed-width integers, length-prefixed slices).
func (pi *EvExecutionPublicValues) Unmarshal(data []byte) error {
	buf := bytes.NewReader(data)

	if err := readBytes(buf, pi.PrevCelestiaHeaderHash[:]); err != nil {
		return fmt.Errorf("read PrevCelestiaHeaderHash: %w", err)
	}

	if err := binary.Read(buf, binary.LittleEndian, &pi.PrevCelestiaHeight); err != nil {
		return fmt.Errorf("read PreviousCelestiaHeight: %w", err)
	}

	if err := readBytes(buf, pi.CelestiaHeaderHash[:]); err != nil {
		return fmt.Errorf("read CelestiaHeaderHash: %w", err)
	}

	if err := binary.Read(buf, binary.LittleEndian, &pi.CelestiaHeight); err != nil {
		return fmt.Errorf("read NewCelestiaHeight: %w", err)
	}

	if err := binary.Read(buf, binary.LittleEndian, &pi.TrustedHeight); err != nil {
		return fmt.Errorf("read TrustedHeight: %w", err)
	}

	if err := readBytes(buf, pi.TrustedStateRoot[:]); err != nil {
		return fmt.Errorf("read TrustedStateRoot: %w", err)
	}

	if err := binary.Read(buf, binary.LittleEndian, &pi.NewHeight); err != nil {
		return fmt.Errorf("read NewHeight: %w", err)
	}

	if err := readBytes(buf, pi.NewStateRoot[:]); err != nil {
		return fmt.Errorf("read NewStateRoot: %w", err)
	}

	if err := readBytes(buf, pi.Namespace[:]); err != nil {
		return fmt.Errorf("read Namespace: %w", err)
	}

	if err := readBytes(buf, pi.PublicKey[:]); err != nil {
		return fmt.Errorf("read PublicKey: %w", err)
	}

	if buf.Len() != 0 {
		return errors.New("trailing data after decoding")
	}

	return nil
}

// EvHyperlanePublicValues are the set of proof public values used when verifying state membership inclusion of
// Hyperlane messages.
type EvHyperlanePublicValues struct {
	StateRoot  [32]byte
	MessageIds [][32]byte
}

// Marshal encodes the EvHyperlanePublicValues struct into a bincode-compatible byte slice.
// The output format uses Rust bincode's default configuration: (little-endian, fixed-width integers, length-prefixed slices).
func (m *EvHyperlanePublicValues) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	if err := writeBytes(&buf, m.StateRoot[:]); err != nil {
		return nil, fmt.Errorf("write StateRoot: %w", err)
	}

	count := uint64(len(m.MessageIds))
	if err := binary.Write(&buf, binary.LittleEndian, count); err != nil {
		return nil, fmt.Errorf("write MessageIds length: %w", err)
	}

	for i, id := range m.MessageIds {
		if err := writeBytes(&buf, id[:]); err != nil {
			return nil, fmt.Errorf("write MessageIds[%d]: %w", i, err)
		}
	}

	return buf.Bytes(), nil
}

// Unmarshal decodes a bincode-serialized EvHyperlanePublicValues struct.
// This function expects the input byte slice to be encoded using Rust bincode's
// default configuration: (little-endian, fixed-width integers, length-prefixed slices).
func (m *EvHyperlanePublicValues) Unmarshal(data []byte) error {
	buf := bytes.NewReader(data)

	if _, err := buf.Read(m.StateRoot[:]); err != nil {
		return fmt.Errorf("read StateRoot: %w", err)
	}

	var count uint64 // read uint64 (little-endian) length prefix
	if err := binary.Read(buf, binary.LittleEndian, &count); err != nil {
		return fmt.Errorf("read message ids length: %w", err)
	}

	remaining := buf.Len()
	if remaining < int(count*32) {
		return fmt.Errorf("buffer too short: need %d, have %d", count*32, remaining)
	}

	m.MessageIds = make([][32]byte, count)
	for i := 0; i < int(count); i++ {
		if _, err := buf.Read(m.MessageIds[i][:]); err != nil {
			return fmt.Errorf("read message_id %d: %w", i, err)
		}
	}

	return nil
}

func readBytes(buf *bytes.Reader, dst []byte) error {
	n, err := io.ReadFull(buf, dst)
	if err != nil {
		return err
	}
	if n != len(dst) {
		return fmt.Errorf("expected %d bytes, got %d", len(dst), n)
	}
	return nil
}

func writeBytes(w io.Writer, b []byte) error {
	_, err := w.Write(b)
	return err
}
