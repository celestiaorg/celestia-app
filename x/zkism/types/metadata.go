package types

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
)

type ProofType uint8

const (
	ProofTypeSP1Groth16 ProofType = iota
)

// ZkExecutionISMMetadata contains the ZK proof and verification data.
type ZkExecutionISMMetadata struct {
	// ProofType is the type of ZK proof system used. Default: Groth16.
	ProofType ProofType
	// Proof is the ZK proof bytes.
	Proof []byte
	// PublicInputs defines the public values used for proof verification.
	PublicInputs PublicInputs
	// MerkleProofs defines a set of merkle proofs used for proving inclusion of a message - TBD.
	MerkleProofs [][]byte
}

// NewZkExecutionISMMetadata parses a raw metadata byte slice into a structured format.
// The ZK Execution ISM metadata follows the following format:
// [0]          - Type of the ZK Proof System used (e.g. Groth16)
// [1:5]        - Size of the ZK Proof, N, if it exists
// [5:N+5]      - The ZK proof
// [N+5:N+9]    - Size of public inputs, M
// [N+9:N+9+M]  - Public inputs serialized using Rust bincode default format.
// [N+9+M:]     - Merkle Proofs
func NewZkExecutionISMMetadata(metadata []byte) (ZkExecutionISMMetadata, error) {
	if len(metadata) < 5 {
		return ZkExecutionISMMetadata{}, errors.New("metadata too short to contain proof type and size")
	}

	offset := 0

	// [0] - Type of the ZK Proof System used
	proofType := ProofType(metadata[offset])
	if proofType != ProofTypeSP1Groth16 {
		return ZkExecutionISMMetadata{}, fmt.Errorf("invalid proof type: expected %d, got %d", ProofTypeSP1Groth16, proofType)
	}

	offset++

	// [1:5] - Size of the proof, N (uint32)
	proofSize := binary.BigEndian.Uint32(metadata[offset : offset+4])
	offset += 4
	if len(metadata[offset:]) < int(proofSize) {
		return ZkExecutionISMMetadata{}, fmt.Errorf("metadata too short to contain full proof: expected %d bytes", proofSize)
	}

	// [5:N+5] - ZK proof
	proof := metadata[offset : offset+int(proofSize)]
	offset += int(proofSize)

	// [N+5:N+9] - Size of public inputs, M (uint32)
	if len(metadata[offset:]) < 4 {
		return ZkExecutionISMMetadata{}, errors.New("metadata too short to contain number of public inputs")
	}

	pubInputsSize := binary.BigEndian.Uint32(metadata[offset : offset+4])
	offset += 4

	if len(metadata[offset:]) < int(pubInputsSize) {
		return ZkExecutionISMMetadata{}, fmt.Errorf("metadata too short to contain public inputs: expected %d bytes", pubInputsSize)
	}

	var publicInputs PublicInputs
	if pubInputsSize != 0 {
		// [N+9:N+9+M] - bincode-encoded PublicInputs
		pubInputsBz := metadata[offset : offset+int(pubInputsSize)]
		offset += int(pubInputsSize)

		if err := publicInputs.Unmarshal(pubInputsBz); err != nil {
			return ZkExecutionISMMetadata{}, fmt.Errorf("failed to decode PublicInputs: %w", err)
		}
	}

	// [remainder] - merkle proofs (assume 32 bytes each)
	merkleProofs := make([][]byte, 0)
	for len(metadata[offset:]) >= 32 {
		merkleProofs = append(merkleProofs, metadata[offset:offset+32])
		offset += 32
	}

	// if there's leftover data less than 32 bytes, it's likely malformed
	if len(metadata[offset:]) > 0 {
		return ZkExecutionISMMetadata{}, errors.New("trailing bytes after parsing Merkle proofs; possibly malformed metadata")
	}

	return ZkExecutionISMMetadata{
		ProofType:    proofType,
		Proof:        proof,
		PublicInputs: publicInputs,
		MerkleProofs: merkleProofs,
	}, nil
}

// HasExecutionProof returns true if ZkExecutionISMMetadata contains an execution proof, otherwise false.
func (meta ZkExecutionISMMetadata) HasExecutionProof() bool {
	return len(meta.Proof) > 0
}

// PublicInputs defines the set of public values associated with a proof generated by a ZK program.
type PublicInputs struct {
	// CelestiaHeaderHash is the hash of the celestia header at which new_height is available.
	CelestiaHeaderHash [32]byte
	// TrustedHeight is the trusted block height from which we are updating.
	TrustedHeight uint64
	// TrustedStateRoot is the trusted state root from which we are updating.
	TrustedStateRoot [32]byte
	// NewHeight is the block height associated with the new header.
	NewHeight uint64
	// NewStateRoot is the resulting state root after applying the state transition.
	NewStateRoot [32]byte
}

// String implements the fmt.Stringer interface.
func (p *PublicInputs) String() string {
	return fmt.Sprintf(`PublicInputs{
  CelestiaHeaderHash: %s,
  TrustedHeight:      %d,
  TrustedStateRoot:   %s,
  NewHeight:          %d,
  NewStateRoot:       %s,
}`,
		hex.EncodeToString(p.CelestiaHeaderHash[:]),
		p.TrustedHeight,
		hex.EncodeToString(p.TrustedStateRoot[:]),
		p.NewHeight,
		hex.EncodeToString(p.NewStateRoot[:]),
	)
}

// Marshal encodes the PublicInputs struct into a bincode-compatible byte slice.
// The output format uses Rust bincode's default configuration: (little-endian, fixed-width integers, length-prefixed slices).
func (pi *PublicInputs) Marshal() ([]byte, error) {
	var buf bytes.Buffer

	if err := writeBytes(&buf, pi.CelestiaHeaderHash[:]); err != nil {
		return nil, fmt.Errorf("write CelestiaHeaderHash: %w", err)
	}

	if err := binary.Write(&buf, binary.LittleEndian, pi.TrustedHeight); err != nil {
		return nil, fmt.Errorf("write TrustedHeight: %w", err)
	}

	if err := writeBytes(&buf, pi.TrustedStateRoot[:]); err != nil {
		return nil, fmt.Errorf("write TrustedStateRoot: %w", err)
	}

	if err := binary.Write(&buf, binary.LittleEndian, pi.NewHeight); err != nil {
		return nil, fmt.Errorf("write NewHeight: %w", err)
	}

	if err := writeBytes(&buf, pi.NewStateRoot[:]); err != nil {
		return nil, fmt.Errorf("write NewStateRoot: %w", err)
	}

	return buf.Bytes(), nil
}

// Unmarshal decodes a bincode-serialized PublicInputs struct.
// This function expects the input byte slice to be encoded using Rust bincode's
// default configuration: (little-endian, fixed-width integers, length-prefixed slices).
func (pi *PublicInputs) Unmarshal(data []byte) error {
	buf := bytes.NewReader(data)

	if err := readBytes(buf, pi.CelestiaHeaderHash[:]); err != nil {
		return fmt.Errorf("read CelestiaHeaderHash: %w", err)
	}

	if err := binary.Read(buf, binary.LittleEndian, &pi.TrustedHeight); err != nil {
		return fmt.Errorf("read TrustedHeight: %w", err)
	}

	if err := readBytes(buf, pi.TrustedStateRoot[:]); err != nil {
		return fmt.Errorf("read TrustedStateRoot: %w", err)
	}

	if err := binary.Read(buf, binary.LittleEndian, &pi.NewHeight); err != nil {
		return fmt.Errorf("read NewHeight: %w", err)
	}

	if err := readBytes(buf, pi.NewStateRoot[:]); err != nil {
		return fmt.Errorf("read NewStateRoot: %w", err)
	}

	if buf.Len() != 0 {
		return errors.New("trailing data after decoding")
	}

	return nil
}

func readBytes(buf *bytes.Reader, dst []byte) error {
	n, err := io.ReadFull(buf, dst)
	if err != nil {
		return err
	}
	if n != len(dst) {
		return fmt.Errorf("expected %d bytes, got %d", len(dst), n)
	}
	return nil
}

func writeBytes(w io.Writer, b []byte) error {
	_, err := w.Write(b)
	return err
}
