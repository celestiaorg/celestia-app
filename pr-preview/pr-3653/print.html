<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Celestia App Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Celestia App Specifications</a></li><li class="chapter-item expanded "><a href="specs/index.html"><strong aria-hidden="true">1.</strong> Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specs/data_structures.html"><strong aria-hidden="true">1.1.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="specs/namespace.html"><strong aria-hidden="true">1.2.</strong> Namespace</a></li><li class="chapter-item expanded "><a href="specs/shares.html"><strong aria-hidden="true">1.3.</strong> Shares</a></li><li class="chapter-item expanded "><a href="specs/consensus.html"><strong aria-hidden="true">1.4.</strong> Consensus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specs/cat_pool.html"><strong aria-hidden="true">1.4.1.</strong> CAT Pool</a></li></ol></li><li class="chapter-item expanded "><a href="specs/block_proposer.html"><strong aria-hidden="true">1.5.</strong> Block Proposer</a></li><li class="chapter-item expanded "><a href="specs/block_validity_rules.html"><strong aria-hidden="true">1.6.</strong> Block Validity Rules</a></li><li class="chapter-item expanded "><a href="specs/ante_handler.html"><strong aria-hidden="true">1.7.</strong> AnteHandler</a></li><li class="chapter-item expanded "><a href="specs/fraud_proofs.html"><strong aria-hidden="true">1.8.</strong> Fraud Proofs</a></li><li class="chapter-item expanded "><a href="specs/networking.html"><strong aria-hidden="true">1.9.</strong> Networking</a></li><li class="chapter-item expanded "><a href="specs/public_key_cryptography.html"><strong aria-hidden="true">1.10.</strong> Public-Key Cryptography</a></li><li class="chapter-item expanded "><a href="specs/data_square_layout.html"><strong aria-hidden="true">1.11.</strong> Data Square Layout</a></li><li class="chapter-item expanded "><a href="specs/resource_pricing.html"><strong aria-hidden="true">1.12.</strong> Resource Pricing</a></li><li class="chapter-item expanded "><a href="specs/multisig.html"><strong aria-hidden="true">1.13.</strong> Multisig</a></li></ol></li><li class="chapter-item expanded "><a href="specs/state_machine_modules.html"><strong aria-hidden="true">2.</strong> State Machine Modules</a></li><li class="chapter-item expanded "><a href="specs/params.html"><strong aria-hidden="true">3.</strong> Mainnet Parameters</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Celestia App Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/celestiaorg/celestia-app" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="celestia-app-specifications"><a class="header" href="#celestia-app-specifications">Celestia App Specifications</a></h1>
<ul>
<li><a href="./specs/index.html">Specification</a>
<ul>
<li><a href="./specs/data_structures.html">Data Structures</a></li>
<li><a href="./specs/namespace.html">Namespace</a></li>
<li><a href="./specs/shares.html">Shares</a></li>
<li><a href="./specs/consensus.html">Consensus</a>
<ul>
<li><a href="./specs/cat_pool.html">CAT Pool</a></li>
</ul>
</li>
<li><a href="./specs/block_proposer.html">Block Proposer</a></li>
<li><a href="./specs/block_validity_rules.html">Block Validity Rules</a></li>
<li><a href="./specs/ante_handler.html">AnteHandler</a></li>
<li><a href="./specs/fraud_proofs.html">Fraud Proofs</a></li>
<li><a href="./specs/networking.html">Networking</a></li>
<li><a href="./specs/public_key_cryptography.html">Public-Key Cryptography</a></li>
<li><a href="./specs/data_square_layout.html">Data Square Layout</a></li>
<li><a href="./specs/resource_pricing.html">Resource Pricing</a></li>
<li><a href="./specs/multisig.html">Multisig</a></li>
</ul>
</li>
<li><a href="./specs/state_machine_modules.html">State Machine Modules</a></li>
<li><a href="./specs/params.html">Mainnet Parameters</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specification"><a class="header" href="#specification">Specification</a></h1>
<ul>
<li><a href="specs/./data_structures.html">Data Structures</a></li>
<li><a href="specs/./namespace.html">Namespace</a></li>
<li><a href="specs/./shares.html">Shares</a></li>
<li><a href="specs/./consensus.html">Consensus</a>
<ul>
<li><a href="specs/./cat_pool.html">CAT Pool</a></li>
</ul>
</li>
<li><a href="specs/./block_proposer.html">Block Proposer</a></li>
<li><a href="specs/./block_validity_rules.html">Block Validity Rules</a></li>
<li><a href="specs/./networking.html">Networking</a></li>
<li><a href="specs/./public_key_cryptography.html">Public-Key Cryptography</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<!-- toc -->
<h2 id="data-structures-overview"><a class="header" href="#data-structures-overview">Data Structures Overview</a></h2>
<p><img src="specs/./figures/block_data_structures.svg" alt="fig: Block data structures." /></p>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th></tr></thead><tbody>
<tr><td><code>Amount</code></td><td><code>uint64</code></td></tr>
<tr><td><code>Graffiti</code></td><td><code>byte[MAX_GRAFFITI_BYTES]</code></td></tr>
<tr><td><a href="specs/data_structures.html#hashdigest"><code>HashDigest</code></a></td><td><code>byte[32]</code></td></tr>
<tr><td><code>Height</code></td><td><code>int64</code></td></tr>
<tr><td><code>Nonce</code></td><td><code>uint64</code></td></tr>
<tr><td><code>Round</code></td><td><code>int32</code></td></tr>
<tr><td><code>StateSubtreeID</code></td><td><code>byte</code></td></tr>
<tr><td><a href="specs/data_structures.html#timestamp"><code>Timestamp</code></a></td><td><code>google.protobuf.Timestamp</code></td></tr>
<tr><td><code>VotingPower</code></td><td><code>uint64</code></td></tr>
</tbody></table>
</div>
<h2 id="blockchain-data-structures"><a class="header" href="#blockchain-data-structures">Blockchain Data Structures</a></h2>
<h3 id="block"><a class="header" href="#block">Block</a></h3>
<p>Blocks are the top-level data structure of the Celestia blockchain.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>header</code></td><td><a href="specs/data_structures.html#header">Header</a></td><td>Block header. Contains primarily identification info and commitments.</td></tr>
<tr><td><code>availableDataHeader</code></td><td><a href="specs/data_structures.html#availabledataheader">AvailableDataHeader</a></td><td>Header of available data. Contains commitments to erasure-coded data.</td></tr>
<tr><td><code>availableData</code></td><td><a href="specs/data_structures.html#availabledata">AvailableData</a></td><td>Data that is erasure-coded for availability.</td></tr>
<tr><td><code>lastCommit</code></td><td><a href="specs/data_structures.html#commit">Commit</a></td><td>Previous block's Tendermint commit.</td></tr>
</tbody></table>
</div>
<h3 id="header"><a class="header" href="#header">Header</a></h3>
<p>Block header, which is fully downloaded by both full clients and light clients.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>version</code></td><td><a href="specs/data_structures.html#consensusversion">ConsensusVersion</a></td><td>The consensus version struct.</td></tr>
<tr><td><code>chainID</code></td><td><code>string</code></td><td>The <code>CHAIN_ID</code>.</td></tr>
<tr><td><code>height</code></td><td><a href="specs/data_structures.html#type-aliases">Height</a></td><td>Block height. The genesis block is at height <code>1</code>.</td></tr>
<tr><td><code>timestamp</code></td><td><a href="specs/data_structures.html#timestamp">Timestamp</a></td><td>Timestamp of this block.</td></tr>
<tr><td><code>lastHeaderHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Previous block's header hash.</td></tr>
<tr><td><code>lastCommitHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Previous block's Tendermint commit hash.</td></tr>
<tr><td><code>consensusHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Hash of <a href="specs/data_structures.html#consensus-parameters">consensus parameters</a> for this block.</td></tr>
<tr><td><code>AppHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>The <a href="specs/data_structures.html#state">state root</a> after the previous block's transactions are applied.</td></tr>
<tr><td><code>availableDataOriginalSharesUsed</code></td><td><code>uint64</code></td><td>The number of shares used in the <a href="specs/data_structures.html#arranging-available-data-into-shares">original data square</a> that are not <a href="specs/./consensus.html#reserved-namespace-ids">tail padding</a>.</td></tr>
<tr><td><code>availableDataRoot</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Root of <a href="specs/data_structures.html#availabledataheader">commitments to erasure-coded data</a>.</td></tr>
<tr><td><code>proposerAddress</code></td><td><a href="specs/data_structures.html#address">Address</a></td><td>Address of this block's proposer.</td></tr>
</tbody></table>
</div>
<p>The size of the <a href="specs/data_structures.html#arranging-available-data-into-shares">original data square</a>, <code>availableDataOriginalSquareSize</code>, isn't explicitly declared in the block header. Instead, it is implicitly computed as the smallest power of 2 whose square is at least <code>availableDataOriginalSharesUsed</code> (in other words, the smallest power of 4 that is at least <code>availableDataOriginalSharesUsed</code>).</p>
<p>The header hash is the <a href="specs/data_structures.html#hashing">hash</a> of the <a href="specs/data_structures.html#serialization">serialized</a> header.</p>
<h3 id="availabledataheader"><a class="header" href="#availabledataheader">AvailableDataHeader</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>rowRoots</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a><code>[]</code></td><td>Commitments to all erasure-coded data.</td></tr>
<tr><td><code>colRoots</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a><code>[]</code></td><td>Commitments to all erasure-coded data.</td></tr>
</tbody></table>
</div>
<p>The number of row/column roots of the original data <a href="specs/data_structures.html#share">shares</a> in <a href="specs/data_structures.html#arranging-available-data-into-shares">square layout</a> for this block. The <code>availableDataRoot</code> of the <a href="specs/data_structures.html#header">header</a> is computed using the compact row and column roots as described <a href="specs/data_structures.html#2d-reed-solomon-encoding-scheme">here</a>.</p>
<p>The number of row and column roots is each <code>availableDataOriginalSquareSize * 2</code>, and must be a power of 2. Note that the minimum <code>availableDataOriginalSquareSize</code> is 1 (not 0), therefore the number of row and column roots are each at least 2.</p>
<p>Implementations can prune rows containing only <a href="specs/./consensus.html#reserved-namespace-ids">tail padding</a> as they are implicitly available.</p>
<h3 id="availabledata"><a class="header" href="#availabledata">AvailableData</a></h3>
<p>Data that is <a href="specs/data_structures.html#erasure-coding">erasure-coded</a> for <a href="https://arxiv.org/abs/1809.09044">data availability checks</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>transactions</code></td><td><a href="specs/data_structures.html#transaction">Transaction</a></td><td>Transactions are ordinary Cosmos SDK transactions. For example: they may modify the validator set and token balances.</td></tr>
<tr><td><code>payForBlobData</code></td><td><a href="specs/data_structures.html#payforblobdata">PayForBlobData</a></td><td>PayForBlob data. Transactions that pay for blobs to be included.</td></tr>
<tr><td><code>blobData</code></td><td><a href="specs/data_structures.html#blobdata">BlobData</a></td><td>Blob data is arbitrary user submitted data that will be published to the Celestia blockchain.</td></tr>
</tbody></table>
</div>
<h3 id="commit"><a class="header" href="#commit">Commit</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>height</code></td><td><a href="specs/data_structures.html#type-aliases">Height</a></td><td>Block height.</td></tr>
<tr><td><code>round</code></td><td><a href="specs/data_structures.html#type-aliases">Round</a></td><td>Round. Incremented on view change.</td></tr>
<tr><td><code>headerHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Header hash of the previous block.</td></tr>
<tr><td><code>signatures</code></td><td><a href="specs/data_structures.html#commitsig">CommitSig</a><code>[]</code></td><td>List of signatures.</td></tr>
</tbody></table>
</div>
<h3 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h3>
<p>Timestamp is a <a href="specs/data_structures.html#type-aliases">type alias</a>.</p>
<p>Celestia uses <a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Timestamp"><code>google.protobuf.Timestamp</code></a> to represent time.</p>
<h3 id="hashdigest"><a class="header" href="#hashdigest">HashDigest</a></h3>
<p>HashDigest is a <a href="specs/data_structures.html#type-aliases">type alias</a>.</p>
<p>Output of the <a href="specs/data_structures.html#hashing">hashing</a> function. Exactly 256 bits (32 bytes) long.</p>
<h3 id="transactionfee"><a class="header" href="#transactionfee">TransactionFee</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>tipRate</code></td><td><code>uint64</code></td><td>The tip rate for this transaction.</td></tr>
</tbody></table>
</div>
<p>Abstraction over transaction fees.</p>
<h3 id="address"><a class="header" href="#address">Address</a></h3>
<p>Celestia supports <a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a> keys where <a href="https://github.com/cosmos/cosmos-sdk/blob/main/docs/architecture/adr-028-public-key-addresses.md">addresses</a> are 20 bytes in length.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>AccAddress</code></td><td><code>[20]byte</code></td><td>AccAddress a wrapper around bytes meant to represent an account address</td></tr>
</tbody></table>
</div>
<h3 id="commitsig"><a class="header" href="#commitsig">CommitSig</a></h3>
<pre><code class="language-C++">enum CommitFlag : uint8_t {
    CommitFlagAbsent = 1,
    CommitFlagCommit = 2,
    CommitFlagNil = 3,
};
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>commitFlag</code></td><td><code>CommitFlag</code></td><td></td></tr>
<tr><td><code>validatorAddress</code></td><td><a href="specs/data_structures.html#address">Address</a></td><td></td></tr>
<tr><td><code>timestamp</code></td><td><a href="specs/data_structures.html#timestamp">Timestamp</a></td><td></td></tr>
<tr><td><code>signature</code></td><td><a href="specs/data_structures.html#signature">Signature</a></td><td></td></tr>
</tbody></table>
</div>
<h3 id="signature"><a class="header" href="#signature">Signature</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>r</code></td><td><code>byte[32]</code></td><td><code>r</code> value of the signature.</td></tr>
<tr><td><code>s</code></td><td><code>byte[32]</code></td><td><code>s</code> value of signature.</td></tr>
</tbody></table>
</div>
<h2 id="consensusversion"><a class="header" href="#consensusversion">ConsensusVersion</a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>block</code></td><td><code>uint64</code></td><td>The <code>VERSION_BLOCK</code>.</td></tr>
<tr><td><code>app</code></td><td><code>uint64</code></td><td>The <code>VERSION_APP</code>.</td></tr>
</tbody></table>
</div>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Objects that are committed to or signed over require a canonical serialization. This is done using a deterministic (and thus, bijective) variant of protobuf defined <a href="https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-027-deterministic-protobuf-serialization.md">here</a>.</p>
<p>Note: there are two requirements for a serialization scheme, should this need to be changed:</p>
<ol>
<li>Must be bijective.</li>
<li>Serialization must include the length of dynamic structures (e.g. arrays with variable length).</li>
</ol>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<!-- disable markdown link check for doi.org because it frequently fails -->
<!-- markdown-link-check-disable -->
<p>All protocol-level hashing is done using SHA-2-256 as defined in <a href="https://doi.org/10.6028/NIST.FIPS.180-4">FIPS 180-4</a>. SHA-2-256 outputs a digest that is 256 bits (i.e. 32 bytes) long.</p>
<!-- markdown-link-check-enable -->
<p>Libraries implementing SHA-2-256 are available in Go (<a href="https://pkg.go.dev/crypto/sha256">https://pkg.go.dev/crypto/sha256</a>) and Rust (<a href="https://docs.rs/sha2">https://docs.rs/sha2</a>).</p>
<p>Unless otherwise indicated explicitly, objects are first <a href="specs/data_structures.html#serialization">serialized</a> before being hashed.</p>
<h2 id="merkle-trees"><a class="header" href="#merkle-trees">Merkle Trees</a></h2>
<p>Merkle trees are used to authenticate various pieces of data across the Celestia stack, including transactions, blobs, the validator set, etc. This section provides an overview of the different tree types used, and specifies how to construct them.</p>
<h3 id="binary-merkle-tree"><a class="header" href="#binary-merkle-tree">Binary Merkle Tree</a></h3>
<p>Binary Merkle trees are constructed in the same fashion as described in <a href="https://tools.ietf.org/html/rfc6962">Certificate Transparency (RFC-6962)</a>, except for using <a href="specs/data_structures.html#hashing">a different hashing function</a>. Leaves are hashed once to get leaf node values and internal node values are the hash of the concatenation of their children (either leaf nodes or other internal nodes).</p>
<p>Nodes contain a single field:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>v</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Node value.</td></tr>
</tbody></table>
</div>
<p>The base case (an empty tree) is defined as the <a href="specs/data_structures.html#hashing">hash</a> of the empty string:</p>
<pre><code class="language-C++">node.v = 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</code></pre>
<p>For leaf node <code>node</code> of leaf data <code>d</code>:</p>
<pre><code class="language-C++">node.v = h(0x00, serialize(d))
</code></pre>
<p>For internal node <code>node</code> with children <code>l</code> and <code>r</code>:</p>
<pre><code class="language-C++">node.v = h(0x01, l.v, r.v)
</code></pre>
<p>Note that rather than duplicating the last node if there are an odd number of nodes (the <a href="https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/consensus/merkle.cpp#L9-L43">Bitcoin design</a>), trees are allowed to be imbalanced. In other words, the height of each leaf may be different. For an example, see Section 2.1.3 of <a href="https://tools.ietf.org/html/rfc6962#section-2.1.3">Certificate Transparency (RFC-6962)</a>.</p>
<p>Leaves and internal nodes are hashed differently: the one-byte <code>0x00</code> is prepended for leaf nodes while <code>0x01</code> is prepended for internal nodes. This avoids a second-preimage attack <a href="https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack">where internal nodes are presented as leaves</a> trees with leaves at different heights.</p>
<h4 id="binarymerkletreeinclusionproof"><a class="header" href="#binarymerkletreeinclusionproof">BinaryMerkleTreeInclusionProof</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>siblings</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a><code>[]</code></td><td>Sibling hash values, ordered starting from the leaf's neighbor.</td></tr>
</tbody></table>
</div>
<p>A proof for a leaf in a <a href="specs/data_structures.html#binary-merkle-tree">binary Merkle tree</a>, as per Section 2.1.1 of <a href="https://tools.ietf.org/html/rfc6962#section-2.1.1">Certificate Transparency (RFC-6962)</a>.</p>
<h3 id="namespace-merkle-tree"><a class="header" href="#namespace-merkle-tree">Namespace Merkle Tree</a></h3>
<!-- disable markdown link check for bitcointalk.org because it frequently fails -->
<!-- markdown-link-check-disable -->
<p><a href="specs/./shares.html">Shares</a> in Celestia are associated with a provided <em>namespace</em>. The Namespace Merkle Tree (NMT) is a variation of the <a href="https://eprint.iacr.org/2018/642">Merkle Interval Tree</a>, which is itself an extension of the <a href="https://bitcointalk.org/index.php?topic=845978.0">Merkle Sum Tree</a>. It allows for compact proofs around the inclusion or exclusion of shares with particular namespace IDs.</p>
<!-- markdown-link-check-enable -->
<p>Nodes contain three fields:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>n_min</code></td><td><a href="specs/./namespace.html">Namespace</a></td><td>Min namespace in subtree rooted at this node.</td></tr>
<tr><td><code>n_max</code></td><td><a href="specs/./namespace.html">Namespace</a></td><td>Max namespace in subtree rooted at this node.</td></tr>
<tr><td><code>v</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Node value.</td></tr>
</tbody></table>
</div>
<p>The base case (an empty tree) is defined as:</p>
<pre><code class="language-C++">node.n_min = 0x0000000000000000
node.n_max = 0x0000000000000000
node.v = 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</code></pre>
<p>For leaf node <code>node</code> of <a href="specs/./shares.html">share</a> data <code>d</code>:</p>
<pre><code class="language-C++">node.n_min = d.namespace
node.n_max = d.namespace
node.v = h(0x00, d.namespace, d.rawData)
</code></pre>
<p>The <code>namespace</code> blob field here is the namespace of the leaf, which is a <a href="specs/consensus.html#system-parameters"><code>NAMESPACE_SIZE</code></a>-long byte array.</p>
<p>Leaves in an NMT <strong>must</strong> be lexicographically sorted by namespace in ascending order.</p>
<p>For internal node <code>node</code> with children <code>l</code> and <code>r</code>:</p>
<pre><code class="language-C++">node.n_min = min(l.n_min, r.n_min)
if l.n_min == PARITY_SHARE_NAMESPACE
  node.n_max = PARITY_SHARE_NAMESPACE
else if r.n_min == PARITY_SHARE_NAMESPACE
  node.n_max = l.n_max
else
  node.n_max = max(l.n_max, r.n_max)
node.v = h(0x01, l.n_min, l.n_max, l.v, r.n_min, r.n_max, r.v)
</code></pre>
<p>Note that the above snippet leverages the property that leaves are sorted by namespace: if <code>l.n_min</code> is <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>, so must <code>{l,r}.n_max</code>. By construction, either both the min and max namespace of a node will be <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>, or neither will: if <code>r.n_min</code> is <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>, so must <code>r.n_max</code>.</p>
<p>For some intuition: the min and max namespace for subtree roots with at least one non-parity leaf (which includes the root of an NMT, as <a href="specs/data_structures.html#2d-reed-solomon-encoding-scheme">the right half of an NMT as used in Celestia will be parity shares</a>) <em>ignore</em> the namespace ID for the parity leaves. Subtree roots with <em>only parity leaves</em> have their min and max namespace ID set to <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>. This allows for shorter proofs into the tree than if the namespace ID of parity shares was not ignored (which would cause the max namespace ID of the root to always be <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>).</p>
<p>A compact commitment can be computed by taking the <a href="specs/data_structures.html#hashing">hash</a> of the <a href="specs/data_structures.html#serialization">serialized</a> root node.</p>
<h4 id="namespacemerkletreeinclusionproof"><a class="header" href="#namespacemerkletreeinclusionproof">NamespaceMerkleTreeInclusionProof</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>siblingValues</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a><code>[]</code></td><td>Sibling hash values, ordered starting from the leaf's neighbor.</td></tr>
<tr><td><code>siblingMins</code></td><td><a href="specs/./namespace.html">Namespace</a><code>[]</code></td><td>Sibling min namespace IDs.</td></tr>
<tr><td><code>siblingMaxes</code></td><td><a href="specs/./namespace.html">Namespace</a><code>[]</code></td><td>Sibling max namespace IDs.</td></tr>
</tbody></table>
</div>
<p>When verifying an NMT proof, the root hash is checked by reconstructing the root node <code>root_node</code> with the computed <code>root_node.v</code> (computed as with a <a href="specs/data_structures.html#binarymerkletreeinclusionproof">plain Merkle proof</a>) and the provided <code>rootNamespaceMin</code> and <code>rootNamespaceMax</code> as the <code>root_node.n_min</code> and <code>root_node.n_max</code>, respectively.</p>
<h2 id="erasure-coding"><a class="header" href="#erasure-coding">Erasure Coding</a></h2>
<p>In order to enable trust-minimized light clients (i.e. light clients that do not rely on an honest majority of validating state assumption), it is critical that light clients can determine whether the data in each block is <em>available</em> or not, without downloading the whole block itself. The technique used here was formally described in the paper <a href="https://arxiv.org/abs/1809.09044">Fraud and Data Availability Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities</a>.</p>
<p>The remainder of the subsections below specify the <a href="specs/data_structures.html#2d-reed-solomon-encoding-scheme">2D Reed-Solomon erasure coding scheme</a> used, along with the format of <a href="specs/./shares.html">shares</a> and how <a href="specs/data_structures.html#available-data">available data</a> is arranged into shares.</p>
<h3 id="reed-solomon-erasure-coding"><a class="header" href="#reed-solomon-erasure-coding">Reed-Solomon Erasure Coding</a></h3>
<p>Note that while data is laid out in a two-dimensional square, rows and columns are erasure coded using a standard one-dimensional encoding.</p>
<p>Reed-Solomon erasure coding is used as the underlying coding scheme. The parameters are:</p>
<ul>
<li>16-bit Galois field</li>
<li><a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a> original pieces (maximum of <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>)</li>
<li><a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a> parity pieces (maximum of <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>) (i.e <code>availableDataOriginalSquareSize * 2</code> total pieces), for an erasure efficiency of 50%. In other words, any 50% of the pieces from the <code>availableDataOriginalSquareSize * 2</code> total pieces are enough to recover the original data.</li>
<li><a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a> bytes per piece</li>
</ul>
<p>Note that <a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a> may vary each block, and <a href="specs/./block_proposer.html#deciding-on-a-block-size">is decided by the block proposer of that block</a>. <a href="https://github.com/catid/leopard">Leopard-RS</a> is a C library that implements the above scheme with quasilinear runtime.</p>
<h3 id="2d-reed-solomon-encoding-scheme"><a class="header" href="#2d-reed-solomon-encoding-scheme">2D Reed-Solomon Encoding Scheme</a></h3>
<p>The 2-dimensional data layout is described in this section. The roots of <a href="specs/data_structures.html#namespace-merkle-tree">NMTs</a> for each row and column across four quadrants of data in a <code>2k * 2k</code> matrix of shares, <code>Q0</code> to <code>Q3</code> (shown below), must be computed. In other words, <code>2k</code> row roots and <code>2k</code> column roots must be computed. The row and column roots are stored in the <code>availableDataCommitments</code> of the <a href="specs/data_structures.html#availabledataheader">AvailableDataHeader</a>.</p>
<p><img src="specs/./figures/rs2d_quadrants.svg" alt="fig: RS2D encoding: data quadrants." /></p>
<p>The data of <code>Q0</code> is the original data, and the remaining quadrants are parity data. Setting <code>k = availableDataOriginalSquareSize</code>, the original data first must be split into <a href="specs/./shares.html">shares</a> and <a href="specs/data_structures.html#arranging-available-data-into-shares">arranged into a <code>k * k</code> matrix</a>. Then the parity data can be computed.</p>
<p>Where <code>A -&gt; B</code> indicates that <code>B</code> is computed using <a href="specs/data_structures.html#reed-solomon-erasure-coding">erasure coding</a> from <code>A</code>:</p>
<ul>
<li><code>Q0 -&gt; Q1</code> for each row in <code>Q0</code> and <code>Q1</code></li>
<li><code>Q0 -&gt; Q2</code> for each column in <code>Q0</code> and <code>Q2</code></li>
<li><code>Q2 -&gt; Q3</code> for each row in <code>Q2</code> and <code>Q3</code></li>
</ul>
<p>Note that the parity data in <code>Q3</code> will be identical if it is vertically extended from <code>Q1</code> or horizontally extended from <code>Q2</code>.</p>
<p><img src="specs/./figures/rs2d_extending.svg" alt="fig: RS2D encoding: extending data." /></p>
<p>As an example, the parity data in the second column of <code>Q2</code> (in striped purple) is computed by <a href="specs/data_structures.html#reed-solomon-erasure-coding">extending</a> the original data in the second column of <code>Q0</code> (in solid blue).</p>
<p><img src="specs/./figures/rs2d_extend.svg" alt="fig: RS2D encoding: extending a column." /></p>
<p>Now that all four quadrants of the <code>2k * 2k</code> matrix are filled, the row and column roots can be computed. To do so, each row/column is used as the leaves of a <a href="specs/data_structures.html#namespace-merkle-tree">NMT</a>, for which the compact root is computed (i.e. an extra hash operation over the NMT root is used to produce a single <a href="specs/data_structures.html#hashdigest">HashDigest</a>). In this example, the fourth row root value is computed as the NMT root of the fourth row of <code>Q0</code> and the fourth row of <code>Q1</code> as leaves.</p>
<p><img src="specs/./figures/rs2d_row.svg" alt="fig: RS2D encoding: a row root." /></p>
<p>Finally, the <code>availableDataRoot</code> of the block <a href="specs/data_structures.html#header">Header</a> is computed as the Merkle root of the <a href="specs/data_structures.html#binary-merkle-tree">binary Merkle tree</a> with the row and column roots as leaves, in that order.</p>
<p><img src="specs/./figures/data_root.svg" alt="fig: Available data root." /></p>
<h3 id="arranging-available-data-into-shares"><a class="header" href="#arranging-available-data-into-shares">Arranging Available Data Into Shares</a></h3>
<p>The previous sections described how some original data, arranged into a <code>k * k</code> matrix, can be extended into a <code>2k * 2k</code> matrix and committed to with NMT roots. This section specifies how <a href="specs/data_structures.html#available-data">available data</a> (which includes <a href="specs/data_structures.html#transaction">transactions</a>, PayForBlob transactions, and <a href="specs/data_structures.html#blobdata">blobs</a>) is arranged into the matrix in the first place.</p>
<p>Note that each <a href="specs/./shares.html">share</a> only has a single namespace, and that the list of concatenated shares is lexicographically ordered by namespace.</p>
<p>Then,</p>
<ol>
<li>For each of <code>transactionData</code>, <code>intermediateStateRootData</code>, PayForBlob transactions, <a href="specs/data_structures.html#serialization">serialize</a>:
<ol>
<li>For each request in the list:
<ol>
<li><a href="specs/data_structures.html#serialization">Serialize</a> the request (individually).</li>
<li>Compute the length of each serialized request, <a href="specs/data_structures.html#serialization">serialize the length</a>, and prepend the serialized request with its serialized length.</li>
</ol>
</li>
<li>Split up the length/request pairs into <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_ID_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a>-byte chunks.</li>
<li>Create a <a href="specs/./shares.html">share</a> out of each chunk. This data has a <em>reserved</em> namespace ID, so the first <a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>+</code><a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> bytes for these shares must be set specially.</li>
</ol>
</li>
<li>Concatenate the lists of shares in the order: transactions, intermediate state roots, PayForBlob transactions.</li>
</ol>
<p>These shares are arranged in the <a href="specs/data_structures.html#2d-reed-solomon-encoding-scheme">first quadrant</a> (<code>Q0</code>) of the <code>availableDataOriginalSquareSize*2 * availableDataOriginalSquareSize*2</code> available data matrix in <em>row-major</em> order. In the example below, each reserved data element takes up exactly one share.</p>
<p><img src="specs/./figures/rs2d_originaldata_reserved.svg" alt="fig: Original data: reserved." /></p>
<p>Each blob in the list <code>blobData</code>:</p>
<ol>
<li><a href="specs/data_structures.html#serialization">Serialize</a> the blob (individually).</li>
<li>Compute the length of each serialized blob, <a href="specs/data_structures.html#serialization">serialize the length</a>, and prepend the serialized blob with its serialized length.</li>
<li>Split up the length/blob pairs into <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a>-byte chunks.</li>
<li>Create a <a href="specs/./shares.html">share</a> out of each chunk. The first <a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a> bytes for these shares is set to the namespace.</li>
</ol>
<p>For each blob, it is placed in the available data matrix, with row-major order, as follows:</p>
<ol>
<li>Place the first share of the blob at the next unused location in the matrix, then place the remaining shares in the following locations.</li>
</ol>
<p>Transactions <a href="specs/data_structures.html#transaction">must commit to a Merkle root of a list of hashes</a> that are each guaranteed (assuming the block is valid) to be subtree roots in one or more of the row NMTs. For additional info, see <a href="specs/../specs/data_square_layout.html">the rationale document</a> for this section.</p>
<p>However, with only the rule above, interaction between the block producer and transaction sender may be required to compute a commitment to the blob the transaction sender can sign over. To remove interaction, blobs can optionally be laid out using a non-interactive default:</p>
<ol>
<li>Place the first share of the blob at the next unused location in the matrix whose column is aligned with the largest power of 2 that is not larger than the blob length or <a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a>, then place the remaining shares in the following locations <strong>unless</strong> there are insufficient unused locations in the row.</li>
<li>If there are insufficient unused locations in the row, place the first share of the blob at the first column of the next row. Then place the remaining shares in the following locations. By construction, any blob whose length is greater than <a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a> will be placed in this way.</li>
</ol>
<p>In the example below, two blobs (of lengths 2 and 1, respectively) are placed using the aforementioned default non-interactive rules.</p>
<p><img src="specs/./figures/rs2d_originaldata_blob.svg" alt="fig: original data blob" /></p>
<p>The blob share commitment rules may introduce empty shares that do not belong to any blob (in the example above, the top-right share is empty). These are zeroes with namespace ID equal to the either <a href="specs/./consensus.html#constants"><code>TAIL_TRANSACTION_PADDING_NAMESPACE_ID</code></a> if between a request with a reserved namespace ID and a blob, or the namespace ID of the previous blob if succeeded by a blob. See the <a href="specs/../specs/data_square_layout.html">rationale doc</a> for more info.</p>
<h2 id="available-data"><a class="header" href="#available-data">Available Data</a></h2>
<h3 id="transaction"><a class="header" href="#transaction">Transaction</a></h3>
<p>Celestia transactions are Cosmos SDK <a href="https://github.com/cosmos/cosmos-sdk/blob/v0.46.15/docs/core/transactions.md">transactions</a>.</p>
<h3 id="payforblobdata"><a class="header" href="#payforblobdata">PayForBlobData</a></h3>
<h3 id="indexwrapper"><a class="header" href="#indexwrapper">IndexWrapper</a></h3>
<p>IndexWrapper are wrappers around PayForBlob transactions. They include additional metadata by the block proposer that is committed to in the <a href="specs/data_structures.html#arranging-available-data-into-shares">available data matrix</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>tx</code></td><td><code>bytes</code></td><td>Actual transaction.</td></tr>
<tr><td><code>share_indexes</code></td><td><code>[]uint32</code></td><td>Share indexes (in row-major order) of the first share for each blob this transaction pays for. Needed for light verification of proper blob inclusion.</td></tr>
<tr><td><code>type_id</code></td><td><code>string</code></td><td>Type ID of the IndexWrapper transaction type. This is used for encoding and decoding IndexWrapper transactions. It is always set to <code>&quot;INDX&quot;</code>.</td></tr>
</tbody></table>
</div>
<h3 id="blobdata"><a class="header" href="#blobdata">BlobData</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>blobs</code></td><td><a href="specs/data_structures.html#blob">Blob</a><code>[]</code></td><td>List of blobs.</td></tr>
</tbody></table>
</div>
<h4 id="blob"><a class="header" href="#blob">Blob</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>namespaceID</code></td><td><a href="specs/data_structures.html#type-aliases">NamespaceID</a></td><td>Namespace ID of this blob.</td></tr>
<tr><td><code>rawData</code></td><td><code>byte[]</code></td><td>Raw blob bytes.</td></tr>
</tbody></table>
</div>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>The state of the Celestia chain is intentionally restricted to containing only account balances and the validator set metadata. Similar to other Cosmos SDK based chains, the state of the Celestia chain is maintained in a <a href="https://github.com/cosmos/cosmos-sdk/blob/v0.46.15/docs/core/store.md#multistore">multistore</a>. The root of the application state is committed to in the <a href="specs/data_structures.html#header">block header</a> via the <code>AppHash</code>.</p>
<h2 id="consensus-parameters"><a class="header" href="#consensus-parameters">Consensus Parameters</a></h2>
<p>Various <a href="specs/consensus.html#system-parameters">consensus parameters</a> are committed to in the block header, such as limits and constants.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>version</code></td><td><a href="specs/data_structures.html#consensusversion">ConsensusVersion</a></td><td>The consensus version struct.</td></tr>
<tr><td><code>chainID</code></td><td><code>string</code></td><td>The <code>CHAIN_ID</code>.</td></tr>
<tr><td><code>shareSize</code></td><td><code>uint64</code></td><td>The <code>SHARE_SIZE</code>.</td></tr>
<tr><td><code>shareReservedBytes</code></td><td><code>uint64</code></td><td>The <code>SHARE_RESERVED_BYTES</code>.</td></tr>
<tr><td><code>availableDataOriginalSquareMax</code></td><td><code>uint64</code></td><td>The <code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code>.</td></tr>
</tbody></table>
</div>
<p>In order to compute the <code>consensusHash</code> field in the <a href="specs/data_structures.html#header">block header</a>, the above list of parameters is <a href="specs/data_structures.html#hashing">hashed</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespace"><a class="header" href="#namespace">Namespace</a></h1>
<!-- toc -->
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>One of Celestia's core data structures is the namespace.
When a user submits a transaction encapsulating a <code>MsgPayForBlobs</code> message to Celestia, they MUST associate each blob with exactly one namespace.
After their transaction has been included in a block, the namespace enables users to take an interest in a subset of the blobs published to Celestia by allowing the user to query for blobs by namespace.</p>
<p>In order to enable efficient retrieval of blobs by namespace, Celestia makes use of a <a href="https://github.com/celestiaorg/nmt">Namespaced Merkle Tree</a>.
See section 5.2 of the <a href="https://arxiv.org/pdf/1905.09274.pdf">LazyLedger whitepaper</a> for more details.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>A namespace is composed of two fields: <a href="specs/namespace.html#version">version</a> and <a href="specs/namespace.html#id">id</a>.
A namespace is encoded as a byte slice with the version and id concatenated.</p>
<p><img src="specs/./figures/namespace.svg" alt="namespace" /></p>
<h3 id="version"><a class="header" href="#version">Version</a></h3>
<p>The namespace version is an 8-bit unsigned integer that indicates the version of the namespace.
The version is used to determine the format of the namespace and
is encoded as a single byte.
A new namespace version MUST be introduced if the namespace format changes in a backwards incompatible way.</p>
<p>Below we explain supported user-specifiable namespace versions,
however, we note that Celestia MAY utilize other namespace versions for internal use.
For more details, see the <a href="specs/namespace.html#reserved-namespaces">Reserved Namespaces</a> section.</p>
<h4 id="version-0"><a class="header" href="#version-0">Version 0</a></h4>
<p>The only supported user-specifiable namespace version is <code>0</code>.
A namespace with version <code>0</code> MUST contain an id with a prefix of 18 leading <code>0</code> bytes.
The remaining 10 bytes of the id are user-specified.
Below, we provide examples of valid and invalid encoded user-supplied namespaces with version <code>0</code>.</p>
<pre><code class="language-go">// Valid encoded namespaces
0x0000000000000000000000000000000000000001010101010101010101 // valid blob namespace
0x0000000000000000000000000000000000000011111111111111111111 // valid blob namespace

// Invalid encoded namespaces
0x0000000000000000000000000111111111111111111111111111111111 // invalid because it does not have 18 leading 0 bytes
0x1000000000000000000000000000000000000000000000000000000000 // invalid because it does not have version 0
0x1111111111111111111111111111111111111111111111111111111111 // invalid because it does not have version 0
</code></pre>
<p>Any change in the number of leading <code>0</code> bytes in the id of a namespace with version <code>0</code> is considered a backwards incompatible change and MUST be introduced as a new namespace version.</p>
<h3 id="id"><a class="header" href="#id">ID</a></h3>
<p>The namespace ID is a 28 byte identifier that uniquely identifies a namespace.
The ID is encoded as a byte slice of length 28.</p>
<!-- It may be useful to indicate the endianness of the encoding) -->
<h2 id="reserved-namespaces"><a class="header" href="#reserved-namespaces">Reserved Namespaces</a></h2>
<p>Celestia reserves some namespaces for protocol use.
These namespaces are called &quot;reserved namespaces&quot;.
Reserved namespaces are used to arrange the contents of the <a href="specs/./data_square_layout.html">data square</a>.
Applications MUST NOT use reserved namespaces for their blob data.
Reserved namespaces fall into two categories: <em>Primary</em> and <em>Secondary</em>.</p>
<ul>
<li>Primary: Namespaces with values less than or equal to <code>0x00000000000000000000000000000000000000000000000000000000FF</code>. Primary namespaces always have a version of <code>0</code>.</li>
<li>Secondary: Namespaces with values greater than or equal to <code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00</code>.
Secondary namespaces always have a version of <code>255</code> (<code>0xFF</code>) so that they are placed after all user specifiable namespaces in a sorted data square.
The <code>PARITY_SHARE_NAMESPACE</code> uses version <code>255</code> (<code>0xFF</code>) to enable more efficient proof generation within the context of <a href="https://github.com/celestiaorg/nmt">nmt</a>, where it is used in conjunction with the <code>IgnoreMaxNamespace</code> feature.
The <code>TAIL_PADDING_NAMESPACE</code> uses the version <code>255</code> to ensure that padding shares are always placed at the end of the Celestia data square even if a new user-specifiable version is introduced.</li>
</ul>
<p>Below is a list of the current reserved namespaces.
For additional information on the significance and application of the reserved namespaces, please refer to the <a href="specs/./data_square_layout.html">Data Square Layout</a> specifications.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>category</th><th>value</th><th>description</th></tr></thead><tbody>
<tr><td><code>TRANSACTION_NAMESPACE</code></td><td><code>Namespace</code></td><td>Primary</td><td><code>0x0000000000000000000000000000000000000000000000000000000001</code></td><td>Namespace for ordinary Cosmos SDK transactions.</td></tr>
<tr><td><code>INTERMEDIATE_STATE_ROOT_NAMESPACE</code></td><td><code>Namespace</code></td><td>Primary</td><td><code>0x0000000000000000000000000000000000000000000000000000000002</code></td><td>Namespace for intermediate state roots (not currently utilized).</td></tr>
<tr><td><code>PAY_FOR_BLOB_NAMESPACE</code></td><td><code>Namespace</code></td><td>Primary</td><td><code>0x0000000000000000000000000000000000000000000000000000000004</code></td><td>Namespace for transactions that contain a PayForBlob.</td></tr>
<tr><td><code>PRIMARY_RESERVED_PADDING_NAMESPACE</code></td><td><code>Namespace</code></td><td>Primary</td><td><code>0x00000000000000000000000000000000000000000000000000000000FF</code></td><td>Namespace for padding after all primary reserved namespaces.</td></tr>
<tr><td><code>MAX_PRIMARY_RESERVED_NAMESPACE</code></td><td><code>Namespace</code></td><td>Primary</td><td><code>0x00000000000000000000000000000000000000000000000000000000FF</code></td><td>Namespace for the highest primary reserved namespace.</td></tr>
<tr><td><code>MIN_SECONDARY_RESERVED_NAMESPACE</code></td><td><code>Namespace</code></td><td>Secondary</td><td><code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00</code></td><td>Namespace for the lowest secondary reserved namespace.</td></tr>
<tr><td><code>TAIL_PADDING_NAMESPACE</code></td><td><code>Namespace</code></td><td>Secondary</td><td><code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE</code></td><td>Namespace for padding after all blobs to fill up the original data square.</td></tr>
<tr><td><code>PARITY_SHARE_NAMESPACE</code></td><td><code>Namespace</code></td><td>Secondary</td><td><code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></td><td>Namespace for parity shares.</td></tr>
</tbody></table>
</div>
<h2 id="assumptions-and-considerations"><a class="header" href="#assumptions-and-considerations">Assumptions and Considerations</a></h2>
<p>Applications MUST refrain from using the <a href="specs/namespace.html#reserved-namespaces">reserved namespaces</a> for their blob data.</p>
<p>Celestia does not ensure the prevention of non-reserved namespace collisions.
Consequently, two distinct applications might use the same namespace.
It is the responsibility of these applications to be cautious and manage the implications and consequences arising from such namespace collisions.
Among the potential consequences is the <em>Woods Attack</em>, as elaborated in this forum post: <a href="https://forum.celestia.org/t/woods-attack-on-celestia/59">Woods Attack on Celestia</a>.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>See <a href="https://github.com/celestiaorg/go-square/blob/main/share/namespace.go">go-square/namespace</a>.</p>
<h2 id="go-definition"><a class="header" href="#go-definition">Go Definition</a></h2>
<pre><code class="language-go">type Namespace struct {
	Version uint8
	ID      []byte
}
</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li><a href="specs/../../../docs/architecture/adr-014-versioned-namespaces.html">ADR-014</a></li>
<li><a href="specs/../../../docs/architecture/adr-015-namespace-id-size.html">ADR-015</a></li>
<li><a href="https://github.com/celestiaorg/nmt">Namespaced Merkle Tree</a></li>
<li><a href="https://arxiv.org/pdf/1905.09274.pdf">LazyLedger whitepaper</a></li>
<li><a href="specs/./data_square_layout.html">Data Square Layout</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shares"><a class="header" href="#shares">Shares</a></h1>
<!-- toc -->
<h2 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h2>
<p>All available data in a Celestia <a href="specs/./data_structures.html#block">block</a> is split into fixed-size data chunks known as &quot;shares&quot;. Shares are the atomic unit of the Celestia data square. The shares in a Celestia block are eventually <a href="specs/./data_structures.html#erasure-coding">erasure-coded</a> and committed to in <a href="specs/./data_structures.html#namespace-merkle-tree">Namespace Merkle trees</a> (also see <a href="https://github.com/celestiaorg/nmt/blob/master/docs/spec/nmt.md">NMT spec</a>).</p>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<ul>
<li><strong>Blob</strong>: User specified data (e.g. a roll-up block) that is associated with exactly one namespace. Blob data are opaque bytes of data that are included in the block but do not impact Celestia's state.</li>
<li><strong>Share</strong>: A fixed-size data chunk that is associated with exactly one namespace.</li>
<li><strong>Share sequence</strong>: A share sequence is a contiguous set of shares that contain semantically relevant data. A share sequence MUST contain one or more shares. When a <a href="specs/../../../x/blob/README.html">blob</a> is split into shares, it is written to one share sequence. As a result, all shares in a share sequence are typically parsed together because the original blob data may have been split across share boundaries. All transactions in the <a href="specs/./namespace.html#reserved-namespaces"><code>TRANSACTION_NAMESPACE</code></a> are contained in one share sequence. All transactions in the <a href="specs/./namespace.html#reserved-namespaces"><code>PAY_FOR_BLOB_NAMESPACE</code></a> are contained in one share sequence.</li>
</ul>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>User submitted transactions are split into shares (see <a href="specs/shares.html#share-splitting">share splitting</a>) and arranged in a <code>k * k</code> matrix (see <a href="specs/./data_structures.html#arranging-available-data-into-shares">arranging available data into shares</a>) prior to the erasure coding step. Shares in the <code>k * k</code> matrix are ordered by namespace and have a common <a href="specs/shares.html#share-format">share format</a>.</p>
<p><a href="specs/shares.html#padding">Padding</a> shares are added to the <code>k * k</code> matrix to ensure:</p>
<ol>
<li>Blob sequences start on an index that conforms to <a href="specs/./data_square_layout.html#blob-share-commitment-rules">blob share commitment rules</a> (see <a href="specs/shares.html#namespace-padding-share">namespace padding share</a> and <a href="specs/shares.html#primary-reserved-padding-share">reserved padding share</a>)</li>
<li>The number of shares in the matrix is a perfect square (see <a href="specs/shares.html#tail-padding-share">tail padding share</a>)</li>
</ol>
<h2 id="share-format"><a class="header" href="#share-format">Share Format</a></h2>
<p>Every share has a fixed size <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a>. The share format below is consistent for all shares:</p>
<ul>
<li>The first <a href="specs/./consensus.html#constants"><code>NAMESPACE_VERSION_SIZE</code></a> bytes of a share's raw data is the namespace version of that share (denoted by &quot;namespace version&quot; in the figure below).</li>
<li>The next <a href="specs/./consensus.html#constants"><code>NAMESPACE_ID_SIZE</code></a> bytes of a share's raw data is the namespace ID of that share (denoted by &quot;namespace id&quot; in the figure below).</li>
<li>The next <a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a> bytes are for share information (denoted by &quot;info byte&quot; in the figure below) with the following structure:
<ul>
<li>The first 7 bits represent the <a href="specs/shares.html#share-version">share version</a> in big endian form (initially, this will be <code>0000000</code> for version <code>0</code>);</li>
<li>The last bit is a sequence start indicator. The indicator is <code>1</code> if this share is the first share in a sequence or <code>0</code> if this share is a continuation share in a sequence.</li>
</ul>
</li>
<li>If this share is the first share in a sequence, it will include the length of the sequence in bytes. The next <a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> represent a big-endian uint32 value (denoted by &quot;sequence length&quot; in the figure below). This length is placed immediately after the <code>SHARE_INFO_BYTES</code> field. It's important to note that shares that are not the first share in a sequence do not contain this field.</li>
<li>The remaining <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> bytes (if first share) or <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a> bytes (if continuation share) are raw data (denoted by &quot;blob1&quot; in the figure below). Typically raw data is the blob payload that user's submit in a <a href="specs/../../../x/blob/README.html">BlobTx</a>. However, raw data can also be transaction data (see <a href="specs/shares.html#transaction-shares">transaction shares</a> below).</li>
<li>If there is insufficient raw data to fill the share, the remaining bytes are filled with <code>0</code>.</li>
</ul>
<p>First share in a sequence:</p>
<p><img src="specs/./figures/share_start.svg" alt="figure 1: share start" /></p>
<p>Continuation share in a sequence:</p>
<p><img src="specs/./figures/share_continuation.svg" alt="figure 2: share continuation" /></p>
<p>Since raw data that exceeds <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a> <code>-</code> <a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> bytes will span more than one share, developers MAY choose to encode additional metadata in their raw blob data prior to inclusion in a Celestia block. For example, Celestia transaction shares encode additional metadata in the form of &quot;reserved bytes&quot;.</p>
<h3 id="share-version"><a class="header" href="#share-version">Share Version</a></h3>
<p>The share version is a 7-bit big-endian unsigned integer that is used to indicate the version of the <a href="specs/shares.html#share-format">share format</a>. The only supported share version is <code>0</code>. A new share version MUST be introduced if the share format changes in a way that is not backwards compatible.</p>
<h2 id="transaction-shares"><a class="header" href="#transaction-shares">Transaction Shares</a></h2>
<p>In order for clients to parse shares in the middle of a sequence without downloading antecedent shares, Celestia encodes additional metadata in the shares associated with reserved namespaces. At the time of writing this only applies to the <a href="specs/./namespace.html#reserved-namespaces"><code>TRANSACTION_NAMESPACE</code></a> and <a href="specs/./namespace.html#reserved-namespaces"><code>PAY_FOR_BLOB_NAMESPACE</code></a>. This share structure is often referred to as &quot;compact shares&quot; to differentiate from the share structure defined above for all shares. It conforms to the common <a href="specs/shares.html#share-format">share format</a> with one additional field, the &quot;reserved bytes&quot; field, which is described below:</p>
<ul>
<li>Every transaction share includes <a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> bytes that contain the index of the starting byte of the length of the <a href="specs/./consensus.html#serialization">canonically serialized</a> first transaction that starts in the share, or <code>0</code> if there is none, as a binary big endian <code>uint32</code>. Denoted by &quot;reserved bytes&quot; in the figure below. The <a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> are placed immediately after the <code>SEQUENCE_BYTES</code> if this is the first share in a sequence or immediately after the <code>SHARE_INFO_BYTES</code> if this is a continuation share in a sequence.</li>
<li>The remaining <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> bytes (if first share) or <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> bytes (if continuation share) are transaction or PayForBlob transaction data (denoted by &quot;tx1&quot; and &quot;tx2&quot; in the figure below). Each transaction or PayForBlob transaction is prefixed with a <a href="https://developers.google.com/protocol-buffers/docs/encoding">varint</a> of the length of that unit (denoted by &quot;len(tx1)&quot; and &quot;len(tx2)&quot; in the figure below).</li>
<li>If there is insufficient transaction or PayForBlob transaction data to fill the share, the remaining bytes are filled with <code>0</code>.</li>
</ul>
<p>First share in a sequence:</p>
<p><img src="specs/./figures/transaction_share_start.svg" alt="figure 3: transaction share start" /></p>
<p>where reserved bytes would be <code>38</code> as a binary big endian <code>uint32</code> (<code>[0b00000000, 0b00000000, 0b00000000, 0b00100110]</code>).</p>
<p>Continuation share in a sequence:</p>
<p><img src="specs/./figures/transaction_share_continuation.svg" alt="figure 4: transaction share continuation" /></p>
<p>where reserved bytes would be <code>80</code> as a binary big endian <code>uint32</code> (<code>[0b00000000, 0b00000000, 0b00000000, 0b01010000]</code>).</p>
<h2 id="padding"><a class="header" href="#padding">Padding</a></h2>
<p>Padding shares vary based on namespace but they conform to the <a href="specs/shares.html#share-format">share format</a> described above.</p>
<ul>
<li>The first <a href="specs/./consensus.html#constants"><code>NAMESPACE_VERSION_SIZE</code></a> bytes of a share's raw data is the namespace version of that share (initially, this will be <code>0</code>).</li>
<li>The next <a href="specs/./consensus.html#constants"><code>NAMESPACE_ID_SIZE</code></a> bytes of a share's raw data is the namespace ID of that share. This varies based on the type of padding share.</li>
<li>The next <a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a> bytes are for share information.
<ul>
<li>The first 7 bits represent the <a href="specs/shares.html#share-version">share version</a> in big endian form (initially, this will be <code>0000000</code> for version <code>0</code>);</li>
<li>The last bit is a sequence start indicator. The indicator is always <code>1</code>.</li>
</ul>
</li>
<li>The next <a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> contain a big endian <code>uint32</code> of value <code>0</code>.</li>
<li>The remaining <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> bytes are filled with <code>0</code>.</li>
</ul>
<h3 id="namespace-padding-share"><a class="header" href="#namespace-padding-share">Namespace Padding Share</a></h3>
<p>A namespace padding share uses the namespace of the blob that precedes it in the data square so that the data square can retain the property that all shares are ordered by namespace.
A namespace padding share acts as padding between blobs so that the subsequent blob begins at an index that conforms to the <a href="specs/./data_square_layout.html#blob-share-commitment-rules">blob share commitment rules</a>. Clients MAY ignore the contents of these shares because they don't contain any significant data.</p>
<h3 id="primary-reserved-padding-share"><a class="header" href="#primary-reserved-padding-share">Primary Reserved Padding Share</a></h3>
<p>Primary reserved padding shares use the <a href="specs/./namespace.html#reserved-namespaces"><code>PRIMARY_RESERVED_PADDING_NAMESPACE</code></a>. Primary reserved padding shares are placed after shares in the primary reserved namespace range so that the first blob can start at an index that conforms to blob share commitment rules. Clients MAY ignore the contents of these shares because they don't contain any significant data.</p>
<h3 id="tail-padding-share"><a class="header" href="#tail-padding-share">Tail Padding Share</a></h3>
<p>Tail padding shares use the <a href="specs/./namespace.html#reserved-namespaces"><code>TAIL_PADDING_NAMESPACE</code></a>. Tail padding shares are placed after the last blob in the data square so that the number of shares in the data square is a perfect square. Clients MAY ignore the contents of these shares because they don't contain any significant data.</p>
<h2 id="parity-share"><a class="header" href="#parity-share">Parity Share</a></h2>
<p>Parity shares use the <a href="specs/./namespace.html#reserved-namespaces"><code>PARITY_SHARE_NAMESPACE</code></a>. Parity shares are the output of the erasure coding step of the data square construction process. They occupy quadrants Q1, Q2, and Q3 of the extended data square and are used to reconstruct the original data square (Q0). Bytes carry no special meaning.</p>
<h2 id="share-splitting"><a class="header" href="#share-splitting">Share Splitting</a></h2>
<p>Share splitting is the process of converting a blob into a share sequence. The process is as follows:</p>
<ol>
<li>Create a new share and populate the prefix of the share with the blob's namespace and <a href="specs/shares.html#share-version">share version</a>. Set the sequence start indicator to <code>1</code>. Write the blob length as the sequence length. Write the blob's data into the share until the share is full.</li>
<li>If there is more data to write, create a new share (a.k.a continuation share) and populate the prefix of the share with the blob's namespace and <a href="specs/shares.html#share-version">share version</a>. Set the sequence start indicator to <code>0</code>. Write the remaining blob data into the share until the share is full.</li>
<li>Repeat the previous step until all blob data has been written.</li>
<li>If the last share is not full, fill the remainder of the share with <code>0</code>.</li>
</ol>
<h2 id="assumptions-and-considerations-1"><a class="header" href="#assumptions-and-considerations-1">Assumptions and Considerations</a></h2>
<ul>
<li>Shares are assumed to be byte slices of length 512. Parsing shares of a different length WILL result in an error.</li>
</ul>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>See <a href="https://github.com/celestiaorg/go-square/tree/main/shares">go-square/shares</a>.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ol>
<li><a href="specs/../../../docs/architecture/adr-012-sequence-length-encoding.html">ADR-012</a></li>
<li><a href="specs/../../../docs/architecture/adr-014-versioned-namespaces.html">ADR-014</a></li>
<li><a href="specs/../../../docs/architecture/adr-015-namespace-id-size.html">ADR-015</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consensus-rules"><a class="header" href="#consensus-rules">Consensus Rules</a></h1>
<!-- toc -->
<h2 id="system-parameters"><a class="header" href="#system-parameters">System Parameters</a></h2>
<h3 id="units"><a class="header" href="#units">Units</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>SI</th><th>value</th><th>description</th></tr></thead><tbody>
<tr><td><code>1u</code></td><td><code>1u</code></td><td><code>10**0</code></td><td><code>1</code> unit.</td></tr>
<tr><td><code>2u</code></td><td><code>k1u</code></td><td><code>10**3</code></td><td><code>1000</code> units.</td></tr>
<tr><td><code>3u</code></td><td><code>M1u</code></td><td><code>10**6</code></td><td><code>1000000</code> units.</td></tr>
<tr><td><code>4u</code></td><td><code>G1u</code></td><td><code>10**9</code></td><td><code>1000000000</code> units.</td></tr>
</tbody></table>
</div>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>value</th><th>unit</th><th>description</th></tr></thead><tbody>
<tr><td><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></td><td><code>uint64</code></td><td></td><td><code>share</code></td><td>Maximum number of rows/columns of the original data <a href="specs/data_structures.html#share">shares</a> in <a href="specs/data_structures.html#arranging-available-data-into-shares">square layout</a>.</td></tr>
<tr><td><code>AVAILABLE_DATA_ORIGINAL_SQUARE_TARGET</code></td><td><code>uint64</code></td><td></td><td><code>share</code></td><td>Target number of rows/columns of the original data <a href="specs/data_structures.html#share">shares</a> in <a href="specs/data_structures.html#arranging-available-data-into-shares">square layout</a>.</td></tr>
<tr><td><code>BLOCK_TIME</code></td><td><code>uint64</code></td><td></td><td>second</td><td>Block time, in seconds.</td></tr>
<tr><td><code>CHAIN_ID</code></td><td><code>string</code></td><td><code>&quot;Celestia&quot;</code></td><td></td><td>Chain ID. Each chain assigns itself a (unique) ID.</td></tr>
<tr><td><code>GENESIS_COIN_COUNT</code></td><td><code>uint64</code></td><td><code>10**8</code></td><td><code>4u</code></td><td><code>(= 100000000)</code> Number of coins at genesis.</td></tr>
<tr><td><code>MAX_GRAFFITI_BYTES</code></td><td><code>uint64</code></td><td><code>32</code></td><td><code>byte</code></td><td>Maximum size of transaction graffiti, in bytes.</td></tr>
<tr><td><code>MAX_VALIDATORS</code></td><td><code>uint16</code></td><td><code>64</code></td><td></td><td>Maximum number of active validators.</td></tr>
<tr><td><code>NAMESPACE_VERSION_SIZE</code></td><td><code>int</code></td><td><code>1</code></td><td><code>byte</code></td><td>Size of namespace version in bytes.</td></tr>
<tr><td><code>NAMESPACE_ID_SIZE</code></td><td><code>int</code></td><td><code>28</code></td><td><code>byte</code></td><td>Size of namespace ID in bytes.</td></tr>
<tr><td><code>NAMESPACE_SIZE</code></td><td><code>int</code></td><td><code>29</code></td><td><code>byte</code></td><td>Size of namespace in bytes.</td></tr>
<tr><td><code>NAMESPACE_ID_MAX_RESERVED</code></td><td><code>uint64</code></td><td><code>255</code></td><td></td><td>Value of maximum reserved namespace (inclusive). 1 byte worth of IDs.</td></tr>
<tr><td><code>SEQUENCE_BYTES</code></td><td><code>uint64</code></td><td><code>4</code></td><td><code>byte</code></td><td>The number of bytes used to store the sequence length in the first share of a sequence</td></tr>
<tr><td><code>SHARE_INFO_BYTES</code></td><td><code>uint64</code></td><td><code>1</code></td><td><code>byte</code></td><td>The number of bytes used for <a href="specs/data_structures.html#share">share</a> information</td></tr>
<tr><td><code>SHARE_RESERVED_BYTES</code></td><td><code>uint64</code></td><td><code>4</code></td><td><code>byte</code></td><td>The number of bytes used to store the index of the first transaction in a transaction share. Must be able to represent any integer up to and including <code>SHARE_SIZE - 1</code>.</td></tr>
<tr><td><code>SHARE_SIZE</code></td><td><code>uint64</code></td><td><code>512</code></td><td><code>byte</code></td><td>Size of transaction and blob <a href="specs/data_structures.html#share">shares</a>, in bytes.</td></tr>
<tr><td><code>STATE_SUBTREE_RESERVED_BYTES</code></td><td><code>uint64</code></td><td><code>1</code></td><td><code>byte</code></td><td>Number of bytes reserved to identify state subtrees.</td></tr>
<tr><td><code>UNBONDING_DURATION</code></td><td><code>uint32</code></td><td></td><td><code>block</code></td><td>Duration, in blocks, for unbonding a validator or delegation.</td></tr>
<tr><td><code>VERSION_APP</code></td><td><code>uint64</code></td><td><code>1</code></td><td></td><td>Version of the Celestia application. Breaking changes (hard forks) must update this parameter.</td></tr>
<tr><td><code>VERSION_BLOCK</code></td><td><code>uint64</code></td><td><code>1</code></td><td></td><td>Version of the Celestia chain. Breaking changes (hard forks) must update this parameter.</td></tr>
</tbody></table>
</div>
<h3 id="rewards-and-penalties"><a class="header" href="#rewards-and-penalties">Rewards and Penalties</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>value</th><th>unit</th><th>description</th></tr></thead><tbody>
<tr><td><code>SECONDS_PER_YEAR</code></td><td><code>uint64</code></td><td><code>31536000</code></td><td>second</td><td>Seconds per year. Omit leap seconds.</td></tr>
<tr><td><code>TARGET_ANNUAL_ISSUANCE</code></td><td><code>uint64</code></td><td><code>2 * 10**6</code></td><td><code>4u</code></td><td><code>(= 2000000)</code> Target number of coins to issue per year.</td></tr>
</tbody></table>
</div>
<h2 id="leader-selection"><a class="header" href="#leader-selection">Leader Selection</a></h2>
<p>Refer to the CometBFT specifications for <a href="https://docs.cometbft.com/v0.34/spec/consensus/proposer-selection">proposer selection procedure</a>.</p>
<h2 id="fork-choice"><a class="header" href="#fork-choice">Fork Choice</a></h2>
<p>The Tendermint consensus protocol is fork-free by construction under an honest majority of stake assumption.</p>
<p>If a block has a <a href="specs/consensus.html#blocklastcommit">valid commit</a>, it is part of the canonical chain. If equivocation evidence is detected for more than 1/3 of voting power, the node must halt. See <a href="https://docs.cometbft.com/v0.34/spec/consensus/consensus#proof-of-fork-accountability">proof of fork accountability</a>.</p>
<h2 id="block-validity"><a class="header" href="#block-validity">Block Validity</a></h2>
<p>The validity of a newly-seen block, <code>block</code>, is determined by two components, detailed in subsequent sections:</p>
<ol>
<li><a href="specs/consensus.html#block-structure">Block structure</a>: whether the block header is valid, and data in a block is arranged into a valid and matching data root (i.e. syntax).</li>
<li><a href="specs/consensus.html#state-transitions">State transition</a>: whether the application of transactions in the block produces a matching and valid state root (i.e. semantics).</li>
</ol>
<p>Pseudocode in this section is not in any specific language and should be interpreted as being in a neutral and sane language.</p>
<h2 id="block-structure"><a class="header" href="#block-structure">Block Structure</a></h2>
<p>Before executing <a href="specs/consensus.html#state-transitions">state transitions</a>, the structure of the <a href="specs/./data_structures.html#block">block</a> must be verified.</p>
<p>The following block fields are acquired from the network and parsed (i.e. <a href="specs/./data_structures.html#serialization">deserialized</a>). If they cannot be parsed, the block is ignored but is not explicitly considered invalid by consensus rules. Further implications of ignoring a block are found in the <a href="specs/./networking.html">networking spec</a>.</p>
<ol>
<li><a href="specs/./data_structures.html#header">block.header</a></li>
<li><a href="specs/./data_structures.html#availabledataheader">block.availableDataHeader</a></li>
<li><a href="specs/./data_structures.html#commit">block.lastCommit</a></li>
</ol>
<p>If the above fields are parsed successfully, the available data <code>block.availableData</code> is acquired in erasure-coded form as <a href="specs/./networking.html#availabledata">a list of share rows</a>, then parsed. If it cannot be parsed, the block is ignored but not explicitly invalid, as above.</p>
<h3 id="blockheader"><a class="header" href="#blockheader"><code>block.header</code></a></h3>
<p>The <a href="specs/./data_structures.html#header">block header</a> <code>block.header</code> (<code>header</code> for short) is the first thing that is downloaded from the new block, and commits to everything inside the block in some way. For previous block <code>prev</code> (if <code>prev</code> is not known, then the block is ignored), and previous block header <code>prev.header</code>, the following checks must be <code>true</code>:</p>
<p><code>availableDataOriginalSquareSize</code> is computed as described <a href="specs/./data_structures.html#header">here</a>.</p>
<ol>
<li><code>header.height</code> == <code>prev.header.height + 1</code>.</li>
<li><code>header.timestamp</code> &gt; <code>prev.header.timestamp</code>.</li>
<li><code>header.lastHeaderHash</code> == the <a href="specs/./data_structures.html#header">header hash</a> of <code>prev</code>.</li>
<li><code>header.lastCommitHash</code> == the <a href="specs/./data_structures.html#hashing">hash</a> of <code>lastCommit</code>.</li>
<li><code>header.consensusHash</code> == the value computed <a href="specs/./data_structures.html#consensus-parameters">here</a>.</li>
<li><code>header.stateCommitment</code> == the root of the state, computed <a href="specs/consensus.html#state-transitions">with the application of all state transitions in this block</a>.</li>
<li><code>availableDataOriginalSquareSize</code> &lt;= <a href="specs/consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>.</li>
<li><code>header.availableDataRoot</code> == the <a href="specs/./data_structures.html#binary-merkle-tree">Merkle root</a> of the tree with the row and column roots of <code>block.availableDataHeader</code> as leaves.</li>
<li><code>header.proposerAddress</code> == the <a href="specs/consensus.html#leader-selection">leader</a> for <code>header.height</code>.</li>
</ol>
<h3 id="blockavailabledataheader"><a class="header" href="#blockavailabledataheader"><code>block.availableDataHeader</code></a></h3>
<p>The <a href="specs/./data_structures.html#availabledataheader">available data header</a> <code>block.availableDataHeader</code> (<code>availableDataHeader</code> for short) is then processed. This commits to the available data, which is only downloaded after the <a href="specs/consensus.html#blocklastcommit">consensus commit</a> is processed. The following checks must be <code>true</code>:</p>
<ol>
<li>Length of <code>availableDataHeader.rowRoots</code> == <code>availableDataOriginalSquareSize * 2</code>.</li>
<li>Length of <code>availableDataHeader.colRoots</code> == <code>availableDataOriginalSquareSize * 2</code>.</li>
<li>The length of each element in <code>availableDataHeader.rowRoots</code> and <code>availableDataHeader.colRoots</code> must be <a href="specs/./data_structures.html#hashing"><code>32</code></a>.</li>
</ol>
<h3 id="blocklastcommit"><a class="header" href="#blocklastcommit"><code>block.lastCommit</code></a></h3>
<p>The last <a href="specs/./data_structures.html#commit">commit</a> <code>block.lastCommit</code> (<code>lastCommit</code> for short) is processed next. This is the Tendermint commit (i.e. polka of votes) <em>for the previous block</em>. For previous block <code>prev</code> and previous block header <code>prev.header</code>, the following checks must be <code>true</code>:</p>
<ol>
<li><code>lastCommit.height</code> == <code>prev.header.height</code>.</li>
<li><code>lastCommit.round</code> &gt;= <code>1</code>.</li>
<li><code>lastCommit.headerHash</code> == the <a href="specs/./data_structures.html#header">header hash</a> of <code>prev</code>.</li>
<li>Length of <code>lastCommit.signatures</code> &lt;= <a href="specs/consensus.html#constants"><code>MAX_VALIDATORS</code></a>.</li>
<li>Each of <code>lastCommit.signatures</code> must be a valid <a href="specs/./data_structures.html#commitsig">CommitSig</a></li>
<li>The sum of the votes for <code>prev</code> in <code>lastCommit</code> must be at least 2/3 (rounded up) of the voting power of <code>prev</code>'s next validator set.</li>
</ol>
<h3 id="blockavailabledata"><a class="header" href="#blockavailabledata"><code>block.availableData</code></a></h3>
<p>The block's <a href="specs/./data_structures.html#availabledata">available data</a> (analogous to transactions in contemporary blockchain designs) <code>block.availableData</code> (<code>availableData</code> for short) is finally processed. The <a href="specs/./networking.html#availabledata">list of share rows</a> is parsed into the <a href="specs/./data_structures.html#availabledata">actual data structures</a> using the reverse of <a href="specs/./data_structures.html#arranging-available-data-into-shares">the process to encode available data into shares</a>; if parsing fails here, the block is invalid.</p>
<p>Once parsed, the following checks must be <code>true</code>:</p>
<ol>
<li>The commitments of the <a href="specs/./data_structures.html#2d-reed-solomon-encoding-scheme">erasure-coded extended</a> <code>availableData</code> must match those in <code>header.availableDataHeader</code>. Implicitly, this means that both rows and columns must be ordered lexicographically by namespace since they are committed to in a <a href="specs/data_structures.html#namespace-merkle-tree">Namespace Merkle Tree</a>.</li>
<li>Length of <code>availableData.intermediateStateRootData</code> == length of <code>availableData.transactionData</code> + length of <code>availableData.payForBlobData</code> + 2. (Two additional state transitions are the <a href="specs/consensus.html#begin-block">begin</a> and <a href="specs/consensus.html#end-block">end block</a> implicit transitions.)</li>
</ol>
<h2 id="state-transitions"><a class="header" href="#state-transitions">State Transitions</a></h2>
<p>Once the basic structure of the block <a href="specs/consensus.html#block-structure">has been validated</a>, state transitions must be applied to compute the new state and state root.</p>
<p>For this section, the variable <code>state</code> represents the <a href="specs/./data_structures.html#state">state tree</a>, with <code>state.accounts[k]</code>, <code>state.inactiveValidatorSet[k]</code>, <code>state.activeValidatorSet[k]</code>, and <code>state.delegationSet[k]</code> being shorthand for the leaf in the state tree in the <a href="specs/./data_structures.html#state">accounts, inactive validator set, active validator set, and delegation set subtrees</a> with <a href="specs/./data_structures.html#state">pre-hashed key</a> <code>k</code>. E.g. <code>state.accounts[a]</code> is shorthand for <code>state[(ACCOUNTS_SUBTREE_ID &lt;&lt; 8*(32-STATE_SUBTREE_RESERVED_BYTES)) | ((-1 &gt;&gt; 8*STATE_SUBTREE_RESERVED_BYTES) &amp; hash(a))]</code>.</p>
<p>State transitions are applied in the following order:</p>
<ol>
<li><a href="specs/consensus.html#begin-block">Begin block</a>.</li>
<li><a href="specs/consensus.html#blockavailabledatatransactiondata">Transactions</a>.</li>
<li><a href="specs/consensus.html#end-block">End block</a>.</li>
</ol>
<h3 id="blockavailabledatatransactiondata"><a class="header" href="#blockavailabledatatransactiondata"><code>block.availableData.transactionData</code></a></h3>
<p>Transactions are applied to the state. Note that <em>transactions</em> mutate the state (essentially, the validator set and minimal balances), while <em>blobs</em> do not.</p>
<p><code>block.availableData.transactionData</code> is simply a list of <a href="specs/./data_structures.html#wrappedtransaction">WrappedTransaction</a>s. For each wrapped transaction in this list, <code>wrappedTransaction</code>, with index <code>i</code> (starting from <code>0</code>), the following checks must be <code>true</code>:</p>
<ol>
<li><code>wrappedTransaction.index</code> == <code>i</code>.</li>
</ol>
<p>For <code>wrappedTransaction</code>'s <a href="specs/./data_structures.html#transaction">transaction</a> <code>transaction</code>, the following checks must be <code>true</code>:</p>
<ol>
<li><code>transaction.signature</code> must be a <a href="specs/./data_structures.html#public-key-cryptography">valid signature</a> over <code>transaction.signedTransactionData</code>.</li>
</ol>
<p>Finally, each <code>wrappedTransaction</code> is processed depending on <a href="specs/./data_structures.html#signedtransactiondata">its transaction type</a>. These are specified in the next subsections, where <code>tx</code> is short for <code>transaction.signedTransactionData</code>, and <code>sender</code> is the recovered signing <a href="specs/./data_structures.html#address">address</a>. We will define a few helper functions:</p>
<pre><code class="language-py">tipCost(y, z) = y * z
totalCost(x, y, z) = x + tipCost(y, z)
</code></pre>
<p>where <code>x</code> above is the amount of coins sent by the transaction authorizer, <code>y</code> above is the tip rate set in the transaction, and <code>z</code> above is the measure of the block space used by the transaction (i.e. size in bytes).</p>
<p>Four additional helper functions are defined to manage the <a href="specs/./data_structures.html#validator">validator queue</a>:</p>
<ol>
<li><code>findFromQueue(power)</code>, which returns the address of the last validator in the <a href="specs/./data_structures.html#validator">validator queue</a> with voting power greater than or equal to <code>power</code>, or <code>0</code> if the queue is empty or no validators in the queue have at least <code>power</code> voting power.</li>
<li><code>parentFromQueue(address)</code>, which returns the address of the parent in the validator queue of the validator with address <code>address</code>, or <code>0</code> if <code>address</code> is not in the queue or is the head of the queue.</li>
<li><code>validatorQueueInsert</code>, defined as</li>
</ol>
<pre><code class="language-py">function validatorQueueInsert(validator)
    # Insert the new validator into the linked list
    parent = findFromQueue(validator.votingPower)
    if parent != 0
        if state.accounts[parent].status == AccountStatus.ValidatorBonded
            validator.next = state.activeValidatorSet[parent].next
            state.activeValidatorSet[parent].next = sender
        else
            validator.next = state.inactiveValidatorSet[parent].next
            state.inactiveValidatorSet[parent].next = sender
    else
        validator.next = state.validatorQueueHead
        state.validatorQueueHead = sender
</code></pre>
<!-- markdownlint-disable-next-line MD029 -->
<ol start="4">
<li><code>validatorQueueRemove</code>, defined as</li>
</ol>
<pre><code class="language-py">function validatorQueueRemove(validator, sender)
    # Remove existing validator from the linked list
    parent = parentFromQueue(sender)
    if parent != 0
        if state.accounts[parent].status == AccountStatus.ValidatorBonded
            state.activeValidatorSet[parent].next = validator.next
            validator.next = 0
        else
            state.inactiveValidatorSet[parent].next = validator.next
            validator.next = 0
    else
        state.validatorQueueHead = validator.next
        validator.next = 0
</code></pre>
<p>Note that light clients cannot perform a linear search through a linked list, and are instead provided logarithmic proofs (e.g. in the case of <code>parentFromQueue</code>, a proof to the parent is provided, which should have <code>address</code> as its next validator).</p>
<p>In addition, three helper functions to manage the <a href="specs/./data_structures.html#blobpaid">blob paid list</a>:</p>
<ol>
<li><code>findFromBlobPaidList(start)</code>, which returns the transaction ID of the last transaction in the <a href="specs/./data_structures.html#blobpaid">blob paid list</a> with <code>finish</code> greater than <code>start</code>, or <code>0</code> if the list is empty or no transactions in the list have at least <code>start</code> <code>finish</code>.</li>
<li><code>parentFromBlobPaidList(txid)</code>, which returns the transaction ID of the parent in the blob paid list of the transaction with ID <code>txid</code>, or <code>0</code> if <code>txid</code> is not in the list or is the head of the list.</li>
<li><code>blobPaidListInsert</code>, defined as</li>
</ol>
<pre><code class="language-py">function blobPaidListInsert(tx, txid)
    # Insert the new transaction into the linked list
    parent = findFromBlobPaidList(tx.blobStartIndex)
    state.blobsPaid[txid].start = tx.blobStartIndex
    numShares = ceil(tx.blobSize / SHARE_SIZE)
    state.blobsPaid[txid].finish = tx.blobStartIndex + numShares - 1
    if parent != 0
        state.blobsPaid[txid].next = state.blobsPaid[parent].next
        state.blobsPaid[parent].next = txid
    else
        state.blobsPaid[txid].next = state.blobPaidHead
        state.blobPaidHead = txid
</code></pre>
<p>We define a helper function to compute F1 entries:</p>
<pre><code class="language-py">function compute_new_entry(reward, power)
    if power == 0
        return 0
    return reward // power
</code></pre>
<p>After applying a transaction, the new state state root is computed.</p>
<h4 id="signedtransactiondatatransfer"><a class="header" href="#signedtransactiondatatransfer">SignedTransactionDataTransfer</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.Transfer</code></a>.</li>
<li><code>totalCost(tx.amount, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1

state.accounts[sender].balance -= totalCost(tx.amount, tx.fee.tipRate, bytesPaid)
state.accounts[tx.to].balance += tx.amount

state.activeValidatorSet.proposerBlockReward += tipCost(bytesPaid)
</code></pre>
<h4 id="signedtransactiondatamsgpayfordata"><a class="header" href="#signedtransactiondatamsgpayfordata">SignedTransactionDataMsgPayForData</a></h4>
<pre><code class="language-py">bytesPaid = len(tx) + tx.blobSize
currentStartFinish = state.blobsPaid[findFromBlobPaidList(tx.blobStartIndex)]
parentStartFinish = state.blobsPaid[parentFromBlobPaidList(findFromBlobPaidList(tx.blobStartIndex))]
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.MsgPayForData</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li>The <code>ceil(tx.blobSize / SHARE_SIZE)</code> shares starting at index <code>tx.blobStartIndex</code> must:
<ol>
<li>Have namespace <code>tx.blobNamespace</code>.</li>
</ol>
</li>
<li><code>tx.blobShareCommitment</code> == computed as described <a href="specs/./data_structures.html#signedtransactiondatamsgpayfordata">here</a>.</li>
<li><code>parentStartFinish.finish</code> &lt; <code>tx.blobStartIndex</code>.</li>
<li><code>currentStartFinish.start</code> == <code>0</code> or <code>currentStartFinish.start</code> &gt; <code>tx.blobStartIndex + ceil(tx.blobSize / SHARE_SIZE)</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(tx.amount, tx.fee.tipRate, bytesPaid)

blobPaidListInsert(tx, id(tx))

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondatacreatevalidator"><a class="header" href="#signedtransactiondatacreatevalidator">SignedTransactionDataCreateValidator</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.CreateValidator</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>tx.commissionRate.denominator &gt; 0</code>.</li>
<li><code>tx.commissionRate.numerator &lt;= tx.commissionRate.denominator</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.None</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = AccountStatus.ValidatorQueued

validator = new Validator
validator.commissionRate = tx.commissionRate
validator.delegatedCount = 0
validator.votingPower = 0
validator.pendingRewards = 0
validator.latestEntry = PeriodEntry(0)
validator.unbondingHeight = 0
validator.isSlashed = false

validatorQueueInsert(validator)

state.inactiveValidatorSet[sender] = validator

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondatabeginunbondingvalidator"><a class="header" href="#signedtransactiondatabeginunbondingvalidator">SignedTransactionDataBeginUnbondingValidator</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.BeginUnbondingValidator</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.ValidatorQueued</code> or <code>state.accounts[sender].status</code> == <code>AccountStatus.ValidatorBonded</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = ValidatorStatus.Unbonding

if state.accounts[sender].status == AccountStatus.ValidatorQueued
    validator = state.inactiveValidatorSet[sender]
else if state.accounts[sender].status == AccountStatus.ValidatorBonded
    validator = state.activeValidatorSet[sender]
    delete state.activeValidatorSet[sender]

validator.unbondingHeight = block.height + 1
validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0

validatorQueueRemove(validator, sender)

state.inactiveValidatorSet[sender] = validator

state.activeValidatorSet.activeVotingPower -= validator.votingPower

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondataunbondvalidator"><a class="header" href="#signedtransactiondataunbondvalidator">SignedTransactionDataUnbondValidator</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.UnbondValidator</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.ValidatorUnbonding</code>.</li>
<li><code>state.inactiveValidatorSet[sender].unbondingHeight + UNBONDING_DURATION</code> &lt; <code>block.height</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">validator = state.inactiveValidatorSet[sender]

state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = AccountStatus.ValidatorUnbonded

state.accounts[sender].balance += validator.commissionRewards

state.inactiveValidatorSet[sender] = validator

if validator.delegatedCount == 0
    state.accounts[sender].status = AccountStatus.None
    delete state.inactiveValidatorSet[sender]

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondatacreatedelegation"><a class="header" href="#signedtransactiondatacreatedelegation">SignedTransactionDataCreateDelegation</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.CreateDelegation</code></a>.</li>
<li><code>totalCost(tx.amount, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>state.accounts[tx.to].status</code> == <code>AccountStatus.ValidatorQueued</code> or <code>state.accounts[tx.to].status</code> == <code>AccountStatus.ValidatorBonded</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.None</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(tx.amount, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = AccountStatus.DelegationBonded

if state.accounts[tx.to].status == AccountStatus.ValidatorQueued
    validator = state.inactiveValidatorSet[tx.to]
else if state.accounts[tx.to].status == AccountStatus.ValidatorBonded
    validator = state.activeValidatorSet[tx.to]

delegation = new Delegation
delegation.status = DelegationStatus.Bonded
delegation.validator = tx.to
delegation.stakedBalance = tx.amount
delegation.beginEntry = validator.latestEntry
delegation.endEntry = PeriodEntry(0)
delegation.unbondingHeight = 0

validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0
validator.delegatedCount += 1
validator.votingPower += tx.amount

# Update the validator in the linked list by first removing then inserting
validatorQueueRemove(validator, delegation.validator)
validatorQueueInsert(validator)

state.delegationSet[sender] = delegation

if state.accounts[tx.to].status == AccountStatus.ValidatorQueued
    state.inactiveValidatorSet[tx.to] = validator
else if state.accounts[tx.to].status == AccountStatus.ValidatorBonded
    state.activeValidatorSet[tx.to] = validator
    state.activeValidatorSet.activeVotingPower += tx.amount

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondatabeginunbondingdelegation"><a class="header" href="#signedtransactiondatabeginunbondingdelegation">SignedTransactionDataBeginUnbondingDelegation</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.BeginUnbondingDelegation</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.DelegationBonded</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = AccountStatus.DelegationUnbonding

delegation = state.delegationSet[sender]

if state.accounts[delegation.validator].status == AccountStatus.ValidatorQueued ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonding ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonded
    validator = state.inactiveValidatorSet[delegation.validator]
else if state.accounts[delegation.validator].status == AccountStatus.ValidatorBonded
    validator = state.activeValidatorSet[delegation.validator]

delegation.status = DelegationStatus.Unbonding
delegation.endEntry = validator.latestEntry
delegation.unbondingHeight = block.height + 1

validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0
validator.delegatedCount -= 1
validator.votingPower -= delegation.stakedBalance

# Update the validator in the linked list by first removing then inserting
# Only do this if the validator is actually in the queue (i.e. bonded or queued)
if state.accounts[delegation.validator].status == AccountStatus.ValidatorBonded ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorQueued
    validatorQueueRemove(validator, delegation.validator)
    validatorQueueInsert(validator)

state.delegationSet[sender] = delegation

if state.accounts[delegation.validator].status == AccountStatus.ValidatorQueued ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonding ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonded
    state.inactiveValidatorSet[delegation.validator] = validator
else if state.accounts[delegation.validator].status == AccountStatus.ValidatorBonded
    state.activeValidatorSet[delegation.validator] = validator
    state.activeValidatorSet.activeVotingPower -= delegation.stakedBalance

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondataunbonddelegation"><a class="header" href="#signedtransactiondataunbonddelegation">SignedTransactionDataUnbondDelegation</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.UnbondDelegation</code></a>.</li>
<li><code>totalCost(0, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.DelegationUnbonding</code>.</li>
<li><code>state.delegationSet[sender].unbondingHeight + UNBONDING_DURATION</code> &lt; <code>block.height</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">delegation = state.accounts[sender].delegationInfo

state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = None

# Return the delegated stake
state.accounts[sender].balance += delegation.stakedBalance
# Also disperse rewards (commission has already been levied)
state.accounts[sender].balance += delegation.stakedBalance * (delegation.endEntry - delegation.beginEntry)

if state.accounts[delegation.validator].status == AccountStatus.ValidatorQueued ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonding
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonded
    validator = state.inactiveValidatorSet[delegation.validator]
else if state.accounts[delegation.validator].status == AccountStatus.ValidatorBonded
    validator = state.activeValidatorSet[delegation.validator]

if validator.delegatedCount == 0 &amp;&amp;
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonded
    state.accounts[delegation.validator].status = AccountStatus.None
    delete state.inactiveValidatorSet[delegation.validator]

delete state.accounts[sender].delegationInfo

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondataburn"><a class="header" href="#signedtransactiondataburn">SignedTransactionDataBurn</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.Burn</code></a>.</li>
<li><code>totalCost(tx.amount, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(tx.amount, tx.fee.tipRate, bytesPaid)

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactionredelegatecommission"><a class="header" href="#signedtransactionredelegatecommission">SignedTransactionRedelegateCommission</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.RedelegateCommission</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[tx.to].status</code> == <code>AccountStatus.DelegationBonded</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.ValidatorBonded</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)

delegation = state.delegationSet[tx.to]
validator = state.activeValidatorSet[delegation.validator]

# Force-redelegate pending rewards for delegation
pendingRewards = delegation.stakedBalance * (validator.latestEntry - delegation.beginEntry)
delegation.stakedBalance += pendingRewards
delegation.beginEntry = validator.latestEntry

validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0

# Assign pending commission rewards to delegation
commissionRewards = validator.commissionRewards
delegation.stakedBalance += commissionRewards
validator.commissionRewards = 0

# Update voting power
validator.votingPower += pendingRewards + commissionRewards
state.activeValidatorSet.activeVotingPower += pendingRewards + commissionRewards

state.delegationSet[tx.to] = delegation
state.activeValidatorSet[delegation.validator] = validator

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactionredelegatereward"><a class="header" href="#signedtransactionredelegatereward">SignedTransactionRedelegateReward</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.RedelegateReward</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.DelegationBonded</code>.</li>
<li><code>state.accounts[state.delegationSet[sender].validator].status</code> == <code>AccountStatus.ValidatorBonded</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)

delegation = state.delegationSet[sender]
validator = state.activeValidatorSet[delegation.validator]

# Redelegate pending rewards for delegation
pendingRewards = delegation.stakedBalance * (validator.latestEntry - delegation.beginEntry)
delegation.stakedBalance += pendingRewards
delegation.beginEntry = validator.latestEntry

validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0

# Update voting power
validator.votingPower += pendingRewards
state.activeValidatorSet.activeVotingPower += pendingRewards

state.delegationSet[sender] = delegation
state.activeValidatorSet[delegation.validator] = validator

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="begin-block"><a class="header" href="#begin-block">Begin Block</a></h4>
<p>At the beginning of the block, rewards are distributed to the block proposer.</p>
<p>Apply the following to the state:</p>
<pre><code class="language-py">proposer = state.activeValidatorSet[block.header.proposerAddress]

# Compute block subsidy and save to state for use in end block.
rewardFactor = (TARGET_ANNUAL_ISSUANCE * BLOCK_TIME) / (SECONDS_PER_YEAR * sqrt(GENESIS_COIN_COUNT))
blockReward = rewardFactor * sqrt(state.activeValidatorSet.activeVotingPower)
state.activeValidatorSet.proposerBlockReward = blockReward

# Save proposer's initial voting power to state for use in end block.
state.activeValidatorSet.proposerInitialVotingPower = proposer.votingPower

state.activeValidatorSet[block.header.proposerAddress] = proposer
</code></pre>
<h4 id="end-block"><a class="header" href="#end-block">End Block</a></h4>
<p>Apply the following to the state:</p>
<pre><code class="language-py">account = state.accounts[block.header.proposerAddress]

if account.status == AccountStatus.ValidatorUnbonding
      account.status == AccountStatus.ValidatorUnbonded
    proposer = state.inactiveValidatorSet[block.header.proposerAddress]
else if account.status == AccountStatus.ValidatorBonded
    proposer = state.activeValidatorSet[block.header.proposerAddress]

# Flush the outstanding pending rewards.
proposer.latestEntry += compute_new_entry(proposer.pendingRewards, proposer.votingPower)
proposer.pendingRewards = 0

blockReward = state.activeValidatorSet.proposerBlockReward
commissionReward = proposer.commissionRate.numerator * blockReward // proposer.commissionRate.denominator
proposer.commissionRewards += commissionReward
proposer.pendingRewards += blockReward - commissionReward

# Even though the voting power hasn't changed yet, we consider this a period change.
proposer.latestEntry += compute_new_entry(proposer.pendingRewards, state.activeValidatorSet.proposerInitialVotingPower)
proposer.pendingRewards = 0

if account.status == AccountStatus.ValidatorUnbonding
      account.status == AccountStatus.ValidatorUnbonded
    state.inactiveValidatorSet[block.header.proposerAddress] = proposer
else if account.status == AccountStatus.ValidatorBonded
    state.activeValidatorSet[block.header.proposerAddress] = proposer
</code></pre>
<p>At the end of a block, the top <code>MAX_VALIDATORS</code> validators by voting power with voting power <em>greater than</em> zero are or become active (bonded). For newly-bonded validators, the entire validator object is moved to the active validators subtree and their status is changed to bonded. For previously-bonded validators that are no longer in the top <code>MAX_VALIDATORS</code> validators begin unbonding.</p>
<p>Bonding validators is simply setting their status to <code>AccountStatus.ValidatorBonded</code>. The logic for validator unbonding is found <a href="specs/consensus.html#signedtransactiondatabeginunbondingvalidator">here</a>, minus transaction sender updates (nonce, balance, and fee).</p>
<p>This end block implicit state transition is a single state transition, and <a href="specs/consensus.html#blockavailabledata">only has a single intermediate state root</a> associated with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="content-addressable-transaction-pool-specification"><a class="header" href="#content-addressable-transaction-pool-specification">Content Addressable Transaction Pool Specification</a></h1>
<ul>
<li>01.12.2022 | Initial specification (@cmwaters)</li>
<li>09.12.2022 | Add Push/Pull mechanics (@cmwaters)</li>
</ul>
<h2 id="outline"><a class="header" href="#outline">Outline</a></h2>
<p>This document specifies the properties, design and implementation of a content addressable transaction pool (CAT). This protocol is intended as an alternative to the FIFO and Priority mempools currently built-in to the Tendermint consensus protocol. The term content-addressable here, indicates that each transaction is identified by a smaller, unique tag (in this case a sha256 hash). These tags are broadcast among the transactions as a means of more compactly indicating which peers have which transactions. Tracking what each peer has aims at reducing the amount of duplication. In a network without content tracking, a peer may receive as many duplicate transactions as peers connected to. The tradeoff here therefore is that the transactions are significantly larger than the tag such that the sum of the data saved sending what would be duplicated transactions is larger than the sum of sending each peer a tag.</p>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>The objective of such a protocol is to transport transactions from the author (usually a client) to a proposed block, optimizing both latency and throughput i.e. how quickly can a transaction be proposed (and committed) and how many transactions can be transported into a block at once.</p>
<p>Typically the mempool serves to receive inbound transactions via an RPC endpoint, gossip them to all nodes in the network (regardless of whether they are capable of proposing a block or not), and stage groups of transactions to both consensus and the application to be included in a block.</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<p>The following are assumptions inherited from existing Tendermint mempool protocols:</p>
<ul>
<li><code>CheckTx</code> should be seen as a simple gatekeeper to what transactions enter the pool to be gossiped and staged. It is non-deterministic: one node may reject a transaction that another node keeps.</li>
<li>Applications implementing <code>CheckTx</code> are responsible for replay protection (i.e. the same transaction being present in multiple blocks). The mempool ensures that within the same block, no duplicate transactions can exist.</li>
<li>The underlying p2p layer guarantees eventually reliable broadcast. A transaction need only be sent once to eventually reach the target peer.</li>
</ul>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>The CAT protocol extends on the existing mempool implementations by introducing two new protobuf messages:</p>
<pre><code class="language-protobuf">message SeenTx {
  bytes tx_key = 1;
  optional string from = 2;
}

message WantTx {
  bytes tx_key = 1;
}
</code></pre>
<p>Both <code>SeenTx</code> and <code>WantTx</code> contain the sha256 hash of the raw transaction bytes. <code>SeenTx</code> also contains an optional <code>p2p.ID</code> that corresponds to the peer that the node received the tx from. The only validation for both is that the byte slice of the <code>tx_key</code> MUST have a length of 32.</p>
<p>Both messages are sent across a new channel with the ID: <code>byte(0x31)</code>. This enables cross compatibility as discussed in greater detail below.</p>
<blockquote>
<p><strong>Note:</strong>
The term <code>SeenTx</code> is used over the more common <code>HasTx</code> because the transaction pool contains sophisticated eviction logic. TTL's, higher priority transactions and reCheckTx may mean that a transaction pool <em>had</em> a transaction but does not have it any more. Semantically it's more appropriate to use <code>SeenTx</code> to imply not the presence of a transaction but that the node has seen it and dealt with it accordingly.</p>
</blockquote>
<h2 id="outbound-logic"><a class="header" href="#outbound-logic">Outbound logic</a></h2>
<p>A node in the protocol has two distinct modes: &quot;broadcast&quot; and &quot;request/response&quot;. When a node receives a transaction via RPC (or specifically through <code>CheckTx</code>), it assumed that it is the only recipient from that client and thus will immediately send that transaction, after validation, to all connected peers. Afterwards, only &quot;request/response&quot; is used to disseminate that transaction to everyone else.</p>
<blockquote>
<p><strong>Note:</strong>
Given that one can configure a mempool to switch off broadcast, there are no guarantees when a client submits a transaction via RPC and no error is returned that it will find its way into a proposers transaction pool.</p>
</blockquote>
<p>A <code>SeenTx</code> is broadcasted to ALL nodes upon receiving a &quot;new&quot; transaction from a peer. The transaction pool does not need to track every unique inbound transaction, therefore &quot;new&quot; is identified as:</p>
<ul>
<li>The node does not currently have the transaction</li>
<li>The node did not recently reject the transacton or has recently seen the same transaction committed (subject to the size of the cache)</li>
<li>The node did not recently evict the transaction (subject to the size of the cache)</li>
</ul>
<p>Given this criteria, it is feasible, yet unlikely that a node receives two <code>SeenTx</code> messages from the same peer for the same transaction.</p>
<p>A <code>SeenTx</code> MAY be sent for each transaction currently in the transaction pool when a connection with a peer is first established. This acts as a mechanism for syncing pool state across peers.</p>
<p>The <code>SeenTx</code> message MUST only be broadcasted after validation and storage. Although it is possible that a node later drops a transaction under load shedding, a <code>SeenTx</code> should give as strong guarantees as possible that the node can be relied upon by others that don't yet have the transcation to obtain it.</p>
<blockquote>
<p><strong>Note:</strong>
Inbound transactions submitted via the RPC do not trigger a <code>SeenTx</code> message as it is assumed that the node is the first to see the transaction and by gossiping it to others it is implied that the node has seen the transaction.</p>
</blockquote>
<p>A <code>WantTx</code> message is always sent point to point and never broadcasted. A <code>WantTx</code> MUST only be sent after receiving a <code>SeenTx</code> message from that peer. There is one exception which is that a <code>WantTx</code> MAY also be sent by a node after receiving an identical <code>WantTx</code> message from a peer that had previously received the nodes <code>SeenTx</code> but which after the lapse in time, did no longer exist in the nodes transaction pool. This provides an optional synchronous method for communicating that a node no longer has a transaction rather than relying on the defaulted asynchronous approach which is to wait for a period of time and try again with a new peer.</p>
<p><code>WantTx</code> must be tracked. A node SHOULD not send multiple <code>WantTx</code>s to multiple peers for the same transaction at once but wait for a period that matches the expected network latency before rerequesting the transaction to another peer.</p>
<h2 id="inbound-logic"><a class="header" href="#inbound-logic">Inbound logic</a></h2>
<p>Transaction pools are solely run in-memory; thus when a node stops, all transactions are discarded. To avoid the scenario where a node restarts and does not receive transactions because other nodes recorded a <code>SeenTx</code> message from their previous run, each transaction pool should track peer state based <strong>per connection</strong> and not per <code>NodeID</code>.</p>
<p>Upon receiving a <code>Txs</code> message:</p>
<ul>
<li>Check whether it is in response to a request or simply an unsolicited broadcast</li>
<li>Validate the tx against current resources and the applications <code>CheckTx</code></li>
<li>If rejected or evicted, mark accordingly</li>
<li>If successful, send a <code>SeenTx</code> message to all connected peers excluding the original sender. If it was from an initial broadcast, the <code>SeenTx</code> should populate the <code>From</code> field with the <code>p2p.ID</code> of the recipient else if it is in response to a request <code>From</code> should remain empty.</li>
</ul>
<p>Upon receiving a <code>SeenTx</code> message:</p>
<ul>
<li>It should mark the peer as having seen the message.</li>
<li>If the node has recently rejected that transaction, it SHOULD ignore the message.</li>
<li>If the node already has the transaction, it SHOULD ignore the message.</li>
<li>If the node does not have the transaction but recently evicted it, it MAY choose to rerequest the transaction if it has adequate resources now to process it.</li>
<li>If the node has not seen the transaction or does not have any pending requests for that transaction, it can do one of two things:
<ul>
<li>It MAY immediately request the tx from the peer with a <code>WantTx</code>.</li>
<li>If the node is connected to the peer specified in <code>FROM</code>, it is likely, from a non-byzantine peer, that the node will also shortly receive the transaction from the peer. It MAY wait for a <code>Txs</code> message for a bounded amount of time but MUST eventually send a <code>WantMsg</code> message to either the original peer or any other peer that <em>has</em> the specified transaction.</li>
</ul>
</li>
</ul>
<p>Upon receiving a <code>WantTx</code> message:</p>
<ul>
<li>If it has the transaction, it MUST respond with a <code>Txs</code> message containing that transaction.</li>
<li>If it does not have the transaction, it MAY respond with an identical <code>WantTx</code> or rely on the timeout of the peer that requested the transaction to eventually ask another peer.</li>
</ul>
<h2 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h2>
<p>CAT has Go API compatibility with the existing two mempool implementations. It implements both the <code>Reactor</code> interface required by Tendermint's P2P layer and the <code>Mempool</code> interface used by <code>consensus</code> and <code>rpc</code>. CAT is currently network compatible with existing implementations (by using another channel), but the protocol is unaware that it is communicating with a different mempool and that <code>SeenTx</code> and <code>WantTx</code> messages aren't reaching those peers thus it is recommended that the entire network use CAT.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="honest-block-proposer"><a class="header" href="#honest-block-proposer">Honest Block Proposer</a></h1>
<!-- toc -->
<p>This document describes the tasks of an honest block proposer to assemble a new block. Performing these actions is not enforced by the <a href="specs/./consensus.html">consensus rules</a>, so long as a valid block is produced.</p>
<h2 id="deciding-on-a-block-size"><a class="header" href="#deciding-on-a-block-size">Deciding on a Block Size</a></h2>
<p>Before <a href="specs/./data_structures.html#arranging-available-data-into-shares">arranging available data into shares</a>, the size of the original data's square must be determined.</p>
<p>There are two restrictions on the original data's square size:</p>
<ol>
<li>It must be at most <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>.</li>
<li>It must be a power of 2.</li>
</ol>
<p>With these restrictions in mind, the block proposer performs the following actions:</p>
<ol>
<li>Collect as many transactions and blobs from the mempool as possible, such that the total number of shares is at most <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>.</li>
<li>Compute the smallest square size that is a power of 2 that can fit the number of shares.</li>
<li>Attempt to lay out the collected transactions and blobs in the current square.
<ol>
<li>If the square is too small to fit all transactions and blobs (which may happen <a href="specs/../specs/data_square_layout.html">due to needing to insert padding between blobs</a>) and the square size is smaller than <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>, double the size of the square and repeat the above step.</li>
<li>If the square is too small to fit all transactions and blobs (which may happen <a href="specs/../specs/data_square_layout.html">due to needing to insert padding between blobs</a>) and the square size is at <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>, drop the transactions and blobs until the data fits within the square.</li>
</ol>
</li>
</ol>
<p>Note: the maximum padding shares between blobs should be at most twice the number of blob shares. Doubling the square size (i.e. quadrupling the number of shares in the square) should thus only have to happen at most once.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-validity-rules"><a class="header" href="#block-validity-rules">Block Validity Rules</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Unlike most blockchains, Celestia derives most of its functionality from
stateless commitments to data rather than stateful transitions. This means that
the protocol relies heavily on block validity rules. Notably, resource
constrained light clients must be able to detect when a subset of these validity
rules have not been followed in order to avoid making an honest majority
assumption on the consensus network. This has a significant impact on their
design. More information on how light clients can check the invalidity of a
block can be found in the <a href="specs/./fraud_proofs.html">Fraud Proofs</a> spec.</p>
<blockquote>
<p><strong>Note</strong> Celestia relies on CometBFT (formerly tendermint) for consensus,
meaning that it has single slot finality and is fork-free. Therefore, in order
to ensure that an invalid block is never committed to, each validator must
check that each block follows all validity rules before voting. If over two
thirds of the voting power colludes to break a validity rule, then fraud
proofs are created for light clients. After light clients verify fraud proofs,
they halt.</p>
</blockquote>
<h2 id="validity-rules"><a class="header" href="#validity-rules">Validity Rules</a></h2>
<p>Before any Celestia specific validation is performed, all CometBFT <a href="https://github.com/cometbft/cometbft/blob/v0.34.28/spec/core/data_structures.md#block">block
validation
rules</a>
must be followed.</p>
<p>Notably, this includes verifying data availability. Consensus nodes verify data
availability by simply downloading the entire block.</p>
<blockquote>
<p><strong>Note</strong> Light clients only sample a fraction of the block. More details on
how sampling actually works can be found in the seminal <a href="https://arxiv.org/abs/1809.09044">&quot;Fraud and Data
Availability Proofs: Maximising Light Client Security and Scaling Blockchains
with Dishonest Majorities&quot;</a> and in the
<a href="https://github.com/celestiaorg/celestia-node"><code>celestia-node</code></a> repo.</p>
</blockquote>
<p>Celestia specific validity rules can be categorized into multiple groups:</p>
<h3 id="block-rules"><a class="header" href="#block-rules">Block Rules</a></h3>
<ol>
<li>In <code>Block.Data.Txs</code>, all <code>BlobTx</code> transactions must be ordered after non-<code>BlobTx</code> transactions.</li>
</ol>
<h3 id="transaction-validity-rules"><a class="header" href="#transaction-validity-rules">Transaction Validity Rules</a></h3>
<h4 id="app-version-1"><a class="header" href="#app-version-1">App Version 1</a></h4>
<p>There is no validity rule that transactions must be decodable so the following rules only apply to transactions that are decodable.</p>
<ol>
<li>Decodable transactions must pass all <a href="specs/./ante_handler.html">AnteHandler</a> checks.</li>
<li>Decodable non-<code>BlobTx</code> transactions must not contain a <code>MsgPayForBlobs</code> message.</li>
<li>Decodable <code>BlobTx</code> transactions must be valid according to the <a href="specs/../../../x/blob/README.html#validity-rules">BlobTx validity rules</a>.</li>
</ol>
<h4 id="app-version-2"><a class="header" href="#app-version-2">App Version 2</a></h4>
<ol>
<li>All transactions must be decodable.</li>
<li>All transactions must pass all <a href="specs/./ante_handler.html">AnteHandler</a> checks.</li>
<li>Non-<code>BlobTx</code> transactions must not contain a <code>MsgPayForBlobs</code> message.</li>
<li><code>BlobTx</code> transactions must be valid according to the <a href="specs/../../../x/blob/README.html#validity-rules">BlobTx validity rules</a>.</li>
</ol>
<h3 id="data-root-construction"><a class="header" href="#data-root-construction">Data Root Construction</a></h3>
<p>The data root must be calculated from a correctly constructed data square per the <a href="specs/./data_square_layout.html">data square layout rules</a></p>
<p><img src="specs/./figures/rs2d_extending.svg" alt="Figure 1: Erasure Encoding" width="400"/> <img
src="./figures/rs2d_quadrants.svg" alt="Figure 2: rsmt2d" width="400"/> <img src="specs/./figures/data_root.svg" alt="Figure 3: Data Root" width="400"/></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="antehandler"><a class="header" href="#antehandler">AnteHandler</a></h1>
<p>Celestia makes use of a Cosmos SDK <a href="https://github.com/cosmos/cosmos-sdk/blob/v0.46.15/x/auth/spec/03_antehandlers.md">AnteHandler</a> in order to reject decodable sdk.Txs that do not meet certain criteria. The AnteHandler is defined in <a href="https://github.com/celestiaorg/celestia-app/blob/7f97788a64af7fe0fce00959753d6dd81663e98f/app/ante/ante.go">app/ante/ante.go</a> and is invoked at multiple times during the transaction lifecycle:</p>
<ol>
<li><code>CheckTx</code> prior to the transaction entering the mempool</li>
<li><code>PrepareProposal</code> when the block proposer includes the transaction in a block proposal</li>
<li><code>ProcessProposal</code> when validators validate the transaction in a block proposal</li>
<li><code>DeliverTx</code> when full nodes execute the transaction in a decided block</li>
</ol>
<p>The AnteHandler chains together several decorators to ensure the following criteria are met:</p>
<ul>
<li>The tx does not contain any <a href="https://github.com/cosmos/cosmos-sdk/blob/22c28366466e64ebf0df1ce5bec8b1130523552c/proto/cosmos/tx/v1beta1/tx.proto#L119-L122">extension options</a>.</li>
<li>The tx passes <code>ValidateBasic()</code>.</li>
<li>The tx's <a href="https://github.com/cosmos/cosmos-sdk/blob/22c28366466e64ebf0df1ce5bec8b1130523552c/proto/cosmos/tx/v1beta1/tx.proto#L115-L117">timeout_height</a> has not been reached if one is specified.</li>
<li>The tx's <a href="https://github.com/cosmos/cosmos-sdk/blob/22c28366466e64ebf0df1ce5bec8b1130523552c/proto/cosmos/tx/v1beta1/tx.proto#L110-L113">memo</a> is &lt;= the max memo characters where <a href="https://github.com/cosmos/cosmos-sdk/blob/a429238fc267da88a8548bfebe0ba7fb28b82a13/x/auth/README.md?plain=1#L230"><code>MaxMemoCharacters = 256</code></a>.</li>
<li>The tx's <a href="https://github.com/cosmos/cosmos-sdk/blob/22c28366466e64ebf0df1ce5bec8b1130523552c/proto/cosmos/tx/v1beta1/tx.proto#L211-L213">gas_limit</a> is &gt; the gas consumed based on the tx's size where <a href="https://github.com/cosmos/cosmos-sdk/blob/a429238fc267da88a8548bfebe0ba7fb28b82a13/x/auth/README.md?plain=1#L232"><code>TxSizeCostPerByte = 10</code></a>.</li>
<li>The tx's feepayer has enough funds to pay fees for the tx. The tx's feepayer is the feegranter (if specified) or the tx's first signer. Note the <a href="https://github.com/cosmos/cosmos-sdk/blob/v0.46.15/x/feegrant/README.md">feegrant</a> module is enabled.</li>
<li>The tx's count of signatures &lt;= the max number of signatures. The max number of signatures is <a href="https://github.com/cosmos/cosmos-sdk/blob/a429238fc267da88a8548bfebe0ba7fb28b82a13/x/auth/README.md?plain=1#L231"><code>TxSigLimit = 7</code></a>.</li>
<li>The tx's <a href="https://github.com/cosmos/cosmos-sdk/blob/22c28366466e64ebf0df1ce5bec8b1130523552c/proto/cosmos/tx/v1beta1/tx.proto#L211-L213">gas_limit</a> is &gt; the gas consumed based on the tx's signatures.</li>
<li>The tx's <a href="https://github.com/cosmos/cosmos-sdk/blob/22c28366466e64ebf0df1ce5bec8b1130523552c/types/tx/signing/signature.go#L10-L26">signatures</a> are valid. For each signature, ensure that the signature's sequence number (a.k.a nonce) matches the account sequence number of the signer.</li>
<li>The tx's <a href="https://github.com/cosmos/cosmos-sdk/blob/22c28366466e64ebf0df1ce5bec8b1130523552c/proto/cosmos/tx/v1beta1/tx.proto#L211-L213">gas_limit</a> is &gt; the gas consumed based on the blob size(s). Since blobs are charged based on the number of shares they occupy, the gas consumed is calculated as follows: <code>gasToConsume = sharesNeeded(blob) * bytesPerShare * gasPerBlobByte</code>. Where <code>bytesPerShare</code> is a global constant (an alias for <a href="https://github.com/celestiaorg/celestia-app/blob/c90e61d5a2d0c0bd0e123df4ab416f6f0d141b7f/pkg/appconsts/global_consts.go#L27-L28"><code>ShareSize = 512</code></a>) and <code>gasPerBlobByte</code> is a governance parameter that can be modified (the <a href="https://github.com/celestiaorg/celestia-app/blob/c90e61d5a2d0c0bd0e123df4ab416f6f0d141b7f/pkg/appconsts/initial_consts.go#L16-L18"><code>DefaultGasPerBlobByte = 8</code></a>).</li>
<li>The tx's total blob size is &lt;= the max blob size. The max blob size is derived from the maximum valid square size. The max valid square size is the minimum of: <code>GovMaxSquareSize</code> and <code>SquareSizeUpperBound</code>.</li>
<li>The tx does not contain a message of type <a href="https://github.com/cosmos/cosmos-sdk/blob/d6d929843bbd331b885467475bcb3050788e30ca/proto/cosmos/gov/v1/tx.proto#L33-L43">MsgSubmitProposal</a> with zero proposal messages.</li>
<li>The tx is not an IBC packet or update message that has already been processed.</li>
</ul>
<p>In addition to the above criteria, the AnteHandler also has a number of side-effects:</p>
<ul>
<li>Tx fees are deducted from the tx's feepayer and added to the fee collector module account.</li>
<li>Tx priority is calculated based on the smallest denomination of gas price in the tx and set in context.</li>
<li>The nonce of all tx signers is incremented by 1.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fraud-proofs"><a class="header" href="#fraud-proofs">Fraud Proofs</a></h1>
<h2 id="bad-encoding-fraud-proofs"><a class="header" href="#bad-encoding-fraud-proofs">Bad Encoding Fraud Proofs</a></h2>
<p>In order for data availability sampling to work, light clients must be convinced
that erasure encoded parity data was encoded correctly. For light clients, this
is ultimately enforced via <a href="https://github.com/celestiaorg/celestia-node/blob/v0.11.0-rc3/docs/adr/adr-006-fraud-service.md#detailed-design">bad encoding fraud proofs
(BEFPs)</a>.
Consensus nodes must verify this themselves before considering a block valid.
This is done automatically by verifying the data root of the header, since that
requires reconstructing the square from the block data, performing the erasure
encoding, calculating the data root using that representation, and then
comparing the data root found in the header.</p>
<h2 id="blob-inclusion"><a class="header" href="#blob-inclusion">Blob Inclusion</a></h2>
<p>TODO</p>
<h2 id="state-1"><a class="header" href="#state-1">State</a></h2>
<p>State fraud proofs allow light clients to avoid making an honest majority assumption for
state validity. While these are not incorporated into the protocol as of v1.0.0,
there are example implementations that can be found in
<a href="https://github.com/rollkit/rollkit">Rollkit</a>. More info in
<a href="https://github.com/rollkit/rollkit/blob/4fd97ba8b8352771f2e66454099785d06fd0c31b/docs/lazy-adr/adr-009-state-fraud-proofs.md">rollkit-ADR009</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking"><a class="header" href="#networking">Networking</a></h1>
<!-- toc -->
<h2 id="wire-format"><a class="header" href="#wire-format">Wire Format</a></h2>
<h3 id="availabledata-1"><a class="header" href="#availabledata-1">AvailableData</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>availableDataRows</code></td><td><a href="specs/networking.html#availabledatarow">AvailableDataRow</a><code>[]</code></td><td>List of rows.</td></tr>
</tbody></table>
</div>
<h3 id="availabledatarow"><a class="header" href="#availabledatarow">AvailableDataRow</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>shares</code></td><td><a href="specs/./data_structures.html#share">Share</a><code>[]</code></td><td>Shares in a row.</td></tr>
</tbody></table>
</div>
<h3 id="consensusproposal"><a class="header" href="#consensusproposal">ConsensusProposal</a></h3>
<p>Defined as <code>ConsensusProposal</code>:</p>
<pre><code class="language-protobuf">message ConsensusProposal {
  SignedMsgType type = 1;
  int32 round = 2;
  int32 pol_round = 3;
  // 32-byte hash
  // Proposed block header
  Header header = 4;
  AvailableDataHeader da_header = 5;
  // 64-byte signature
  bytes proposer_signature = 6;
}
</code></pre>
<p>When receiving a new block proposal <code>proposal</code> from the network, the following steps are performed in order. <em>Must</em> indicates that peers must be blacklisted (to prevent DoS attacks) and <em>should</em> indicates that the network blob can simply be ignored.</p>
<ol>
<li><code>proposal.type</code> must be a <code>SignedMsgType</code>.</li>
<li><code>proposal.round</code> is processed identically to Tendermint.</li>
<li><code>proposal.pol_round</code> is processed identically to Tendermint.</li>
<li><code>proposal.header</code> must be well-formed.</li>
<li><code>proposal.header.version.block</code> must be <a href="specs/./consensus.html#constants"><code>VERSION_BLOCK</code></a>.</li>
<li><code>proposal.header.version.app</code> must be <a href="specs/./consensus.html#constants"><code>VERSION_APP</code></a>.</li>
<li><code>proposal.header.height</code> should be previous known height + 1.</li>
<li><code>proposal.header.chain_id</code> must be <a href="specs/./consensus.html#constants"><code>CHAIN_ID</code></a>.</li>
<li><code>proposal.header.time</code> is processed identically to Tendermint.</li>
<li><code>proposal.header.last_header_hash</code> must be previous block's header hash.</li>
<li><code>proposal.header.last_commit_hash</code> must be the previous block's commit hash.</li>
<li><code>proposal.header.consensus_hash</code> must be the hash of <a href="specs/./data_structures.html#header">consensus parameters</a>.</li>
<li><code>proposal.header.state_commitment</code> must be the state root after applying the previous block's transactions.</li>
<li><code>proposal.header.available_data_original_shares_used</code> must be at most <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX ** 2</code></a>.</li>
<li><code>proposal.header.available_data_root</code> must be the <a href="specs/./data_structures.html#availabledataheader">root</a> of <code>proposal.da_header</code>.</li>
<li><code>proposal.header.proposer_address</code> must be the <a href="specs/./consensus.html#leader-selection">correct leader</a>.</li>
<li><code>proposal.da_header</code> must be well-formed.</li>
<li>The number of elements in <code>proposal.da_header.row_roots</code> and <code>proposal.da_header.row_roots</code> must be equal.</li>
<li>The number of elements in <code>proposal.da_header.row_roots</code> must be the same as computed <a href="specs/./data_structures.html#header">here</a>.</li>
<li><code>proposal.proposer_signature</code> must be a valid <a href="specs/./data_structures.html#public-key-cryptography">digital signature</a> over the header hash of <code>proposal.header</code> that recovers to <code>proposal.header.proposer_address</code>.</li>
<li>For full nodes, <code>proposal.da_header</code> must be the result of computing the roots of the shares (received separately).</li>
<li>For light nodes, <code>proposal.da_header</code> should be sampled from for availability.</li>
</ol>
<h3 id="msgwirepayfordata"><a class="header" href="#msgwirepayfordata">MsgWirePayForData</a></h3>
<p>Defined as <code>MsgWirePayForData</code>:</p>
<pre><code class="language-protobuf">message MsgWirePayForData {
  TransactionFee fee = 1;
  uint64 nonce = 2;
  // 8-byte namespace ID
  bytes message_namespace_id = 3;
  uint64 message_size = 4;
  bytes message = 5;
  repeated MessageCommitmentAndSignature message_commitment_and_signature = 6;
}
</code></pre>
<p>Accepting a <code>MsgWirePayForData</code> into the mempool requires different logic than other transactions in Celestia, since it leverages the paradigm of block proposers being able to malleate transaction data. Unlike <a href="specs/./data_structures.html#signedtransactiondatamsgpayfordata">SignedTransactionDataMsgPayForData</a> (the canonical data type that is included in blocks and committed to with a data root in the block header), each <code>MsgWirePayForData</code> (the over-the-wire representation of the same) has potentially multiple signatures.</p>
<p>Transaction senders who want to pay for a blob will create a <a href="specs/./data_structures.html#signedtransactiondatamsgpayfordata">SignedTransactionDataMsgPayForData</a> object, <code>stx</code>, filling in the <code>stx.blobShareCommitment</code> field <a href="specs/../specs/data_square_layout.html#blob-share-commitment-rules">based on the blob share commitmentrules</a>, then signing it to get a <a href="specs/./data_structures.html#transaction">transaction</a> <code>tx</code>.</p>
<p>Receiving a <code>MsgWirePayForData</code> object from the network follows the reverse process: verify using the <a href="specs/../specs/data_square_layout.html#blob-share-commitment-rules">blob share commitmentrules</a> that the signature is valid.</p>
<h2 id="invalid-erasure-coding"><a class="header" href="#invalid-erasure-coding">Invalid Erasure Coding</a></h2>
<p>If a malicious block producer incorrectly computes the 2D Reed-Solomon code for a block's data, a fraud proof for this can be presented. We assume that the light clients have the <a href="specs/./data_structures.html#availabledataheader">AvailableDataHeader</a> and the <a href="specs/./data_structures.html#header">Header</a> for each block. Hence, given a <a href="specs/networking.html#shareproof">ShareProof</a>, they can verify if the <code>rowRoot</code> or <code>colRoot</code> specified by <code>isCol</code> and <code>position</code> commits to the corresponding <a href="specs/./data_structures.html#share">Share</a>. Similarly, given the <code>height</code> of a block, they can access all elements within the <a href="specs/./data_structures.html#availabledataheader">AvailableDataHeader</a> and the <a href="specs/./data_structures.html#header">Header</a> of the block.</p>
<h3 id="shareproof"><a class="header" href="#shareproof">ShareProof</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>share</code></td><td><a href="specs/./data_structures.html#share">Share</a></td><td>The share.</td></tr>
<tr><td><code>proof</code></td><td><a href="specs/./data_structures.html#namespacemerkletreeinclusionproof">NamespaceMerkleTreeInclusionProof</a></td><td>The Merkle proof of the share in the offending row or column root.</td></tr>
<tr><td><code>isCol</code></td><td><code>bool</code></td><td>A Boolean indicating if the proof is from a row root or column root; <code>false</code> if it is a row root.</td></tr>
<tr><td><code>position</code></td><td><code>uint64</code></td><td>The index of the share in the offending row or column.</td></tr>
</tbody></table>
</div>
<h3 id="badencodingfraudproof"><a class="header" href="#badencodingfraudproof">BadEncodingFraudProof</a></h3>
<p>Defined as <code>BadEncodingFraudProof</code>:</p>
<pre><code class="language-protobuf">// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#badencodingfraudproof
message BadEncodingFraudProof {
  // height of the block with the offending row or column
  int64 height = 1;
  // the available shares in the offending row or column and their Merkle proofs
  // array of ShareProofs
  repeated ShareProof shareProofs = 2;
  // a Boolean indicating if it is an offending row or column; false if it is a row
  bool isCol = 3;
  // the index of the offending row or column in the square
  uint64 position = 4;
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>height</code></td><td><a href="specs/./data_structures.html#type-aliases">Height</a></td><td>Height of the block with the offending row or column.</td></tr>
<tr><td><code>shareProofs</code></td><td><a href="specs/networking.html#shareproof">ShareProof</a><code>[]</code></td><td>The available shares in the offending row or column.</td></tr>
<tr><td><code>isCol</code></td><td><code>bool</code></td><td>A Boolean indicating if it is an offending row or column; <code>false</code> if it is a row.</td></tr>
<tr><td><code>position</code></td><td><code>uint64</code></td><td>The index of the offending row or column in the square.</td></tr>
</tbody></table>
</div>
<h2 id="invalid-state-update"><a class="header" href="#invalid-state-update">Invalid State Update</a></h2>
<p>If a malicious block producer incorrectly computes the state, a fraud proof for this can be presented. We assume that the light clients have the <a href="specs/./data_structures.html#availabledataheader">AvailableDataHeader</a> and the <a href="specs/./data_structures.html#header">Header</a> for each block. Hence, given a <a href="specs/networking.html#shareproof">ShareProof</a>, they can verify if the <code>rowRoot</code> or <code>colRoot</code> specified by <code>isCol</code> and <code>position</code> commits to the corresponding <a href="specs/./data_structures.html#share">Share</a>. Similarly, given the <code>height</code> of a block, they can access all elements within the <a href="specs/./data_structures.html#availabledataheader">AvailableDataHeader</a> and the <a href="specs/./data_structures.html#header">Header</a> of the block.</p>
<h3 id="statefraudproof"><a class="header" href="#statefraudproof">StateFraudProof</a></h3>
<p>Defined as <code>StateFraudProof</code>:</p>
<pre><code class="language-protobuf">// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#statefraudproof
message StateFraudProof {
  // height of the block with the intermediate state roots 
  // Subtracting one from height gives the height of the block with the transactions.
  int64 height = 1;
  // shares containing the transactions and their Merkle proofs
  // isCol within the ShareProof must be false.
  // array of ShareProofs
  repeated ShareProof transactionShareProofs = 2;
  // shares containing the intermediate state roots and their Merkle proofs
  // isCol within the ShareProof must be false.
  // array of ShareProofs
  repeated ShareProof isrShareProofs = 3;
  // index for connecting the WrappedIntermediateStateRoot and WrappedTransaction after shares are parsed
  uint64 index = 4;
  // state elements that were changed by the transactions
  // array of StateElements
  repeated StateElement intermediateStateElements = 5;
  // sparse Merkle tree inclusion proofs for the state elements
  // array of SparseMerkleTreeInclusionProofs
  repeated SparseMerkleTreeInclusionProof stateInclusionProofs = 6;
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>height</code></td><td><a href="specs/./data_structures.html#type-aliases">Height</a></td><td>Height of the block with the intermediate state roots. Subtracting one from <code>height</code> gives the height of the block with the transactions.</td></tr>
<tr><td><code>transactionShareProofs</code></td><td><a href="specs/networking.html#shareproof">ShareProof</a><code>[]</code></td><td><code>isCol</code> of type <code>bool</code> must be <code>false</code>.</td></tr>
<tr><td><code>isrShareProofs</code></td><td><a href="specs/networking.html#shareproof">ShareProof</a><code>[]</code></td><td><code>isCol</code> of type <code>bool</code> must be <code>false</code>.</td></tr>
<tr><td><code>index</code></td><td><code>uint64</code></td><td>Index for connecting the <a href="specs/./data_structures.html#wrappedintermediatestateroot">WrappedIntermediateStateRoot</a> and <a href="specs/./data_structures.html#wrappedtransaction">WrappedTransaction</a> after shares are parsed.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="public-key-cryptography"><a class="header" href="#public-key-cryptography">Public-Key Cryptography</a></h1>
<!-- toc -->
<p>Consensus-critical data is authenticated using <a href="https://www.secg.org/sec1-v2.pdf">ECDSA</a> with the curves: <a href="https://en.bitcoin.it/wiki/Secp256k1">Secp256k1</a> or <a href="https://en.wikipedia.org/wiki/EdDSA#Ed25519">Ed25519</a>.</p>
<h2 id="secp256k1"><a class="header" href="#secp256k1">Secp256k1</a></h2>
<p>The Secp256k1 key type is used by accounts that submit transactions to be included in Celestia.</p>
<h3 id="libraries"><a class="header" href="#libraries">Libraries</a></h3>
<p>A highly-optimized library is available in C (<a href="https://github.com/bitcoin-core/secp256k1">https://github.com/bitcoin-core/secp256k1</a>), with wrappers in Go (<a href="https://pkg.go.dev/github.com/ethereum/go-ethereum/crypto/secp256k1">https://pkg.go.dev/github.com/ethereum/go-ethereum/crypto/secp256k1</a>) and Rust (<a href="https://docs.rs/crate/secp256k1">https://docs.rs/crate/secp256k1</a>).</p>
<h3 id="public-keys"><a class="header" href="#public-keys">Public-keys</a></h3>
<p>Secp256k1 public keys can be compressed to 257-bits (or 33 bytes) per the format described <a href="https://github.com/cosmos/cosmos-sdk/blob/v0.46.15/docs/basics/accounts.md#public-keys">here</a>.</p>
<h3 id="addresses"><a class="header" href="#addresses">Addresses</a></h3>
<p>Cosmos <a href="https://github.com/cosmos/cosmos-sdk/blob/v0.46.15/docs/basics/accounts.md#addresses">addresses</a> are 20 bytes in length.</p>
<h3 id="signatures"><a class="header" href="#signatures">Signatures</a></h3>
<!-- markdown-link-check-disable -->
<p>Deterministic signatures (<a href="https://tools.ietf.org/rfc/rfc6979.txt">RFC-6979</a>) should be used when signing, but this is not enforced at the protocol level as it cannot be for Secp256k1 signatures.</p>
<!-- markdown-link-check-enable -->
<p>Signatures are represented as the <code>r</code> and <code>s</code> (each 32 bytes) values of the signature. <code>r</code> and <code>s</code> take on their usual meaning (see: <a href="https://www.secg.org/sec1-v2.pdf">SEC 1, 4.1.3 Signing Operation</a>). Signatures are encoded with protobuf as described <a href="https://github.com/cosmos/cosmos-sdk/blob/v0.46.15/docs/core/encoding.md">here</a>.</p>
<h3 id="human-readable-encoding"><a class="header" href="#human-readable-encoding">Human Readable Encoding</a></h3>
<p>In front-ends addresses are prefixed with the <a href="https://en.bitcoin.it/wiki/Bech32">Bech32</a> prefix <code>celestia</code>. For example, a valid address is <code>celestia1kj39jkzqlr073t42am9d8pd40tgudc3e2kj9yf</code>.</p>
<h2 id="ed25519"><a class="header" href="#ed25519">Ed25519</a></h2>
<p>The Ed25519 key type is used by validators.</p>
<!-- markdownlint-disable-next-line MD024 -->
<h3 id="libraries-1"><a class="header" href="#libraries-1">Libraries</a></h3>
<ul>
<li><a href="https://pkg.go.dev/crypto/ed25519">crypto/ed25519</a></li>
<li><a href="https://pkg.go.dev/github.com/cometbft/cometbft@v0.37.0/crypto/ed25519">cometbft crypto/ed25519</a></li>
</ul>
<h3 id="public-keys-1"><a class="header" href="#public-keys-1">Public Keys</a></h3>
<p>Ed25519 public keys are 32 bytes in length. They often appear in validator configuration files (e.g. <code>genesis.json</code>) base64 encoded:</p>
<pre><code class="language-json">      &quot;pub_key&quot;: {
        &quot;type&quot;: &quot;tendermint/PubKeyEd25519&quot;,
        &quot;value&quot;: &quot;DMEMMj1+thrkUCGocbvvKzXeaAtRslvX9MWtB+smuIA=&quot;
      }
</code></pre>
<!-- markdownlint-disable-next-line MD024 -->
<h3 id="addresses-1"><a class="header" href="#addresses-1">Addresses</a></h3>
<p>Ed25519 addresses are the first 20-bytes of the SHA256 hash of the raw 32-byte public key:</p>
<pre><code class="language-go">address = SHA256(pubkey)[:20]
</code></pre>
<!-- markdownlint-disable-next-line MD024 -->
<h3 id="signatures-1"><a class="header" href="#signatures-1">Signatures</a></h3>
<p>Ed25519 signatures are 64 bytes in length.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-square-layout"><a class="header" href="#data-square-layout">Data Square Layout</a></h1>
<!-- toc -->
<h2 id="preamble"><a class="header" href="#preamble">Preamble</a></h2>
<p>Celestia uses <a href="https://arxiv.org/abs/1809.09044">a data availability scheme</a> that allows nodes to determine whether a block's data was published without downloading the whole block. The core of this scheme is arranging data in a two-dimensional matrix of <a href="specs/./shares.html">shares</a>, then applying erasure coding to each row and column. This document describes the rationale for how datatransactions, blobs, and other data<a href="specs/./data_structures.html#arranging-available-data-into-shares">is actually arranged</a>. Familiarity with the <a href="https://arxiv.org/abs/1809.09044">originally proposed data layout format</a> is assumed.</p>
<h2 id="layout-rationale"><a class="header" href="#layout-rationale">Layout Rationale</a></h2>
<p>Block data consists of:</p>
<ol>
<li>Standard cosmos-SDK transactions: (which are often represented internally as the <a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/types/tx_msg.go#L42-L50"><code>sdk.Tx</code> interface</a>) as described in <a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/docs/architecture/adr-020-protobuf-transaction-encoding.md">cosmos-sdk ADR020</a>
<ol>
<li>These transactions contain protobuf encoded <a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/types/tx_msg.go#L14-L26"><code>sdk.Msg</code></a>s, which get executed atomically (if one fails they all fail) to update the Celestia state. The complete list of modules, which define the <code>sdk.Msg</code>s that the state machine is capable of handling, can be found in the <a href="specs/../specs/state_machine_modules.html">state machine modules spec</a>. Examples include standard cosmos-sdk module messages such as <a href="https://github.com/cosmos/cosmos-sdk/blob/f71df80e93bffbf7ce5fbd519c6154a2ee9f991b/proto/cosmos/bank/v1beta1/tx.proto#L21-L32">MsgSend</a>), and celestia specific module messages such as <a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/proto/celestia/blob/v1/tx.proto#L16-L31"><code>MsgPayForBlobs</code></a></li>
</ol>
</li>
<li>Blobs: binary large objects which do not modify the Celestia state, but which are intended for a Celestia application identified with a provided namespace.</li>
</ol>
<p>We want to arrange this data into a <code>k * k</code> matrix of fixed-sized <a href="specs/../specs/shares.html">shares</a>, which will later be committed to in <a href="https://github.com/celestiaorg/nmt/blob/v0.16.0/docs/spec/nmt.md">Namespace Merkle Trees (NMTs)</a> so that individual shares in this matrix can be proven to belong to a single data root. <code>k</code> must always be a power of 2 (e.g. 1, 2, 4, 8, 16, 32, etc.) as this is optimal for the erasure coding algorithm.</p>
<p>The simplest way we can imagine arranging block data is to simply serialize it all in no particular order, split it into fixed-sized shares, then arrange those shares into the <code>k * k</code> matrix in row-major order. However, this naive scheme can be improved in a number of ways, described below.</p>
<p>First, we impose some ground rules:</p>
<ol>
<li>Data must be ordered by namespace. This makes queries into a NMT commitment of that data more efficient.</li>
<li>Since non-blob data are not naturally intended for particular namespaces, we assign <a href="specs/./namespace.html#Reserved-Namespaces">reserved namespaces</a> for them. A range of namespaces is reserved for this purpose, starting from the lowest possible namespace.</li>
<li>By construction, the above two rules mean that non-blob data always precedes blob data in the row-major matrix, even when considering single rows or columns.</li>
<li>Data with different namespaces must not be in the same share. This might cause a small amount of wasted block space, but makes the NMT easier to reason about in general since leaves are guaranteed to belong to a single namespace.</li>
</ol>
<p>Given these rules, a square may look as follows:</p>
<p><img src="specs/./figures/square_layout.svg" alt="square_layout" /></p>
<p>Padding is addressed in the <a href="specs/data_square_layout.html#padding">padding section</a>. Namespace C contains two blobs of two shares each while Namespace D contains one blob of three shares.</p>
<h3 id="ordering"><a class="header" href="#ordering">Ordering</a></h3>
<p>The order of blobs in a namespace is dictated by the priority of the PFBs that paid for the blob. A PFB with greater priority will have all blobs in that namespace strictly before a PFB with less priority. Priority is determined by the <code>gas-price</code> of the transaction (<code>fee</code>/<code>gas</code>).</p>
<h2 id="blob-share-commitment-rules"><a class="header" href="#blob-share-commitment-rules">Blob Share Commitment Rules</a></h2>
<p>Transactions can pay fees for a blob to be included in the same block as the transaction itself. It may seem natural to bundle the <code>MsgPayForBlobs</code> transaction that pays for a number of blobs with these blobs (which is the case in other blockchains with native execution, e.g. calldata in Ethereum transactions or OP_RETURN data in Bitcoin transactions), however this would mean that processes validating the state of the Celestia network would need to download all blob data. PayForBlob transactions must therefore only include a commitment to (i.e. some hash of) the blob they pay fees for. If implemented naively (e.g. with a simple hash of the blob, or a simple binary Merkle tree root of the blob), this can lead to a data availability problem, as there are no guarantees that the data behind these commitments is actually part of the block data.</p>
<p>To that end, we impose some additional rules onto <em>blobs only</em>: blobs must be placed is a way such that both the transaction sender and the block producer can be held accountablea necessary property for e.g. fee burning. Accountable in this context means that</p>
<ol>
<li>The transaction sender must pay sufficient fees for blob inclusion.</li>
<li>The block proposer cannot claim that a blob was included when it was not (which implies that a transaction and the blob it pays for must be included in the same block). In addition all blobs must be accompanied by a PayForBlob transaction.</li>
</ol>
<p>Specifically, a <code>MsgPayForBlobs</code> must include a <code>ShareCommitment</code> over the contents of each blob it is paying for. If the transaction sender knows 1) <code>k</code>, the size of the matrix, 2) the starting location of their blob in a row, and 3) the length of the blob (they know this since they are sending the blob), then they can actually compute a sequence of roots to <em>subtrees in the row NMTs</em>. Taking <em>the simple Merkle root of these subtree roots</em> provides us with the <code>ShareCommitment</code> that gets included in <code>MsgPayForBlobs</code>. Using subtree roots instead of all the leafs makes blob inclusion proofs smaller.</p>
<p><img src="specs/./figures/blob_share_commitment.svg" alt="subtree roots" /></p>
<p>Understanding 1) and 2) would usually require interaction with the block proposer. To make the possible starting locations of blobs sufficiently predictable and to make <code>ShareCommitment</code> independent of <code>k</code>, we impose an additional rule. The blob must start at a multiple of the <code>SubtreeWidth</code>.</p>
<p>The <code>SubtreeWidth</code> is calculated as the length of the blob in shares, divided by the <a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/pkg/appconsts/v1/app_consts.go#L6"><code>SubtreeRootThreshold</code></a> and rounded up to the nearest power of 2 (<a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/pkg/shares/non_interactive_defaults.go#L94-L116">implementation here</a>). If the output is greater than the minimum square size that the blob can fit in (i.e. a blob of 15 shares has a minimum square size of 4) then we take that minimum value. This <code>SubtreeWidth</code> is used as the width of the first mountain in the <a href="https://docs.grin.mw/wiki/chain-state/merkle-mountain-range/">Merkle Mountain Range</a> that would all together represent the <code>ShareCommitment</code> over the blob.</p>
<p><img src="specs/./figures/subtree_width.svg" alt="subtree root width" /></p>
<p>The <code>SubtreeRootThreshold</code> is an arbitrary versioned protocol constant that aims to put a soft limit on the number of subtree roots included in a blob inclusion proof, as described in <a href="specs/../../../docs/architecture/adr-013-non-interactive-default-rules-for-zero-padding.html">ADR013</a>. A higher <code>SubtreeRootThreshold</code> means less padding and more tightly packed squares but also means greater blob inclusion proof sizes.
With the above constraint, we can compute subtree roots deterministically. For example, a blob of 172 shares and <code>SubtreeRootThreshold</code> (SRT) = 64, must start on a share index that is a multiple of 4 because 172/64 = 3. 3 rounded up to the nearest power of 2 is 4. In this case, there will be a maximum of 3 shares of padding between blobs (more on padding below). The maximum subtree width in shares for the first mountain in the Merkle range will be 4 (The actual mountain range would be 43 subtree roots of 4 shares each). The <code>ShareCommitment</code> is then the Merkle tree over the peaks of the mountain range.</p>
<h2 id="padding-1"><a class="header" href="#padding-1">Padding</a></h2>
<p>Given these rules whereby blobs in their share format can't be directly appended one after the other, we use padding shares to fill the gaps. These are shares with a particular format (see <a href="specs/./shares.html#padding">padding</a>). Padding always comes after all the blobs in the namespace. The padding at the end of the reserved namespace and at the end of the square are special in that they belong to unique namespaces. All other padding shares use the namespace of the blob before it in the data square.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-pricing"><a class="header" href="#resource-pricing">Resource Pricing</a></h1>
<p>For all standard cosmos-sdk transactions (staking, IBC, etc), Celestia utilizes
the <a href="https://github.com/cosmos/cosmos-sdk/blob/v0.46.15/docs/basics/gas-fees.md">default cosmos-sdk mechanisms</a> for pricing resources. This involves
incrementing a gas counter during transaction execution each time the state is
read from/written to, or when specific costly operations occur such as signature
verification or inclusion of data.</p>
<pre><code class="language-go">// GasMeter interface to track gas consumption
type GasMeter interface {
	GasConsumed() Gas
	GasConsumedToLimit() Gas
	GasRemaining() Gas
	Limit() Gas
	ConsumeGas(amount Gas, descriptor string)
	RefundGas(amount Gas, descriptor string)
	IsPastLimit() bool
	IsOutOfGas() bool
	String() string
}
</code></pre>
<p>We can see how this gas meter is used in practice by looking at the store.
Notice where gas is consumed each time we write or read, specifically a flat
cost for initiating the action followed by a prorated cost for the amount of
data read or written.</p>
<pre><code class="language-go">// Implements KVStore.
func (gs *Store) Get(key []byte) (value []byte) {
	gs.gasMeter.ConsumeGas(gs.gasConfig.ReadCostFlat, types.GasReadCostFlatDesc)
	value = gs.parent.Get(key)

	// TODO overflow-safe math?
	gs.gasMeter.ConsumeGas(gs.gasConfig.ReadCostPerByte*types.Gas(len(key)), types.GasReadPerByteDesc)
	gs.gasMeter.ConsumeGas(gs.gasConfig.ReadCostPerByte*types.Gas(len(value)), types.GasReadPerByteDesc)

	return value
}

// Implements KVStore.
func (gs *Store) Set(key []byte, value []byte) {
	types.AssertValidKey(key)
	types.AssertValidValue(value)
	gs.gasMeter.ConsumeGas(gs.gasConfig.WriteCostFlat, types.GasWriteCostFlatDesc)
	// TODO overflow-safe math?
	gs.gasMeter.ConsumeGas(gs.gasConfig.WriteCostPerByte*types.Gas(len(key)), types.GasWritePerByteDesc)
	gs.gasMeter.ConsumeGas(gs.gasConfig.WriteCostPerByte*types.Gas(len(value)), types.GasWritePerByteDesc)
	gs.parent.Set(key, value)
}
</code></pre>
<p>The configuration for the gas meter used by Celestia is as follows.</p>
<pre><code class="language-go">// KVGasConfig returns a default gas config for KVStores.
func KVGasConfig() GasConfig {
	return GasConfig{
		HasCost:          1000,
		DeleteCost:       1000,
		ReadCostFlat:     1000,
		ReadCostPerByte:  3,
		WriteCostFlat:    2000,
		WriteCostPerByte: 30,
		IterNextCostFlat: 30,
	}
}

// TransientGasConfig returns a default gas config for TransientStores.
func TransientGasConfig() GasConfig {
	return GasConfig{
		HasCost:          100,
		DeleteCost:       100,
		ReadCostFlat:     100,
		ReadCostPerByte:  0,
		WriteCostFlat:    200,
		WriteCostPerByte: 3,
		IterNextCostFlat: 3,
	}
}
</code></pre>
<p>Two notable gas consumption events that are not Celestia specific are the total
bytes used for a transaction and the verification of the signature</p>
<pre><code class="language-go">func (cgts ConsumeTxSizeGasDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (sdk.Context, error) {
	sigTx, ok := tx.(authsigning.SigVerifiableTx)
	if !ok {
		return ctx, sdkerrors.Wrap(sdkerrors.ErrTxDecode, &quot;invalid tx type&quot;)
	}
	params := cgts.ak.GetParams(ctx)

	ctx.GasMeter().ConsumeGas(params.TxSizeCostPerByte*sdk.Gas(len(ctx.TxBytes())), &quot;txSize&quot;)
    ...
}

// DefaultSigVerificationGasConsumer is the default implementation of SignatureVerificationGasConsumer. It consumes gas
// for signature verification based upon the public key type. The cost is fetched from the given params and is matched
// by the concrete type.
func DefaultSigVerificationGasConsumer(
	meter sdk.GasMeter, sig signing.SignatureV2, params types.Params,
) error {
	pubkey := sig.PubKey
	switch pubkey := pubkey.(type) {
	case *ed25519.PubKey:
		meter.ConsumeGas(params.SigVerifyCostED25519, &quot;ante verify: ed25519&quot;)
		return sdkerrors.Wrap(sdkerrors.ErrInvalidPubKey, &quot;ED25519 public keys are unsupported&quot;)

	case *secp256k1.PubKey:
		meter.ConsumeGas(params.SigVerifyCostSecp256k1, &quot;ante verify: secp256k1&quot;)
		return nil

	case *secp256r1.PubKey:
		meter.ConsumeGas(params.SigVerifyCostSecp256r1(), &quot;ante verify: secp256r1&quot;)
		return nil

	case multisig.PubKey:
		multisignature, ok := sig.Data.(*signing.MultiSignatureData)
		if !ok {
			return fmt.Errorf(&quot;expected %T, got, %T&quot;, &amp;signing.MultiSignatureData{}, sig.Data)
		}
		err := ConsumeMultisignatureVerificationGas(meter, multisignature, pubkey, params, sig.Sequence)
		if err != nil {
			return err
		}
		return nil

	default:
		return sdkerrors.Wrapf(sdkerrors.ErrInvalidPubKey, &quot;unrecognized public key type: %T&quot;, pubkey)
	}
}
</code></pre>
<p>Since gas is consumed in this fashion and many of the cosmos-sdk transactions
are composable, any given transaction can have a large window of possible gas
consumption. For example, vesting accounts use more bytes of state than a normal
account, so more gas is consumed each time a vesting account is read from or
updated.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>There are four parameters that can be modified via governance to modify gas
usage.</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Default Value</th><th>Description</th><th>Changeable via Governance</th></tr></thead><tbody>
<tr><td>consensus/max_gas</td><td>-1</td><td>The maximum gas allowed in a block. Default of -1 means this value is not capped.</td><td>True</td></tr>
<tr><td>auth/tx_size_cost_per_byte</td><td>10</td><td>Gas used per each byte used by the transaction.</td><td>True</td></tr>
<tr><td>auth/sig_verify_cost_secp256k1</td><td>1000</td><td>Gas used per verifying a secp256k1 signature</td><td>True</td></tr>
<tr><td>blob/gas_per_blob_byte</td><td>8</td><td>Gas used per byte used by blob. Note that this value is applied to all encoding overhead, meaning things like the padding of the remaining share and namespace. See PFB gas estimation section for more details.</td><td>True</td></tr>
</tbody></table>
</div>
<h2 id="gas-limit"><a class="header" href="#gas-limit">Gas Limit</a></h2>
<p>The gas limit must be included in each transaction. If the transaction exceeds
this gas limit during the execution of the transaction, then the transaction
will fail.</p>
<blockquote>
<p>Note: When a transaction is submitted to the mempool, the transaction is not
fully executed. This can lead to a transaction getting accepted by the mempool
and eventually included in a block, yet failing because the transaction ends
up exceeding the gas limit.</p>
</blockquote>
<p>Fees are not currently refunded. While users can specify a gas price, the total
fee is then calculated by simply multiplying the gas limit by the gas price. The
entire fee is then deducted from the transaction no matter what.</p>
<h2 id="fee-market"><a class="header" href="#fee-market">Fee market</a></h2>
<p>By default, Celestia's consensus nodes prioritize transactions in their mempools
based on gas price. In version 1, there was no enforced minimum gas price, which
allowed each consensus node to independently set its own minimum gas price in
<code>app.toml</code>. This even permitted a gas price of 0, thereby creating the
possibility of secondary markets. In version 2, Celestia introduces a network
minimum gas price, a consensus constant, unaffected by individual node
configurations. Although nodes retain the freedom to increase gas prices
locally, all transactions in a block must be greater than or equal to the network
minimum threshold. If a block is proposed that contains a tx with a gas price
below the network min gas price, the block will be rejected as invalid.</p>
<h2 id="estimating-pfb-cost"><a class="header" href="#estimating-pfb-cost">Estimating PFB cost</a></h2>
<p>Generally, the gas used by a PFB transaction involves a static &quot;fixed cost&quot; and
a dynamic cost based on the size of each blob involved in the transaction.</p>
<blockquote>
<p>Note: For a general use case of a normal account submitting a PFB, the static
costs can be treated as such. However, due to the description above of how gas
works in the cosmos-sdk this is not always the case. Notably, if we use a
vesting account or the <code>feegrant</code> modules, then these static costs change.</p>
</blockquote>
<p>The &quot;fixed cost&quot; is an approximation of the gas consumed by operations outside
the function <code>GasToConsume</code> (for example, signature verification, tx size, read
access to accounts), which has a default value of 65,000.</p>
<blockquote>
<p>Note: the first transaction sent by an account (sequence number == 0) has an
additional one time gas cost of 10,000. If this is the case, this should be
accounted for.</p>
</blockquote>
<p>Each blob in the PFB contributes to the total gas cost based on its size. The
function <code>GasToConsume</code> calculates the total gas consumed by all the blobs
involved in a PFB, where each blob's gas cost is computed by first determining
how many shares are needed to store the blob size. Then, it computes the product
of the number of shares, the number of bytes per share, and the <code>gasPerByte</code>
parameter. Finally, it adds a static amount per blob.</p>
<p>The gas cost per blob byte and gas cost per transaction byte are parameters that
could potentially be adjusted through the system's governance mechanisms. Hence,
actual costs may vary depending on the current settings of these parameters.</p>
<h2 id="tracing-gas-consumption"><a class="header" href="#tracing-gas-consumption">Tracing Gas Consumption</a></h2>
<p>This figure plots each instance of the gas meter being incremented as a colored
dot over the execution lifecycle of a given transaction. The y-axis is units of
gas and the x-axis is cumulative gas consumption. The legend shows which color
indicates what the cause of the gas consumption was.</p>
<p>This code used to trace gas consumption can be found in the <code>tools/gasmonitor</code> of the branch for <a href="https://github.com/celestiaorg/celestia-app/pull/2131">#2131</a>, and the script to generate the plots below can be found <a href="https://gist.github.com/evan-forbes/948c8cf574f2f50b101c89a95ee1d43c">here</a> (warning: this script will not be maintained).</p>
<h3 id="msgsend"><a class="header" href="#msgsend">MsgSend</a></h3>
<p>Here we can see the gas consumption trace of a common send transaction for
1<code>utia</code></p>
<p><img src="specs/./figures/gas_consumption/msg_send_trace.png" alt="MsgSend" /></p>
<h3 id="msgcreatevalidator"><a class="header" href="#msgcreatevalidator">MsgCreateValidator</a></h3>
<p>Here we examine a more complex transaction.</p>
<p><img src="specs/./figures/gas_consumption/msg_create_validator_trace.png" alt="MsgCreateValidator" /></p>
<h3 id="pfb-with-one-single-share-blob"><a class="header" href="#pfb-with-one-single-share-blob">PFB with One Single Share Blob</a></h3>
<p><img src="specs/./figures/gas_consumption/single_share_pfb_trace.png" alt="MsgPayForBlobs Single Share" /></p>
<h3 id="pfb-with-two-single-share-blobs"><a class="header" href="#pfb-with-two-single-share-blobs">PFB with Two Single Share Blobs</a></h3>
<p>This PFB transaction contains two single share blobs. Notice the gas cost for
<code>pay for blob</code> is double what it is above due to two shares being used, and
there is also additional cost from <code>txSize</code> since the transaction itself is
larger to accommodate the second set of metadata in the PFB.</p>
<p><img src="specs/./figures/gas_consumption/pfb_with_two_single_share_blobs_trace.png" alt="MsgPayForBlobs with Two Blobs" /></p>
<h3 id="100kib-single-blob-pfb"><a class="header" href="#100kib-single-blob-pfb">100KiB Single Blob PFB</a></h3>
<p>Here we can see how the cost of a PFB with a large blob (100KiB) is quickly dominated by
the cost of the blob.</p>
<p><img src="specs/./figures/gas_consumption/100kib_pfb_trace.png" alt="MsgPayForBlobs with One Large Blob" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multisig"><a class="header" href="#multisig">Multisig</a></h1>
<p>Celestia inherits support for Multisig accounts from the Cosmos SDK. Multisig accounts behave similarly to regular accounts with the added requirement that a threshold of signatures is needed to authorize a transaction.</p>
<p>The maximum number of signatures allowed for a multisig account is determined by the <a href="specs/./params.html">param</a> <code>auth.TxSigLimit</code>. The threshold and list of signers for a multisig account are set at the time of creation and can be viewed in the <code>pubkey</code> field of a key. For example:</p>
<pre><code class="language-shell">$ celestia-appd keys show multisig
- address: celestia17rehcgutjfra8zhjl8675t8hhw8wsavzzutv06
  name: multisig
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.multisig.LegacyAminoPubKey&quot;,&quot;threshold&quot;:2,&quot;public_keys&quot;:[{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;AxMTEFDH8oyBPIH+d2MKfCIY1yAsEd0HVekoPaAOiu9c&quot;},{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;Ax0ANkTPWcCDWy9O2TcUXw90Z0DxnX2zqPvhi4VJPUl5&quot;},{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;AlUwWCGLzhclCMEKc2YLEap9H8JT5tWq1kB8BagU1TVH&quot;}]}'
  type: multi
</code></pre>
<p>Please see the <a href="https://docs.cosmos.network/main/user/run-node/multisig-guide#step-by-step-guide-to-multisig-transactions">Cosmos SDK docs</a> for more information on how to use multisig accounts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-machine-modules"><a class="header" href="#state-machine-modules">State Machine Modules</a></h1>
<p>Celestia app is built using the cosmos-sdk, and follows standard cosmos-sdk module structure.</p>
<h2 id="celestia-app-specific-modules"><a class="header" href="#celestia-app-specific-modules"><code>celestia-app</code> Specific Modules</a></h2>
<ul>
<li><a href="https://github.com/celestiaorg/celestia-app/blob/main/x/blob/README.md">blob</a></li>
<li><a href="https://github.com/celestiaorg/celestia-app/blob/main/x/minfee/README.md">minfee</a></li>
<li><a href="https://github.com/celestiaorg/celestia-app/blob/main/x/mint/README.md">mint</a></li>
<li><a href="https://github.com/celestiaorg/celestia-app/blob/main/x/paramfilter/README.md">paramfilter</a></li>
<li><a href="https://github.com/celestiaorg/celestia-app/blob/main/x/signal/README.md">signal</a></li>
<li><a href="https://github.com/celestiaorg/celestia-app/blob/main/x/tokenfilter/README.md">tokenfilter</a></li>
</ul>
<h2 id="standard-cosmos-sdk-modules"><a class="header" href="#standard-cosmos-sdk-modules">Standard <code>cosmos-sdk</code> Modules</a></h2>
<ul>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/auth/spec/README.md">auth</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/authz/spec/README.md">authz</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/bank/spec/README.md">bank</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/capability/spec/README.md">capability</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/crisis/spec/README.md">crisis</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/distribution/spec/README.md">distribution</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/evidence/spec/README.md">evidence</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/feegrant/spec/README.md">feegrant</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/tree/v1.14.0-sdk-v0.46.11/x/genutil">genutil</a> (no spec)</li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/gov/spec/README.md">gov</a></li>
<li><a href="https://github.com/cosmos/ibc/blob/f990a7f96eb7753c2fabbd49ed50b64d3a807629/README.md">ibc</a></li>
<li><a href="https://github.com/cosmos/ibc/blob/2921c5cec7b18e4ef77677e16a6b693051ae3b35/spec/app/ics-027-interchain-accounts/README.md">interchain accounts</a></li>
<li><a href="https://github.com/cosmos/ibc-apps/blob/main/middleware/packet-forward-middleware/README.md">packetforwardmiddleware</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/params/spec/README.md">params</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/slashing/spec/README.md">slashing</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/staking/spec/README.md">staking</a></li>
<li><a href="https://github.com/cosmos/ibc/blob/f990a7f96eb7753c2fabbd49ed50b64d3a807629/spec/app/ics-020-fungible-token-transfer/README.md">transfer</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/tree/v1.14.0-sdk-v0.46.11/x/auth/vesting">vesting</a> (no spec)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="celestia-governance-params"><a class="header" href="#celestia-governance-params">Celestia Governance Params</a></h1>
<p>These are the parameters for mainnet. Note that not all of these parameters are
changeable via governance. This list also includes parameter that require a
hardfork to change due to being manually hardcoded in the application or they
are blocked by the <code>x/paramfilter</code> module.</p>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<h3 id="global-parameters"><a class="header" href="#global-parameters">Global parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Default</th><th>Summary</th><th>Changeable via Governance</th></tr></thead><tbody>
<tr><td>MaxBlockSizeBytes</td><td>100MiB</td><td>Hardcoded value in CometBFT for the protobuf encoded block.</td><td>False</td></tr>
<tr><td>MaxSquareSize</td><td>128</td><td>Hardcoded maximum square size determined per shares per row or column for the original data square (not yet extended).</td><td>False</td></tr>
</tbody></table>
</div>
<h3 id="module-parameters"><a class="header" href="#module-parameters">Module parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Module.Parameter</th><th>Default</th><th>Summary</th><th>Changeable via Governance</th></tr></thead><tbody>
<tr><td>auth.MaxMemoCharacters</td><td>256</td><td>Largest allowed size for a memo in bytes.</td><td>True</td></tr>
<tr><td>auth.SigVerifyCostED25519</td><td>590</td><td>Gas used to verify Ed25519 signature.</td><td>True</td></tr>
<tr><td>auth.SigVerifyCostSecp256k1</td><td>1000</td><td>Gas used to verify secp256k1 signature.</td><td>True</td></tr>
<tr><td>auth.TxSigLimit</td><td>7</td><td>Max number of signatures allowed in a multisig transaction.</td><td>True</td></tr>
<tr><td>auth.TxSizeCostPerByte</td><td>10</td><td>Gas used per transaction byte.</td><td>True</td></tr>
<tr><td>bank.SendEnabled</td><td>true</td><td>Allow transfers.</td><td>False</td></tr>
<tr><td>blob.GasPerBlobByte</td><td>8</td><td>Gas used per blob byte.</td><td>True</td></tr>
<tr><td>blob.GovMaxSquareSize</td><td>64</td><td>Governance parameter for the maximum square size determined per shares per row or column for the original data square (not yet extended)s. If larger than MaxSquareSize, MaxSquareSize is used.</td><td>True</td></tr>
<tr><td>blobstream.DataCommitmentWindow</td><td>400</td><td>Number of blocks that are included in a signed batch (DataCommitment).</td><td>True</td></tr>
<tr><td>consensus.block.MaxBytes</td><td>1974272 bytes (~1.88 MiB)</td><td>Governance parameter for the maximum size of the protobuf encoded block.</td><td>True</td></tr>
<tr><td>consensus.block.MaxGas</td><td>-1</td><td>Maximum gas allowed per block (-1 is infinite).</td><td>True</td></tr>
<tr><td>consensus.block.TimeIotaMs</td><td>1000</td><td>Minimum time added to the time in the header each block.</td><td>False</td></tr>
<tr><td>consensus.evidence.MaxAgeDuration</td><td>1814400000000000 (21 days)</td><td>The maximum age of evidence before it is considered invalid in nanoseconds. This value should be identical to the unbonding period.</td><td>True</td></tr>
<tr><td>consensus.evidence.MaxAgeNumBlocks</td><td>120960</td><td>The maximum number of blocks before evidence is considered invalid. This value will stop CometBFT from pruning block data.</td><td>True</td></tr>
<tr><td>consensus.evidence.MaxBytes</td><td>1MiB</td><td>Maximum size in bytes used by evidence in a given block.</td><td>True</td></tr>
<tr><td>consensus.validator.PubKeyTypes</td><td>Ed25519</td><td>The type of public key used by validators.</td><td>False</td></tr>
<tr><td>consensus.Version.AppVersion</td><td>1</td><td>Determines protocol rules used for a given height. Incremented by the application upon an upgrade.</td><td>True</td></tr>
<tr><td>distribution.BaseProposerReward</td><td>0</td><td>Reward in the mint denomination for proposing a block.</td><td>True</td></tr>
<tr><td>distribution.BonusProposerReward</td><td>0</td><td>Extra reward in the mint denomination for proposers based on the voting power included in the commit.</td><td>True</td></tr>
<tr><td>distribution.CommunityTax</td><td>0.02 (2%)</td><td>Percentage of the inflation sent to the community pool.</td><td>True</td></tr>
<tr><td>distribution.WithdrawAddrEnabled</td><td>true</td><td>Enables delegators to withdraw funds to a different address.</td><td>True</td></tr>
<tr><td>gov.DepositParams.MaxDepositPeriod</td><td>604800000000000 (1 week)</td><td>Maximum period for token holders to deposit on a proposal in nanoseconds.</td><td>True</td></tr>
<tr><td>gov.DepositParams.MinDeposit</td><td>10_000_000_000 utia (10,000 TIA)</td><td>Minimum deposit for a proposal to enter voting period.</td><td>True</td></tr>
<tr><td>gov.TallyParams.Quorum</td><td>0.334 (33.4%)</td><td>Minimum percentage of total stake needed to vote for a result to be considered valid.</td><td>True</td></tr>
<tr><td>gov.TallyParams.Threshold</td><td>0.50 (50%)</td><td>Minimum proportion of Yes votes for proposal to pass.</td><td>True</td></tr>
<tr><td>gov.TallyParams.VetoThreshold</td><td>0.334 (33.4%)</td><td>Minimum value of Veto votes to Total votes ratio for proposal to be vetoed.</td><td>True</td></tr>
<tr><td>gov.VotingParams.VotingPeriod</td><td>604800000000000 (1 week)</td><td>Duration of the voting period in nanoseconds.</td><td>True</td></tr>
<tr><td>ibc.ClientGenesis.AllowedClients</td><td>[]string{&quot;06-solomachine&quot;, &quot;07-tendermint&quot;}</td><td>List of allowed IBC light clients.</td><td>True</td></tr>
<tr><td>ibc.ConnectionGenesis.MaxExpectedTimePerBlock</td><td>7500000000000 (75 seconds)</td><td>Maximum expected time per block in nanoseconds under normal operation.</td><td>True</td></tr>
<tr><td>ibc.Transfer.ReceiveEnabled</td><td>true</td><td>Enable receiving tokens via IBC.</td><td>True</td></tr>
<tr><td>ibc.Transfer.SendEnabled</td><td>true</td><td>Enable sending tokens via IBC.</td><td>True</td></tr>
<tr><td>minfee.NetworkMinGasPrice</td><td>0.000001 utia</td><td>All transactions must have a gas price greater than or equal to this value.</td><td>True</td></tr>
<tr><td>mint.BondDenom</td><td>utia</td><td>Denomination that is inflated and sent to the distribution module account.</td><td>False</td></tr>
<tr><td>mint.DisinflationRate</td><td>0.10 (10%)</td><td>The rate at which the inflation rate decreases each year.</td><td>False</td></tr>
<tr><td>mint.InitialInflationRate</td><td>0.08 (8%)</td><td>The inflation rate the network starts at.</td><td>False</td></tr>
<tr><td>mint.TargetInflationRate</td><td>0.015 (1.5%)</td><td>The inflation rate that the network aims to stabilize at.</td><td>False</td></tr>
<tr><td>slashing.DowntimeJailDuration</td><td>1 min</td><td>Duration of time a validator must stay jailed.</td><td>True</td></tr>
<tr><td>slashing.MinSignedPerWindow</td><td>0.75 (75%)</td><td>The percentage of SignedBlocksWindow that must be signed not to get jailed.</td><td>True</td></tr>
<tr><td>slashing.SignedBlocksWindow</td><td>5000</td><td>The range of blocks used to count for downtime.</td><td>True</td></tr>
<tr><td>slashing.SlashFractionDoubleSign</td><td>0.02 (2%)</td><td>Percentage slashed after a validator is jailed for double signing.</td><td>True</td></tr>
<tr><td>slashing.SlashFractionDowntime</td><td>0.00 (0%)</td><td>Percentage slashed after a validator is jailed for downtime.</td><td>True</td></tr>
<tr><td>staking.BondDenom</td><td>utia</td><td>Bondable coin denomination.</td><td>False</td></tr>
<tr><td>staking.HistoricalEntries</td><td>10000</td><td>Number of historical entries to persist in store.</td><td>True</td></tr>
<tr><td>staking.MaxEntries</td><td>7</td><td>Maximum number of entries in the redelegation queue.</td><td>True</td></tr>
<tr><td>staking.MaxValidators</td><td>100</td><td>Maximum number of validators.</td><td>True</td></tr>
<tr><td>staking.MinCommissionRate</td><td>0.05 (5%)</td><td>Minimum commission rate used by all validators.</td><td>True</td></tr>
<tr><td>staking.UnbondingTime</td><td>1814400 (21 days)</td><td>Duration of time for unbonding in seconds.</td><td>False</td></tr>
</tbody></table>
</div>
<p>Note: none of the mint module parameters are governance modifiable because they have been converted into hardcoded constants. See the x/mint README.md for more details.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
