<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Celestia App Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Celestia App Specifications</a></li><li class="chapter-item expanded "><a href="specs/index.html"><strong aria-hidden="true">1.</strong> Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specs/data_structures.html"><strong aria-hidden="true">1.1.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="specs/namespace.html"><strong aria-hidden="true">1.2.</strong> Namespace</a></li><li class="chapter-item expanded "><a href="specs/shares.html"><strong aria-hidden="true">1.3.</strong> Shares</a></li><li class="chapter-item expanded "><a href="specs/consensus.html"><strong aria-hidden="true">1.4.</strong> Consensus</a></li><li class="chapter-item expanded "><a href="specs/block_proposer.html"><strong aria-hidden="true">1.5.</strong> Block Proposer</a></li><li class="chapter-item expanded "><a href="specs/block_validity_rules.html"><strong aria-hidden="true">1.6.</strong> Block Validity Rules</a></li><li class="chapter-item expanded "><a href="specs/fraud_proofs.html"><strong aria-hidden="true">1.7.</strong> Fraud Proofs</a></li><li class="chapter-item expanded "><a href="specs/networking.html"><strong aria-hidden="true">1.8.</strong> Networking</a></li><li class="chapter-item expanded "><a href="specs/public_key_cryptography.html"><strong aria-hidden="true">1.9.</strong> Public-Key Cryptography</a></li><li class="chapter-item expanded "><a href="specs/data_square_layout.html"><strong aria-hidden="true">1.10.</strong> Data Square Layout</a></li></ol></li><li class="chapter-item expanded "><a href="specs/state_machine_modules.html"><strong aria-hidden="true">2.</strong> State Machine Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../x/blob/index.html"><strong aria-hidden="true">2.1.</strong> blob</a></li><li class="chapter-item expanded "><a href="../../x/qgb/index.html"><strong aria-hidden="true">2.2.</strong> qgb</a></li><li class="chapter-item expanded "><a href="../../x/mint/index.html"><strong aria-hidden="true">2.3.</strong> mint</a></li><li class="chapter-item expanded "><a href="../../x/paramfilter/index.html"><strong aria-hidden="true">2.4.</strong> paramfilter</a></li><li class="chapter-item expanded "><a href="../../x/upgrade/index.html"><strong aria-hidden="true">2.5.</strong> upgrade</a></li><li class="chapter-item expanded "><a href="../../x/tokenfilter/index.html"><strong aria-hidden="true">2.6.</strong> tokenfilter</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Celestia App Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/celestiaorg/celestia-app" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="celestia-app-specifications"><a class="header" href="#celestia-app-specifications">Celestia App Specifications</a></h1>
<ul>
<li><a href="./specs/index.html">Specification</a>
<ul>
<li><a href="./specs/data_structures.html">Data Structures</a></li>
<li><a href="./specs/namespace.html">Namespace</a></li>
<li><a href="./specs/shares.html">Shares</a></li>
<li><a href="./specs/consensus.html">Consensus</a></li>
<li><a href="./specs/block_proposer.html">Block Proposer</a></li>
<li><a href="./specs/block_validity_rules.html">Block Validity Rules</a></li>
<li><a href="./specs/fraud_proofs.html">Fraud Proofs</a></li>
<li><a href="./specs/networking.html">Networking</a></li>
<li><a href="./specs/public_key_cryptography.html">Public-Key Cryptography</a></li>
<li><a href="./specs/data_square_layout.html">Data Square Layout</a></li>
</ul>
</li>
<li><a href="./specs/state_machine_modules.html">State Machine Modules</a>
<ul>
<li><a href="../../x/blob/README.html">blob</a></li>
<li><a href="../../x/qgb/README.html">qgb</a></li>
<li><a href="../../x/mint/README.html">mint</a></li>
<li><a href="../../x/paramfilter/README.html">paramfilter</a></li>
<li><a href="../../x/upgrade/README.html">upgrade</a></li>
<li><a href="../../x/tokenfilter/README.html">tokenfilter</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specification"><a class="header" href="#specification">Specification</a></h1>
<ul>
<li><a href="specs/./data_structures.html">Data Structures</a></li>
<li><a href="specs/./namespace.html">Namespace</a></li>
<li><a href="specs/./shares.html">Shares</a></li>
<li><a href="specs/./consensus.html">Consensus</a></li>
<li><a href="specs/./block_proposer.html">Block Proposer</a></li>
<li><a href="specs/./block_validity_rules.html">Block Validity Rules</a></li>
<li><a href="specs/./networking.html">Networking</a></li>
<li><a href="specs/./public_key_cryptography.html">Public-Key Cryptography</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<!-- toc -->
<h2 id="data-structures-overview"><a class="header" href="#data-structures-overview">Data Structures Overview</a></h2>
<p><img src="specs/./figures/block_data_structures.svg" alt="fig: Block data structures." /></p>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th></tr></thead><tbody>
<tr><td><code>Amount</code></td><td><code>uint64</code></td></tr>
<tr><td><code>Graffiti</code></td><td><code>byte[MAX_GRAFFITI_BYTES]</code></td></tr>
<tr><td><a href="specs/data_structures.html#hashdigest"><code>HashDigest</code></a></td><td><code>byte[32]</code></td></tr>
<tr><td><code>Height</code></td><td><code>int64</code></td></tr>
<tr><td><code>Nonce</code></td><td><code>uint64</code></td></tr>
<tr><td><code>Round</code></td><td><code>int32</code></td></tr>
<tr><td><code>StateSubtreeID</code></td><td><code>byte</code></td></tr>
<tr><td><a href="specs/data_structures.html#timestamp"><code>Timestamp</code></a></td><td><code>google.protobuf.Timestamp</code></td></tr>
<tr><td><code>VotingPower</code></td><td><code>uint64</code></td></tr>
</tbody></table>
</div>
<h2 id="blockchain-data-structures"><a class="header" href="#blockchain-data-structures">Blockchain Data Structures</a></h2>
<h3 id="block"><a class="header" href="#block">Block</a></h3>
<p>Blocks are the top-level data structure of the Celestia blockchain.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>header</code></td><td><a href="specs/data_structures.html#header">Header</a></td><td>Block header. Contains primarily identification info and commitments.</td></tr>
<tr><td><code>availableDataHeader</code></td><td><a href="specs/data_structures.html#availabledataheader">AvailableDataHeader</a></td><td>Header of available data. Contains commitments to erasure-coded data.</td></tr>
<tr><td><code>availableData</code></td><td><a href="specs/data_structures.html#availabledata">AvailableData</a></td><td>Data that is erasure-coded for availability.</td></tr>
<tr><td><code>lastCommit</code></td><td><a href="specs/data_structures.html#commit">Commit</a></td><td>Previous block's Tendermint commit.</td></tr>
</tbody></table>
</div>
<h3 id="header"><a class="header" href="#header">Header</a></h3>
<p>Block header, which is fully downloaded by both full clients and light clients.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>version</code></td><td><a href="specs/data_structures.html#consensusversion">ConsensusVersion</a></td><td>The consensus version struct.</td></tr>
<tr><td><code>chainID</code></td><td><code>string</code></td><td>The <code>CHAIN_ID</code>.</td></tr>
<tr><td><code>height</code></td><td><a href="specs/data_structures.html#type-aliases">Height</a></td><td>Block height. The genesis block is at height <code>1</code>.</td></tr>
<tr><td><code>timestamp</code></td><td><a href="specs/data_structures.html#timestamp">Timestamp</a></td><td>Timestamp of this block.</td></tr>
<tr><td><code>lastHeaderHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Previous block's header hash.</td></tr>
<tr><td><code>lastCommitHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Previous block's Tendermint commit hash.</td></tr>
<tr><td><code>consensusHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Hash of <a href="specs/data_structures.html#consensus-parameters">consensus parameters</a> for this block.</td></tr>
<tr><td><code>AppHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>The <a href="specs/data_structures.html#state">state root</a> after the previous block's transactions are applied.</td></tr>
<tr><td><code>availableDataOriginalSharesUsed</code></td><td><code>uint64</code></td><td>The number of shares used in the <a href="specs/data_structures.html#arranging-available-data-into-shares">original data square</a> that are not <a href="specs/./consensus.html#reserved-namespace-ids">tail padding</a>.</td></tr>
<tr><td><code>availableDataRoot</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Root of <a href="specs/data_structures.html#availabledataheader">commitments to erasure-coded data</a>.</td></tr>
<tr><td><code>proposerAddress</code></td><td><a href="specs/data_structures.html#address">Address</a></td><td>Address of this block's proposer.</td></tr>
</tbody></table>
</div>
<p>The size of the <a href="specs/data_structures.html#arranging-available-data-into-shares">original data square</a>, <code>availableDataOriginalSquareSize</code>, isn't explicitly declared in the block header. Instead, it is implicitly computed as the smallest power of 2 whose square is at least <code>availableDataOriginalSharesUsed</code> (in other words, the smallest power of 4 that is at least <code>availableDataOriginalSharesUsed</code>).</p>
<p>The header hash is the <a href="specs/data_structures.html#hashing">hash</a> of the <a href="specs/data_structures.html#serialization">serialized</a> header.</p>
<h3 id="availabledataheader"><a class="header" href="#availabledataheader">AvailableDataHeader</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>rowRoots</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a><code>[]</code></td><td>Commitments to all erasure-coded data.</td></tr>
<tr><td><code>colRoots</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a><code>[]</code></td><td>Commitments to all erasure-coded data.</td></tr>
</tbody></table>
</div>
<p>The number of row/column roots of the original data <a href="specs/data_structures.html#share">shares</a> in <a href="specs/data_structures.html#arranging-available-data-into-shares">square layout</a> for this block. The <code>availableDataRoot</code> of the <a href="specs/data_structures.html#header">header</a> is computed using the compact row and column roots as described <a href="specs/data_structures.html#2d-reed-solomon-encoding-scheme">here</a>.</p>
<p>The number of row and column roots is each <code>availableDataOriginalSquareSize * 2</code>, and must be a power of 2. Note that the minimum <code>availableDataOriginalSquareSize</code> is 1 (not 0), therefore the number of row and column roots are each at least 2.</p>
<p>Implementations can prune rows containing only <a href="specs/./consensus.html#reserved-namespace-ids">tail padding</a> as they are implicitly available.</p>
<h3 id="availabledata"><a class="header" href="#availabledata">AvailableData</a></h3>
<p>Data that is <a href="specs/data_structures.html#erasure-coding">erasure-coded</a> for <a href="https://arxiv.org/abs/1809.09044">data availability checks</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>transactionData</code></td><td><a href="specs/data_structures.html#transactiondata">TransactionData</a></td><td>Transaction data. Transactions modify the validator set and balances, and pay fees for blobs to be included.</td></tr>
<tr><td><code>intermediateStateRootData</code></td><td><a href="specs/data_structures.html#intermediatestaterootdata">IntermediateStateRootData</a></td><td>Intermediate state roots used for fraud proofs.</td></tr>
<tr><td><code>payForBlobData</code></td><td><a href="specs/data_structures.html#payforblobdata">PayForBlobData</a></td><td>PayForBlob data. Transactions that pay for blobs to be included.</td></tr>
<tr><td><code>blobData</code></td><td><a href="specs/data_structures.html#blobdata">BlobData</a></td><td>Blob data. Blobs are app data.</td></tr>
</tbody></table>
</div>
<h3 id="commit"><a class="header" href="#commit">Commit</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>height</code></td><td><a href="specs/data_structures.html#type-aliases">Height</a></td><td>Block height.</td></tr>
<tr><td><code>round</code></td><td><a href="specs/data_structures.html#type-aliases">Round</a></td><td>Round. Incremented on view change.</td></tr>
<tr><td><code>headerHash</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Header hash of the previous block.</td></tr>
<tr><td><code>signatures</code></td><td><a href="specs/data_structures.html#commitsig">CommitSig</a><code>[]</code></td><td>List of signatures.</td></tr>
</tbody></table>
</div>
<h3 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h3>
<p>Timestamp is a <a href="specs/data_structures.html#type-aliases">type alias</a>.</p>
<p>Celestia uses <a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Timestamp"><code>google.protobuf.Timestamp</code></a> to represent time.</p>
<h3 id="hashdigest"><a class="header" href="#hashdigest">HashDigest</a></h3>
<p>HashDigest is a <a href="specs/data_structures.html#type-aliases">type alias</a>.</p>
<p>Output of the <a href="specs/data_structures.html#hashing">hashing</a> function. Exactly 256 bits (32 bytes) long.</p>
<h3 id="transactionfee"><a class="header" href="#transactionfee">TransactionFee</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>tipRate</code></td><td><code>uint64</code></td><td>The tip rate for this transaction.</td></tr>
</tbody></table>
</div>
<p>Abstraction over transaction fees.</p>
<h3 id="address"><a class="header" href="#address">Address</a></h3>
<p>Celestia supports <a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a> keys where <a href="https://docs.cosmos.network/v0.46/basics/accounts.html#addresses">addresses</a> are 20 bytes in length.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>AccAddress</code></td><td><code>[20]byte</code></td><td>AccAddress a wrapper around bytes meant to represent an account address</td></tr>
</tbody></table>
</div>
<h3 id="commitsig"><a class="header" href="#commitsig">CommitSig</a></h3>
<pre><code class="language-C++">enum CommitFlag : uint8_t {
    CommitFlagAbsent = 1,
    CommitFlagCommit = 2,
    CommitFlagNil = 3,
};
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>commitFlag</code></td><td><code>CommitFlag</code></td><td></td></tr>
<tr><td><code>validatorAddress</code></td><td><a href="specs/data_structures.html#address">Address</a></td><td></td></tr>
<tr><td><code>timestamp</code></td><td><a href="specs/data_structures.html#timestamp">Timestamp</a></td><td></td></tr>
<tr><td><code>signature</code></td><td><a href="specs/data_structures.html#signature">Signature</a></td><td></td></tr>
</tbody></table>
</div>
<h3 id="signature"><a class="header" href="#signature">Signature</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>r</code></td><td><code>byte[32]</code></td><td><code>r</code> value of the signature.</td></tr>
<tr><td><code>s</code></td><td><code>byte[32]</code></td><td><code>s</code> value of signature.</td></tr>
</tbody></table>
</div>
<h2 id="consensusversion"><a class="header" href="#consensusversion">ConsensusVersion</a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>block</code></td><td><code>uint64</code></td><td>The <code>VERSION_BLOCK</code>.</td></tr>
<tr><td><code>app</code></td><td><code>uint64</code></td><td>The <code>VERSION_APP</code>.</td></tr>
</tbody></table>
</div>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Objects that are committed to or signed over require a canonical serialization. This is done using a deterministic (and thus, bijective) variant of protobuf defined <a href="https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-027-deterministic-protobuf-serialization.md">here</a>.</p>
<p>Note: there are two requirements for a serialization scheme, should this need to be changed:</p>
<ol>
<li>Must be bijective.</li>
<li>Serialization must include the length of dynamic structures (e.g. arrays with variable length).</li>
</ol>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<!-- disable markdown link check for doi.org because it frequently fails -->
<!-- markdown-link-check-disable -->
<p>All protocol-level hashing is done using SHA-2-256 as defined in <a href="https://doi.org/10.6028/NIST.FIPS.180-4">FIPS 180-4</a>. SHA-2-256 outputs a digest that is 256 bits (i.e. 32 bytes) long.</p>
<!-- markdown-link-check-enable -->
<p>Libraries implementing SHA-2-256 are available in Go (<a href="https://pkg.go.dev/crypto/sha256">https://pkg.go.dev/crypto/sha256</a>) and Rust (<a href="https://docs.rs/sha2">https://docs.rs/sha2</a>).</p>
<p>Unless otherwise indicated explicitly, objects are first <a href="specs/data_structures.html#serialization">serialized</a> before being hashed.</p>
<h2 id="merkle-trees"><a class="header" href="#merkle-trees">Merkle Trees</a></h2>
<p>Merkle trees are used to authenticate various pieces of data across the Celestia stack, including transactions, blobs, the validator set, etc. This section provides an overview of the different tree types used, and specifies how to construct them.</p>
<h3 id="binary-merkle-tree"><a class="header" href="#binary-merkle-tree">Binary Merkle Tree</a></h3>
<p>Binary Merkle trees are constructed in the same fashion as described in <a href="https://tools.ietf.org/html/rfc6962">Certificate Transparency (RFC-6962)</a>, except for using <a href="specs/data_structures.html#hashing">a different hashing function</a>. Leaves are hashed once to get leaf node values and internal node values are the hash of the concatenation of their children (either leaf nodes or other internal nodes).</p>
<p>Nodes contain a single field:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>v</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Node value.</td></tr>
</tbody></table>
</div>
<p>The base case (an empty tree) is defined as the <a href="specs/data_structures.html#hashing">hash</a> of the empty string:</p>
<pre><code class="language-C++">node.v = 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</code></pre>
<p>For leaf node <code>node</code> of leaf data <code>d</code>:</p>
<pre><code class="language-C++">node.v = h(0x00, serialize(d))
</code></pre>
<p>For internal node <code>node</code> with children <code>l</code> and <code>r</code>:</p>
<pre><code class="language-C++">node.v = h(0x01, l.v, r.v)
</code></pre>
<p>Note that rather than duplicating the last node if there are an odd number of nodes (the <a href="https://github.com/bitcoin/bitcoin/blob/5961b23898ee7c0af2626c46d5d70e80136578d3/src/consensus/merkle.cpp#L9-L43">Bitcoin design</a>), trees are allowed to be imbalanced. In other words, the height of each leaf may be different. For an example, see Section 2.1.3 of <a href="https://tools.ietf.org/html/rfc6962#section-2.1.3">Certificate Transparency (RFC-6962)</a>.</p>
<p>Leaves and internal nodes are hashed differently: the one-byte <code>0x00</code> is prepended for leaf nodes while <code>0x01</code> is prepended for internal nodes. This avoids a second-preimage attack <a href="https://en.wikipedia.org/wiki/Merkle_tree#Second_preimage_attack">where internal nodes are presented as leaves</a> trees with leaves at different heights.</p>
<h4 id="binarymerkletreeinclusionproof"><a class="header" href="#binarymerkletreeinclusionproof">BinaryMerkleTreeInclusionProof</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>siblings</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a><code>[]</code></td><td>Sibling hash values, ordered starting from the leaf's neighbor.</td></tr>
</tbody></table>
</div>
<p>A proof for a leaf in a <a href="specs/data_structures.html#binary-merkle-tree">binary Merkle tree</a>, as per Section 2.1.1 of <a href="https://tools.ietf.org/html/rfc6962#section-2.1.1">Certificate Transparency (RFC-6962)</a>.</p>
<h3 id="namespace-merkle-tree"><a class="header" href="#namespace-merkle-tree">Namespace Merkle Tree</a></h3>
<p><a href="specs/./shares.html">Shares</a> in Celestia are associated with a provided <em>namespace</em>. The Namespace Merkle Tree (NMT) is a variation of the <a href="https://eprint.iacr.org/2018/642">Merkle Interval Tree</a>, which is itself an extension of the <a href="https://bitcointalk.org/index.php?topic=845978.0">Merkle Sum Tree</a>. It allows for compact proofs around the inclusion or exclusion of shares with particular namespace IDs.</p>
<p>Nodes contain three fields:</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>n_min</code></td><td><a href="specs/./namespace.html">Namespace</a></td><td>Min namespace in subtree rooted at this node.</td></tr>
<tr><td><code>n_max</code></td><td><a href="specs/./namespace.html">Namespace</a></td><td>Max namespace in subtree rooted at this node.</td></tr>
<tr><td><code>v</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Node value.</td></tr>
</tbody></table>
</div>
<p>The base case (an empty tree) is defined as:</p>
<pre><code class="language-C++">node.n_min = 0x0000000000000000
node.n_max = 0x0000000000000000
node.v = 0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
</code></pre>
<p>For leaf node <code>node</code> of <a href="specs/./shares.html">share</a> data <code>d</code>:</p>
<pre><code class="language-C++">node.n_min = d.namespace
node.n_max = d.namespace
node.v = h(0x00, d.namespace, d.rawData)
</code></pre>
<p>The <code>namespace</code> blob field here is the namespace of the leaf, which is a <a href="specs/consensus.html#system-parameters"><code>NAMESPACE_SIZE</code></a>-long byte array.</p>
<p>Leaves in an NMT <strong>must</strong> be lexicographically sorted by namespace in ascending order.</p>
<p>For internal node <code>node</code> with children <code>l</code> and <code>r</code>:</p>
<pre><code class="language-C++">node.n_min = min(l.n_min, r.n_min)
if l.n_min == PARITY_SHARE_NAMESPACE
  node.n_max = PARITY_SHARE_NAMESPACE
else if r.n_min == PARITY_SHARE_NAMESPACE
  node.n_max = l.n_max
else
  node.n_max = max(l.n_max, r.n_max)
node.v = h(0x01, l.n_min, l.n_max, l.v, r.n_min, r.n_max, r.v)
</code></pre>
<p>Note that the above snippet leverages the property that leaves are sorted by namespace: if <code>l.n_min</code> is <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>, so must <code>{l,r}.n_max</code>. By construction, either both the min and max namespace of a node will be <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>, or neither will: if <code>r.n_min</code> is <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>, so must <code>r.n_max</code>.</p>
<p>For some intuition: the min and max namespace for subtree roots with at least one non-parity leaf (which includes the root of an NMT, as <a href="specs/data_structures.html#2d-reed-solomon-encoding-scheme">the right half of an NMT as used in Celestia will be parity shares</a>) <em>ignore</em> the namespace ID for the parity leaves. Subtree roots with <em>only parity leaves</em> have their min and max namespace ID set to <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>. This allows for shorter proofs into the tree than if the namespace ID of parity shares was not ignored (which would cause the max namespace ID of the root to always be <a href="specs/consensus.html#reserved-state-subtree-ids"><code>PARITY_SHARE_NAMESPACE</code></a>).</p>
<p>A compact commitment can be computed by taking the <a href="specs/data_structures.html#hashing">hash</a> of the <a href="specs/data_structures.html#serialization">serialized</a> root node.</p>
<h4 id="namespacemerkletreeinclusionproof"><a class="header" href="#namespacemerkletreeinclusionproof">NamespaceMerkleTreeInclusionProof</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>siblingValues</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a><code>[]</code></td><td>Sibling hash values, ordered starting from the leaf's neighbor.</td></tr>
<tr><td><code>siblingMins</code></td><td><a href="specs/./namespace.html">Namespace</a><code>[]</code></td><td>Sibling min namespace IDs.</td></tr>
<tr><td><code>siblingMaxes</code></td><td><a href="specs/./namespace.html">Namespace</a><code>[]</code></td><td>Sibling max namespace IDs.</td></tr>
</tbody></table>
</div>
<p>When verifying an NMT proof, the root hash is checked by reconstructing the root node <code>root_node</code> with the computed <code>root_node.v</code> (computed as with a <a href="specs/data_structures.html#binarymerkletreeinclusionproof">plain Merkle proof</a>) and the provided <code>rootNamespaceMin</code> and <code>rootNamespaceMax</code> as the <code>root_node.n_min</code> and <code>root_node.n_max</code>, respectively.</p>
<h2 id="erasure-coding"><a class="header" href="#erasure-coding">Erasure Coding</a></h2>
<p>In order to enable trust-minimized light clients (i.e. light clients that do not rely on an honest majority of validating state assumption), it is critical that light clients can determine whether the data in each block is <em>available</em> or not, without downloading the whole block itself. The technique used here was formally described in the paper <a href="https://arxiv.org/abs/1809.09044">Fraud and Data Availability Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities</a>.</p>
<p>The remainder of the subsections below specify the <a href="specs/data_structures.html#2d-reed-solomon-encoding-scheme">2D Reed-Solomon erasure coding scheme</a> used, along with the format of <a href="specs/./shares.html">shares</a> and how <a href="specs/data_structures.html#available-data">available data</a> is arranged into shares.</p>
<h3 id="reed-solomon-erasure-coding"><a class="header" href="#reed-solomon-erasure-coding">Reed-Solomon Erasure Coding</a></h3>
<p>Note that while data is laid out in a two-dimensional square, rows and columns are erasure coded using a standard one-dimensional encoding.</p>
<p>Reed-Solomon erasure coding is used as the underlying coding scheme. The parameters are:</p>
<ul>
<li>16-bit Galois field</li>
<li><a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a> original pieces (maximum of <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>)</li>
<li><a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a> parity pieces (maximum of <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>) (i.e <code>availableDataOriginalSquareSize * 2</code> total pieces), for an erasure efficiency of 50%. In other words, any 50% of the pieces from the <code>availableDataOriginalSquareSize * 2</code> total pieces are enough to recover the original data.</li>
<li><a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a> bytes per piece</li>
</ul>
<p>Note that <a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a> may vary each block, and <a href="specs/./block_proposer.html#deciding-on-a-block-size">is decided by the block proposer of that block</a>. <a href="https://github.com/catid/leopard">Leopard-RS</a> is a C library that implements the above scheme with quasilinear runtime.</p>
<h3 id="2d-reed-solomon-encoding-scheme"><a class="header" href="#2d-reed-solomon-encoding-scheme">2D Reed-Solomon Encoding Scheme</a></h3>
<p>The 2-dimensional data layout is described in this section. The roots of <a href="specs/data_structures.html#namespace-merkle-tree">NMTs</a> for each row and column across four quadrants of data in a <code>2k * 2k</code> matrix of shares, <code>Q0</code> to <code>Q3</code> (shown below), must be computed. In other words, <code>2k</code> row roots and <code>2k</code> column roots must be computed. The row and column roots are stored in the <code>availableDataCommitments</code> of the <a href="specs/data_structures.html#availabledataheader">AvailableDataHeader</a>.</p>
<p><img src="specs/./figures/rs2d_quadrants.svg" alt="fig: RS2D encoding: data quadrants." /></p>
<p>The data of <code>Q0</code> is the original data, and the remaining quadrants are parity data. Setting <code>k = availableDataOriginalSquareSize</code>, the original data first must be split into <a href="specs/./shares.html">shares</a> and <a href="specs/data_structures.html#arranging-available-data-into-shares">arranged into a <code>k * k</code> matrix</a>. Then the parity data can be computed.</p>
<p>Where <code>A -&gt; B</code> indicates that <code>B</code> is computed using <a href="specs/data_structures.html#reed-solomon-erasure-coding">erasure coding</a> from <code>A</code>:</p>
<ul>
<li><code>Q0 -&gt; Q1</code> for each row in <code>Q0</code> and <code>Q1</code></li>
<li><code>Q0 -&gt; Q2</code> for each column in <code>Q0</code> and <code>Q2</code></li>
<li><code>Q2 -&gt; Q3</code> for each row in <code>Q2</code> and <code>Q3</code></li>
</ul>
<p>Note that the parity data in <code>Q3</code> will be identical if it is vertically extended from <code>Q1</code> or horizontally extended from <code>Q2</code>.</p>
<p><img src="specs/./figures/rs2d_extending.svg" alt="fig: RS2D encoding: extending data." /></p>
<p>As an example, the parity data in the second column of <code>Q2</code> (in striped purple) is computed by <a href="specs/data_structures.html#reed-solomon-erasure-coding">extending</a> the original data in the second column of <code>Q0</code> (in solid blue).</p>
<p><img src="specs/./figures/rs2d_extend.svg" alt="fig: RS2D encoding: extending a column." /></p>
<p>Now that all four quadrants of the <code>2k * 2k</code> matrix are filled, the row and column roots can be computed. To do so, each row/column is used as the leaves of a <a href="specs/data_structures.html#namespace-merkle-tree">NMT</a>, for which the compact root is computed (i.e. an extra hash operation over the NMT root is used to produce a single <a href="specs/data_structures.html#hashdigest">HashDigest</a>). In this example, the fourth row root value is computed as the NMT root of the fourth row of <code>Q0</code> and the fourth row of <code>Q1</code> as leaves.</p>
<p><img src="specs/./figures/rs2d_row.svg" alt="fig: RS2D encoding: a row root." /></p>
<p>Finally, the <code>availableDataRoot</code> of the block <a href="specs/data_structures.html#header">Header</a> is computed as the Merkle root of the <a href="specs/data_structures.html#binary-merkle-tree">binary Merkle tree</a> with the row and column roots as leaves, in that order.</p>
<p><img src="specs/./figures/data_root.svg" alt="fig: Available data root." /></p>
<h3 id="arranging-available-data-into-shares"><a class="header" href="#arranging-available-data-into-shares">Arranging Available Data Into Shares</a></h3>
<p>The previous sections described how some original data, arranged into a <code>k * k</code> matrix, can be extended into a <code>2k * 2k</code> matrix and committed to with NMT roots. This section specifies how <a href="specs/data_structures.html#available-data">available data</a> (which includes <a href="specs/data_structures.html#transactiondata">transactions</a>, <a href="specs/data_structures.html#intermediatestaterootdata">intermediate state roots</a>, PayForBlob transactions, and <a href="specs/data_structures.html#blobdata">blobs</a>) is arranged into the matrix in the first place.</p>
<p>Then,</p>
<ol>
<li>For each of <code>transactionData</code>, <code>intermediateStateRootData</code>, PayForBlob transactions, <a href="specs/data_structures.html#serialization">serialize</a>:
<ol>
<li>For each request in the list:
<ol>
<li><a href="specs/data_structures.html#serialization">Serialize</a> the request (individually).</li>
<li>Compute the length of each serialized request, <a href="specs/data_structures.html#serialization">serialize the length</a>, and pre-pend the serialized request with its serialized length.</li>
</ol>
</li>
<li>Split up the length/request pairs into <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_ID_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a>-byte chunks.</li>
<li>Create a <a href="specs/./shares.html">share</a> out of each chunk. This data has a <em>reserved</em> namespace ID, so the first <a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>+</code><a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> bytes for these shares must be set specially.</li>
</ol>
</li>
<li>Concatenate the lists of shares in the order: transactions, intermediate state roots, PayForBlob transactions.</li>
</ol>
<p>Note that by construction, each share only has a single namespace, and that the list of concatenated shares is <a href="specs/consensus.html#reserved-namespace-ids">lexicographically ordered by namespace ID</a>.</p>
<p>These shares are arranged in the <a href="specs/data_structures.html#2d-reed-solomon-encoding-scheme">first quadrant</a> (<code>Q0</code>) of the <code>availableDataOriginalSquareSize*2 * availableDataOriginalSquareSize*2</code> available data matrix in <em>row-major</em> order. In the example below, each reserved data element takes up exactly one share.</p>
<p><img src="specs/./figures/rs2d_originaldata_reserved.svg" alt="fig: Original data: reserved." /></p>
<p>Each blob in the list <code>blobData</code>:</p>
<ol>
<li><a href="specs/data_structures.html#serialization">Serialize</a> the blob (individually).</li>
<li>Compute the length of each serialized blob, <a href="specs/data_structures.html#serialization">serialize the length</a>, and pre-pend the serialized blob with its serialized length.</li>
<li>Split up the length/blob pairs into <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a>-byte chunks.</li>
<li>Create a <a href="specs/./shares.html">share</a> out of each chunk. The first <a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a> bytes for these shares is set to the namespace.</li>
</ol>
<p>For each blob, it is placed in the available data matrix, with row-major order, as follows:</p>
<ol>
<li>Place the first share of the blob at the next unused location in the matrix, then place the remaining shares in the following locations.</li>
</ol>
<p>Transactions <a href="specs/data_structures.html#transaction">must commit to a Merkle root of a list of hashes</a> that are each guaranteed (assuming the block is valid) to be subtree roots in one or more of the row NMTs. For additional info, see <a href="specs/../specs/data_square_layout.html">the rationale document</a> for this section.</p>
<p>However, with only the rule above, interaction between the block producer and transaction sender may be required to compute a commitment to the blob the transaction sender can sign over. To remove interaction, blobs can optionally be laid out using a non-interactive default:</p>
<ol>
<li>Place the first share of the blob at the next unused location in the matrix whose column is aligned with the largest power of 2 that is not larger than the blob length or <a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a>, then place the remaining shares in the following locations <strong>unless</strong> there are insufficient unused locations in the row.</li>
<li>If there are insufficient unused locations in the row, place the first share of the blob at the first column of the next row. Then place the remaining shares in the following locations. By construction, any blob whose length is greater than <a href="specs/data_structures.html#header"><code>availableDataOriginalSquareSize</code></a> will be placed in this way.</li>
</ol>
<p>In the example below, two blobs (of lengths 2 and 1, respectively) are placed using the aforementioned default non-interactive rules.</p>
<p><img src="specs/./figures/rs2d_originaldata_blob.svg" alt="fig: original data blob" /></p>
<p>The blob share commitment rules may introduce empty shares that do not belong to any blob (in the example above, the top-right share is empty). These are zeroes with namespace ID equal to the either <a href="specs/./consensus.html#constants"><code>TAIL_TRANSACTION_PADDING_NAMESPACE_ID</code></a> if between a request with a reserved namespace ID and a blob, or the namespace ID of the previous blob if succeeded by a blob. See the <a href="specs/../specs/data_square_layout.html">rationale doc</a> for more info.</p>
<h2 id="available-data"><a class="header" href="#available-data">Available Data</a></h2>
<h3 id="transactiondata"><a class="header" href="#transactiondata">TransactionData</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>wrappedTransactions</code></td><td><a href="specs/data_structures.html#wrappedtransaction">WrappedTransaction</a><code>[]</code></td><td>List of wrapped transactions.</td></tr>
</tbody></table>
</div>
<h4 id="wrappedtransaction"><a class="header" href="#wrappedtransaction">WrappedTransaction</a></h4>
<p>Wrapped transactions include additional metadata by the block proposer that is committed to in the <a href="specs/data_structures.html#arranging-available-data-into-shares">available data matrix</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>index</code></td><td><code>uint64</code></td><td>Index of this transaction in the list of wrapped transactions. This information is lost when splitting transactions into fixed-sized <a href="specs/./shares.html">shares</a>, and needs to be re-added here for fraud proof support. Allows linking a transaction to an <a href="specs/data_structures.html#wrappedintermediatestateroot">intermediate state root</a>.</td></tr>
<tr><td><code>transaction</code></td><td><a href="specs/data_structures.html#transaction">Transaction</a></td><td>Actual transaction.</td></tr>
<tr><td><code>blobStartIndex</code></td><td><code>uint64</code></td><td><em>Optional, only used if transaction pays for a blob or padding</em>. Share index (in row-major order) of first share of blob this transaction pays for. Needed for light verification of proper blob inclusion.</td></tr>
</tbody></table>
</div>
<h4 id="transaction"><a class="header" href="#transaction">Transaction</a></h4>
<p>Celestia transactions are Cosmos SDK <a href="https://docs.cosmos.network/v0.46/core/transactions.html">transactions</a>.</p>
<h3 id="payforblobdata"><a class="header" href="#payforblobdata">PayForBlobData</a></h3>
<h3 id="intermediatestaterootdata"><a class="header" href="#intermediatestaterootdata">IntermediateStateRootData</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>wrappedIntermediateStateRoots</code></td><td><a href="specs/data_structures.html#wrappedintermediatestateroot">WrappedIntermediateStateRoot</a><code>[]</code></td><td>List of wrapped intermediate state roots.</td></tr>
</tbody></table>
</div>
<h4 id="wrappedintermediatestateroot"><a class="header" href="#wrappedintermediatestateroot">WrappedIntermediateStateRoot</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>index</code></td><td><code>uint64</code></td><td>Index of this intermediate state root in the list of intermediate state roots. This information is lost when splitting intermediate state roots into fixed-sized <a href="specs/./shares.html">shares</a>, and needs to be re-added here for fraud proof support. Allows linking an intermediate state root to a <a href="specs/data_structures.html#wrappedtransaction">transaction</a>.</td></tr>
<tr><td><code>intermediateStateRoot</code></td><td><a href="specs/data_structures.html#intermediatestateroot">IntermediateStateRoot</a></td><td>Intermediate state root. Used for fraud proofs.</td></tr>
</tbody></table>
</div>
<h4 id="intermediatestateroot"><a class="header" href="#intermediatestateroot">IntermediateStateRoot</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>root</code></td><td><a href="specs/data_structures.html#hashdigest">HashDigest</a></td><td>Root of intermediate state, which is composed of the global state and the validator set.</td></tr>
</tbody></table>
</div>
<h3 id="blobdata"><a class="header" href="#blobdata">BlobData</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>blobs</code></td><td><a href="specs/data_structures.html#blob">Blob</a><code>[]</code></td><td>List of blobs.</td></tr>
</tbody></table>
</div>
<h4 id="blob"><a class="header" href="#blob">Blob</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>namespaceID</code></td><td><a href="specs/data_structures.html#type-aliases">NamespaceID</a></td><td>Namespace ID of this blob.</td></tr>
<tr><td><code>rawData</code></td><td><code>byte[]</code></td><td>Raw blob bytes.</td></tr>
</tbody></table>
</div>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>The state of the Celestia chain is intentionally restricted to containing only account balances and the validator set metadata. Similar to other Cosmos SDK based chains, the state of the Celestia chain is maintained in a <a href="https://docs.cosmos.network/main/core/store#multistore">multistore</a>. The root of the application state is committed to in the <a href="specs/data_structures.html#header">block header</a> via the <code>AppHash</code>.</p>
<h2 id="consensus-parameters"><a class="header" href="#consensus-parameters">Consensus Parameters</a></h2>
<p>Various <a href="specs/consensus.html#system-parameters">consensus parameters</a> are committed to in the block header, such as limits and constants.</p>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>version</code></td><td><a href="specs/data_structures.html#consensusversion">ConsensusVersion</a></td><td>The consensus version struct.</td></tr>
<tr><td><code>chainID</code></td><td><code>string</code></td><td>The <code>CHAIN_ID</code>.</td></tr>
<tr><td><code>shareSize</code></td><td><code>uint64</code></td><td>The <code>SHARE_SIZE</code>.</td></tr>
<tr><td><code>shareReservedBytes</code></td><td><code>uint64</code></td><td>The <code>SHARE_RESERVED_BYTES</code>.</td></tr>
<tr><td><code>availableDataOriginalSquareMax</code></td><td><code>uint64</code></td><td>The <code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code>.</td></tr>
</tbody></table>
</div>
<p>In order to compute the <code>consensusHash</code> field in the <a href="specs/data_structures.html#header">block header</a>, the above list of parameters is <a href="specs/data_structures.html#hashing">hashed</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespace"><a class="header" href="#namespace">Namespace</a></h1>
<!-- toc -->
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>One of Celestia's core data structures is the namespace. When a user submits a <code>MsgPayForBlobs</code> transaction to Celestia they MUST associate each blob with exactly one namespace. After their transaction has been included in a block, the namespace enables users to take an interest in a subset of the blobs published to Celestia by allowing the user to query for blobs by namespace.</p>
<p>In order to enable efficient retrieval of blobs by namespace, Celestia makes use of a <a href="https://github.com/celestiaorg/nmt">Namespaced Merkle Tree</a>. See section 5.2 of the <a href="https://arxiv.org/pdf/1905.09274.pdf">LazyLedger whitepaper</a> for more details.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>A namespace is composed of two fields: <a href="specs/namespace.html#version">version</a> and <a href="specs/namespace.html#id">id</a>. A namespace is encoded as a byte slice with the version and id concatenated. Each <a href="specs/./shares.html">share</a> is prefixed with exactly one namespace.</p>
<p><img src="specs/./figures/namespace.svg" alt="namespace" /></p>
<h3 id="version"><a class="header" href="#version">Version</a></h3>
<p>The namespace version is an 8-bit unsigned integer that indicates the version of the namespace. The version is used to determine the format of the namespace. The only supported user-specifiable namespace version is <code>0</code>. The version is encoded as a single byte.</p>
<p>Note: The <code>PARITY_SHARE_NAMESPACE</code> uses the namespace version <code>255</code> so that it can be ignored via the <code>IgnoreMaxNamespace</code> feature from <a href="https://github.com/celestiaorg/nmt">nmt</a>. The <code>TAIL_PADDING_NAMESPACE</code> uses the namespace version <code>255</code> so that it remains ordered after all blob namespaces even in the case a new namespace version is introduced.</p>
<p>A namespace with version <code>0</code> must contain an id with a prefix of 18 leading <code>0</code> bytes. The remaining 10 bytes of the id are user-specified.</p>
<pre><code class="language-go">// Valid encoded namespaces
0x0000000000000000000000000000000000000000000000000000000001 // transaction namespace
0x0000000000000000000000000000000000000001010101010101010101 // valid blob namespace
0x0000000000000000000000000000000000000011111111111111111111 // valid blob namespace

// Invalid encoded namespaces
0x0000000000000000000000000111111111111111111111111111111111 // invalid because it does not have 18 leading 0 bytes
0x1000000000000000000000000000000000000000000000000000000000 // invalid because it does not have version 0
0x1111111111111111111111111111111111111111111111111111111111 // invalid because it does not have version 0
</code></pre>
<p>A new namespace version MUST be introduced if the namespace format changes in a backwards incompatible way (i.e. the number of leading <code>0</code> bytes in the id prefix is reduced).</p>
<h3 id="id"><a class="header" href="#id">ID</a></h3>
<p>The namespace ID is a 28 byte identifier that uniquely identifies a namespace. The ID is encoded as a byte slice of length 28.</p>
<h2 id="reserved-namespaces"><a class="header" href="#reserved-namespaces">Reserved Namespaces</a></h2>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>value</th><th>description</th></tr></thead><tbody>
<tr><td><code>TRANSACTION_NAMESPACE</code></td><td><code>Namespace</code></td><td><code>0x0000000000000000000000000000000000000000000000000000000001</code></td><td>Transactions: requests that modify the state.</td></tr>
<tr><td><code>INTERMEDIATE_STATE_ROOT_NAMESPACE</code></td><td><code>Namespace</code></td><td><code>0x0000000000000000000000000000000000000000000000000000000002</code></td><td>Intermediate state roots, committed after every transaction.</td></tr>
<tr><td><code>PAY_FOR_BLOB_NAMESPACE</code></td><td><code>Namespace</code></td><td><code>0x0000000000000000000000000000000000000000000000000000000004</code></td><td>Namespace reserved for transactions that contain a PayForBlob.</td></tr>
<tr><td><code>RESERVED_PADDING_NAMESPACE</code></td><td><code>Namespace</code></td><td><code>0x00000000000000000000000000000000000000000000000000000000FF</code></td><td>Padding after all reserved namespaces but before blobs.</td></tr>
<tr><td><code>MAX_RESERVED_NAMESPACE</code></td><td><code>Namespace</code></td><td><code>0x00000000000000000000000000000000000000000000000000000000FF</code></td><td>Max reserved namespace is lexicographically the largest namespace that is reserved for protocol use.</td></tr>
<tr><td><code>TAIL_PADDING_NAMESPACE</code></td><td><code>Namespace</code></td><td><code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE</code></td><td>Tail padding for blobs: padding after all blobs to fill up the original data square.</td></tr>
<tr><td><code>PARITY_SHARE_NAMESPACE</code></td><td><code>Namespace</code></td><td><code>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</code></td><td>Parity shares: extended shares in the available data matrix.</td></tr>
</tbody></table>
</div>
<h2 id="assumptions-and-considerations"><a class="header" href="#assumptions-and-considerations">Assumptions and Considerations</a></h2>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>See <a href="specs/../../../pkg/namespace">pkg/namespace</a>.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li><a href="specs/../../../docs/architecture/adr-014-versioned-namespaces.html">ADR-014</a></li>
<li><a href="specs/../../../docs/architecture/adr-015-namespace-id-size.html">ADR-015</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shares"><a class="header" href="#shares">Shares</a></h1>
<!-- toc -->
<h2 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h2>
<p>All available data in a Celestia <a href="specs/./data_structures.html#block">block</a> is split into fixed-size data chunks known as &quot;shares&quot;. Shares are the atomic unit of the Celestia data square. The shares in a Celestia block are eventually <a href="specs/./data_structures.html#erasure-coding">erasure-coded</a> and committed to in <a href="specs/./data_structures.html#namespace-merkle-tree">Namespace Merkle trees</a> (also see <a href="https://github.com/celestiaorg/nmt/blob/master/docs/spec/nmt.md">NMT spec</a>).</p>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<ul>
<li><strong>Blob</strong>: User specified data (e.g. a roll-up block) that is associated with exactly one namespace. Blob data are opaque bytes of data that are included in the block but do not impact Celestia's state.</li>
<li><strong>Share</strong>: A fixed-size data chunk that is associated with exactly one namespace.</li>
<li><strong>Share sequence</strong>: A share sequence is a contiguous set of shares that contain semantically relevant data. A share sequence MUST contain one or more shares. When a <a href="specs/../../../x/blob/README.html">blob</a> is split into shares, it is written to one share sequence. As a result, all shares in a share sequence are typically parsed together because the original blob data may have been split across share boundaries. All transactions in the <a href="specs/./namespace.html#reserved-namespaces"><code>TRANSACTION_NAMESPACE</code></a> are contained in one share sequence. All transactions in the <a href="specs/./namespace.html#reserved-namespaces"><code>PAY_FOR_BLOB_NAMESPACE</code></a> are contained in one share sequence.</li>
</ul>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>User submitted transactions are split into shares (see <a href="specs/shares.html#share-splitting">share splitting</a>) and arranged in a <code>k * k</code> matrix (see <a href="specs/./data_structures.html#arranging-available-data-into-shares">arranging available data into shares</a>) prior to the erasure coding step. Shares in the <code>k * k</code> matrix are ordered by namespace and have a common <a href="specs/shares.html#share-format">share format</a>.</p>
<p><a href="specs/shares.html#padding">Padding</a> shares are added to the <code>k * k</code> matrix to ensure:</p>
<ol>
<li>Blob sequences start on an index that conforms to <a href="specs/./data_square_layout.html#blob-share-commitment-rules">blob share commitment rules</a> (see <a href="specs/shares.html#namespace-padding-share">namespace padding share</a> and <a href="specs/shares.html#reserved-padding-share">reserved padding share</a>)</li>
<li>The number of shares in the matrix is a perfect square (see <a href="specs/shares.html#tail-padding-share">tail padding share</a>)</li>
</ol>
<h2 id="share-format"><a class="header" href="#share-format">Share Format</a></h2>
<p>Every share has a fixed size <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a>. The share format below is consistent for all shares:</p>
<ul>
<li>The first <a href="specs/./consensus.html#constants"><code>NAMESPACE_VERSION_SIZE</code></a> bytes of a share's raw data is the namespace version of that share (denoted by &quot;namespace version&quot; in the figure below).</li>
<li>The next <a href="specs/./consensus.html#constants"><code>NAMESPACE_ID_SIZE</code></a> bytes of a share's raw data is the namespace ID of that share (denoted by &quot;namespace id&quot; in the figure below).</li>
<li>The next <a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a> bytes are for share information (denoted by &quot;info byte&quot; in the figure below) with the following structure:
<ul>
<li>The first 7 bits represent the <a href="specs/shares.html#share-version">share version</a> in big endian form (initially, this will be <code>0000000</code> for version <code>0</code>);</li>
<li>The last bit is a sequence start indicator. The indicator is <code>1</code> if this share is the first share in a sequence or <code>0</code> if this share is a continuation share in a sequence.</li>
</ul>
</li>
<li>If this share is the first share in a sequence, it will include the length of the sequence in bytes. The next <a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> represent a big-endian uint32 value (denoted by &quot;sequence length&quot; in the figure below). This length is placed immediately after the <code>SHARE_INFO_BYTES</code> field. It's important to note that shares that are not the first share in a sequence do not contain this field.</li>
<li>The remaining <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> bytes (if first share) or <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a> bytes (if continuation share) are raw data (denoted by &quot;blob1&quot; in the figure below). Typically raw data is the blob payload that user's submit in a <a href="specs/../../../x/blob/README.html">BlobTx</a>. However, raw data can also be transaction data (see <a href="specs/shares.html#transaction-shares">transaction shares</a> below).</li>
<li>If there is insufficient raw data to fill the share, the remaining bytes are filled with <code>0</code>.</li>
</ul>
<p>First share in a sequence:</p>
<p><img src="specs/./figures/share_start.svg" alt="figure 1: share start" /></p>
<p>Continuation share in a sequence:</p>
<p><img src="specs/./figures/share_continuation.svg" alt="figure 2: share continuation" /></p>
<p>Since raw data that exceeds <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a> <code>-</code> <a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> bytes will span more than one share, developers MAY choose to encode additional metadata in their raw blob data prior to inclusion in a Celestia block. For example, Celestia transaction shares encode additional metadata in the form of &quot;reserved bytes&quot;.</p>
<h3 id="share-version"><a class="header" href="#share-version">Share Version</a></h3>
<p>The share version is a 7-bit big-endian unsigned integer that is used to indicate the version of the <a href="specs/shares.html#share-format">share format</a>. The only supported share version is <code>0</code>. A new share version MUST be introduced if the share format changes in a way that is not backwards compatible.</p>
<h2 id="transaction-shares"><a class="header" href="#transaction-shares">Transaction Shares</a></h2>
<p>In order for clients to parse shares in the middle of a sequence without downloading antecedent shares, Celestia encodes additional metadata in the shares associated with reserved namespaces. At the time of writing this only applies to the <a href="specs/./namespace.html#reserved-namespaces"><code>TRANSACTION_NAMESPACE</code></a> and <a href="specs/./namespace.html#reserved-namespaces"><code>PAY_FOR_BLOB_NAMESPACE</code></a>. This share structure is often referred to as &quot;compact shares&quot; to differentiate from the share structure defined above for all shares. It conforms to the common <a href="specs/shares.html#share-format">share format</a> with one additional field, the &quot;reserved bytes&quot; field, which is described below:</p>
<ul>
<li>Every transaction share includes <a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> bytes that contain the index of the starting byte of the length of the <a href="specs/./consensus.html#serialization">canonically serialized</a> first transaction that starts in the share, or <code>0</code> if there is none, as a binary big endian <code>uint32</code>. Denoted by &quot;reserved bytes&quot; in the figure below. The <a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> are placed immediately after the <code>SEQUENCE_BYTES</code> if this is the first share in a sequence or immediately after the <code>SHARE_INFO_BYTES</code> if this is a continuation share in a sequence.</li>
<li>The remaining <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> bytes (if first share) or <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_RESERVED_BYTES</code></a> bytes (if continuation share) are transaction or PayForBlob transaction data (denoted by &quot;tx1&quot; and &quot;tx2&quot; in the figure below). Each transaction or PayForBlob transaction is prefixed with a <a href="https://developers.google.com/protocol-buffers/docs/encoding">varint</a> of the length of that unit (denoted by &quot;len(tx1)&quot; and &quot;len(tx2)&quot; in the figure below).</li>
<li>If there is insufficient transaction or PayForBlob transaction data to fill the share, the remaining bytes are filled with <code>0</code>.</li>
</ul>
<p>First share in a sequence:</p>
<p><img src="specs/./figures/transaction_share_start.svg" alt="figure 3: transaction share start" /></p>
<p>where reserved bytes would be <code>38</code> as a binary big endian <code>uint32</code> (<code>[0b00000000, 0b00000000, 0b00000000, 0b00100110]</code>).</p>
<p>Continuation share in a sequence:</p>
<p><img src="specs/./figures/transaction_share_continuation.svg" alt="figure 4: transaction share continuation" /></p>
<p>where reserved bytes would be <code>80</code> as a binary big endian <code>uint32</code> (<code>[0b00000000, 0b00000000, 0b00000000, 0b01010000]</code>).</p>
<h2 id="padding"><a class="header" href="#padding">Padding</a></h2>
<p>Padding shares vary based on namespace but they conform to the <a href="specs/shares.html#share-format">share format</a> described above.</p>
<ul>
<li>The first <a href="specs/./consensus.html#constants"><code>NAMESPACE_VERSION_SIZE</code></a> bytes of a share's raw data is the namespace version of that share (initially, this will be <code>0</code>).</li>
<li>The next <a href="specs/./consensus.html#constants"><code>NAMESPACE_ID_SIZE</code></a> bytes of a share's raw data is the namespace ID of that share. This varies based on the type of padding share.</li>
<li>The next <a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a> bytes are for share information.
<ul>
<li>The first 7 bits represent the <a href="specs/shares.html#share-version">share version</a> in big endian form (initially, this will be <code>0000000</code> for version <code>0</code>);</li>
<li>The last bit is a sequence start indicator. The indicator is always <code>1</code>.</li>
</ul>
</li>
<li>The next <a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> contain a big endian <code>uint32</code> of value <code>0</code>.</li>
<li>The remaining <a href="specs/./consensus.html#constants"><code>SHARE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>NAMESPACE_SIZE</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SHARE_INFO_BYTES</code></a><code>-</code><a href="specs/./consensus.html#constants"><code>SEQUENCE_BYTES</code></a> bytes are filled with <code>0</code>.</li>
</ul>
<h3 id="namespace-padding-share"><a class="header" href="#namespace-padding-share">Namespace Padding Share</a></h3>
<p>A namespace padding share uses the namespace of the blob that precedes it in the data square so that the data square can retain the property that all shares are ordered by namespace.
A namespace padding share acts as padding between blobs so that the subsequent blob begins at an index that conforms to the <a href="specs/./data_square_layout.html#blob-share-commitment-rules">blob share commitment rules</a>. Clients MAY ignore the contents of these shares because they don't contain any significant data.</p>
<h3 id="reserved-padding-share"><a class="header" href="#reserved-padding-share">Reserved Padding Share</a></h3>
<p>Reserved padding shares use the <a href="specs/./consensus.html#constants"><code>RESERVED_PADDING_NAMESPACE</code></a>. Reserved padding shares are placed after the last reserved namespace share in the data square so that the first blob can start at an index that conforms to blob share commitment rules. Clients MAY ignore the contents of these shares because they don't contain any significant data.</p>
<h3 id="tail-padding-share"><a class="header" href="#tail-padding-share">Tail Padding Share</a></h3>
<p>Tail padding shares use the <a href="specs/./consensus.html#constants"><code>TAIL_PADDING_NAMESPACE</code></a>. Tail padding shares are placed after the last blob in the data square so that the number of shares in the data square is a perfect square. Clients MAY ignore the contents of these shares because they don't contain any significant data.</p>
<h2 id="parity-share"><a class="header" href="#parity-share">Parity Share</a></h2>
<p>Parity shares use the <a href="specs/./consensus.html#constants"><code>PARITY_SHARE_NAMESPACE</code></a>. Parity shares are the output of the erasure coding step of the data square construction process. They occupy quadrants Q1, Q2, and Q3 of the extended data square and are used to reconstruct the original data square (Q0). Bytes carry no special meaning.</p>
<h2 id="share-splitting"><a class="header" href="#share-splitting">Share Splitting</a></h2>
<p>Share splitting is the process of converting a blob into a share sequence. The process is as follows:</p>
<ol>
<li>Create a new share and populate the prefix of the share with the blob's namespace and <a href="specs/shares.html#share-version">share version</a>. Set the sequence start indicator to <code>1</code>. Write the blob length as the sequence length. Write the blob's data into the share until the share is full.</li>
<li>If there is more data to write, create a new share (a.k.a continuation share) and populate the prefix of the share with the blob's namespace and <a href="specs/shares.html#share-version">share version</a>. Set the sequence start indicator to <code>0</code>. Write the remaining blob data into the share until the share is full.</li>
<li>Repeat the previous step until all blob data has been written.</li>
<li>If the last share is not full, fill the remainder of the share with <code>0</code>.</li>
</ol>
<h2 id="assumptions-and-considerations-1"><a class="header" href="#assumptions-and-considerations-1">Assumptions and Considerations</a></h2>
<ul>
<li>Shares are assumed to be byte slices of length 512. Parsing shares of a different length WILL result in an error.</li>
</ul>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>See <a href="specs/../../../pkg/shares">pkg/shares</a>.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ol>
<li><a href="specs/../../../docs/architecture/adr-012-sequence-length-encoding.html">ADR-012</a></li>
<li><a href="specs/../../../docs/architecture/adr-014-versioned-namespaces.html">ADR-014</a></li>
<li><a href="specs/../../../docs/architecture/adr-015-namespace-id-size.html">ADR-015</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="consensus-rules"><a class="header" href="#consensus-rules">Consensus Rules</a></h1>
<!-- toc -->
<h2 id="system-parameters"><a class="header" href="#system-parameters">System Parameters</a></h2>
<h3 id="units"><a class="header" href="#units">Units</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>SI</th><th>value</th><th>description</th></tr></thead><tbody>
<tr><td><code>1u</code></td><td><code>1u</code></td><td><code>10**0</code></td><td><code>1</code> unit.</td></tr>
<tr><td><code>2u</code></td><td><code>k1u</code></td><td><code>10**3</code></td><td><code>1000</code> units.</td></tr>
<tr><td><code>3u</code></td><td><code>M1u</code></td><td><code>10**6</code></td><td><code>1000000</code> units.</td></tr>
<tr><td><code>4u</code></td><td><code>G1u</code></td><td><code>10**9</code></td><td><code>1000000000</code> units.</td></tr>
</tbody></table>
</div>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>value</th><th>unit</th><th>description</th></tr></thead><tbody>
<tr><td><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></td><td><code>uint64</code></td><td></td><td><code>share</code></td><td>Maximum number of rows/columns of the original data <a href="specs/data_structures.html#share">shares</a> in <a href="specs/data_structures.html#arranging-available-data-into-shares">square layout</a>.</td></tr>
<tr><td><code>AVAILABLE_DATA_ORIGINAL_SQUARE_TARGET</code></td><td><code>uint64</code></td><td></td><td><code>share</code></td><td>Target number of rows/columns of the original data <a href="specs/data_structures.html#share">shares</a> in <a href="specs/data_structures.html#arranging-available-data-into-shares">square layout</a>.</td></tr>
<tr><td><code>BLOCK_TIME</code></td><td><code>uint64</code></td><td></td><td>second</td><td>Block time, in seconds.</td></tr>
<tr><td><code>CHAIN_ID</code></td><td><code>string</code></td><td><code>&quot;Celestia&quot;</code></td><td></td><td>Chain ID. Each chain assigns itself a (unique) ID.</td></tr>
<tr><td><code>GENESIS_COIN_COUNT</code></td><td><code>uint64</code></td><td><code>10**8</code></td><td><code>4u</code></td><td><code>(= 100000000)</code> Number of coins at genesis.</td></tr>
<tr><td><code>MAX_GRAFFITI_BYTES</code></td><td><code>uint64</code></td><td><code>32</code></td><td><code>byte</code></td><td>Maximum size of transaction graffiti, in bytes.</td></tr>
<tr><td><code>MAX_VALIDATORS</code></td><td><code>uint16</code></td><td><code>64</code></td><td></td><td>Maximum number of active validators.</td></tr>
<tr><td><code>NAMESPACE_VERSION_SIZE</code></td><td><code>int</code></td><td><code>1</code></td><td><code>byte</code></td><td>Size of namespace version in bytes.</td></tr>
<tr><td><code>NAMESPACE_ID_SIZE</code></td><td><code>int</code></td><td><code>28</code></td><td><code>byte</code></td><td>Size of namespace ID in bytes.</td></tr>
<tr><td><code>NAMESPACE_SIZE</code></td><td><code>int</code></td><td><code>29</code></td><td><code>byte</code></td><td>Size of namespace in bytes.</td></tr>
<tr><td><code>NAMESPACE_ID_MAX_RESERVED</code></td><td><code>uint64</code></td><td><code>255</code></td><td></td><td>Value of maximum reserved namespace (inclusive). 1 byte worth of IDs.</td></tr>
<tr><td><code>SEQUENCE_BYTES</code></td><td><code>uint64</code></td><td><code>4</code></td><td><code>byte</code></td><td>The number of bytes used to store the sequence length in the first share of a sequence</td></tr>
<tr><td><code>SHARE_INFO_BYTES</code></td><td><code>uint64</code></td><td><code>1</code></td><td><code>byte</code></td><td>The number of bytes used for <a href="specs/data_structures.html#share">share</a> information</td></tr>
<tr><td><code>SHARE_RESERVED_BYTES</code></td><td><code>uint64</code></td><td><code>4</code></td><td><code>byte</code></td><td>The number of bytes used to store the index of the first transaction in a transaction share. Must be able to represent any integer up to and including <code>SHARE_SIZE - 1</code>.</td></tr>
<tr><td><code>SHARE_SIZE</code></td><td><code>uint64</code></td><td><code>512</code></td><td><code>byte</code></td><td>Size of transaction and blob <a href="specs/data_structures.html#share">shares</a>, in bytes.</td></tr>
<tr><td><code>STATE_SUBTREE_RESERVED_BYTES</code></td><td><code>uint64</code></td><td><code>1</code></td><td><code>byte</code></td><td>Number of bytes reserved to identify state subtrees.</td></tr>
<tr><td><code>UNBONDING_DURATION</code></td><td><code>uint32</code></td><td></td><td><code>block</code></td><td>Duration, in blocks, for unbonding a validator or delegation.</td></tr>
<tr><td><code>VERSION_APP</code></td><td><code>uint64</code></td><td><code>1</code></td><td></td><td>Version of the Celestia application. Breaking changes (hard forks) must update this parameter.</td></tr>
<tr><td><code>VERSION_BLOCK</code></td><td><code>uint64</code></td><td><code>1</code></td><td></td><td>Version of the Celestia chain. Breaking changes (hard forks) must update this parameter.</td></tr>
</tbody></table>
</div>
<h3 id="rewards-and-penalties"><a class="header" href="#rewards-and-penalties">Rewards and Penalties</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>value</th><th>unit</th><th>description</th></tr></thead><tbody>
<tr><td><code>SECONDS_PER_YEAR</code></td><td><code>uint64</code></td><td><code>31536000</code></td><td>second</td><td>Seconds per year. Omit leap seconds.</td></tr>
<tr><td><code>TARGET_ANNUAL_ISSUANCE</code></td><td><code>uint64</code></td><td><code>2 * 10**6</code></td><td><code>4u</code></td><td><code>(= 2000000)</code> Target number of coins to issue per year.</td></tr>
</tbody></table>
</div>
<h2 id="leader-selection"><a class="header" href="#leader-selection">Leader Selection</a></h2>
<p>TODO</p>
<h2 id="fork-choice"><a class="header" href="#fork-choice">Fork Choice</a></h2>
<p>The Tendermint consensus protocol is fork-free by construction under an honest majority of stake assumption.</p>
<p>If a block has a <a href="specs/consensus.html#blocklastcommit">valid commit</a>, it is part of the canonical chain. If equivocation evidence is detected for more than 1/3 of voting power, the node must halt.</p>
<h2 id="block-validity"><a class="header" href="#block-validity">Block Validity</a></h2>
<p>The validity of a newly-seen block, <code>block</code>, is determined by two components, detailed in subsequent sections:</p>
<ol>
<li><a href="specs/consensus.html#block-structure">Block structure</a>: whether the block header is valid, and data in a block is arranged into a valid and matching data root (i.e. syntax).</li>
<li><a href="specs/consensus.html#state-transitions">State transition</a>: whether the application of transactions in the block produces a matching and valid state root (i.e. semantics).</li>
</ol>
<p>Pseudocode in this section is not in any specific language and should be interpreted as being in a neutral and sane language.</p>
<h2 id="block-structure"><a class="header" href="#block-structure">Block Structure</a></h2>
<p>Before executing <a href="specs/consensus.html#state-transitions">state transitions</a>, the structure of the <a href="specs/./data_structures.html#block">block</a> must be verified.</p>
<p>The following block fields are acquired from the network and parsed (i.e. <a href="specs/./data_structures.html#serialization">deserialized</a>). If they cannot be parsed, the block is ignored but is not explicitly considered invalid by consensus rules. Further implications of ignoring a block are found in the <a href="specs/./networking.html">networking spec</a>.</p>
<ol>
<li><a href="specs/./data_structures.html#header">block.header</a></li>
<li><a href="specs/./data_structures.html#availabledataheader">block.availableDataHeader</a></li>
<li><a href="specs/./data_structures.html#commit">block.lastCommit</a></li>
</ol>
<p>If the above fields are parsed successfully, the available data <code>block.availableData</code> is acquired in erasure-coded form as <a href="specs/./networking.html#availabledata">a list of share rows</a>, then parsed. If it cannot be parsed, the block is ignored but not explicitly invalid, as above.</p>
<h3 id="blockheader"><a class="header" href="#blockheader"><code>block.header</code></a></h3>
<p>The <a href="specs/./data_structures.html#header">block header</a> <code>block.header</code> (<code>header</code> for short) is the first thing that is downloaded from the new block, and commits to everything inside the block in some way. For previous block <code>prev</code> (if <code>prev</code> is not known, then the block is ignored), and previous block header <code>prev.header</code>, the following checks must be <code>true</code>:</p>
<p><code>availableDataOriginalSquareSize</code> is computed as described <a href="specs/./data_structures.html#header">here</a>.</p>
<ol>
<li><code>header.height</code> == <code>prev.header.height + 1</code>.</li>
<li><code>header.timestamp</code> &gt; <code>prev.header.timestamp</code>.</li>
<li><code>header.lastHeaderHash</code> == the <a href="specs/./data_structures.html#header">header hash</a> of <code>prev</code>.</li>
<li><code>header.lastCommitHash</code> == the <a href="specs/./data_structures.html#hashing">hash</a> of <code>lastCommit</code>.</li>
<li><code>header.consensusHash</code> == the value computed <a href="specs/./data_structures.html#consensus-parameters">here</a>.</li>
<li><code>header.stateCommitment</code> == the root of the state, computed <a href="specs/consensus.html#state-transitions">with the application of all state transitions in this block</a>.</li>
<li><code>availableDataOriginalSquareSize</code> &lt;= <a href="specs/consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>.</li>
<li><code>header.availableDataRoot</code> == the <a href="specs/./data_structures.html#binary-merkle-tree">Merkle root</a> of the tree with the row and column roots of <code>block.availableDataHeader</code> as leaves.</li>
<li><code>header.proposerAddress</code> == the <a href="specs/consensus.html#leader-selection">leader</a> for <code>header.height</code>.</li>
</ol>
<h3 id="blockavailabledataheader"><a class="header" href="#blockavailabledataheader"><code>block.availableDataHeader</code></a></h3>
<p>The <a href="specs/./data_structures.html#availabledataheader">available data header</a> <code>block.availableDataHeader</code> (<code>availableDataHeader</code> for short) is then processed. This commits to the available data, which is only downloaded after the <a href="specs/consensus.html#blocklastcommit">consensus commit</a> is processed. The following checks must be <code>true</code>:</p>
<ol>
<li>Length of <code>availableDataHeader.rowRoots</code> == <code>availableDataOriginalSquareSize * 2</code>.</li>
<li>Length of <code>availableDataHeader.colRoots</code> == <code>availableDataOriginalSquareSize * 2</code>.</li>
<li>The length of each element in <code>availableDataHeader.rowRoots</code> and <code>availableDataHeader.colRoots</code> must be <a href="specs/./data_structures.html#hashing"><code>32</code></a>.</li>
</ol>
<h3 id="blocklastcommit"><a class="header" href="#blocklastcommit"><code>block.lastCommit</code></a></h3>
<p>The last <a href="specs/./data_structures.html#commit">commit</a> <code>block.lastCommit</code> (<code>lastCommit</code> for short) is processed next. This is the Tendermint commit (i.e. polka of votes) <em>for the previous block</em>. For previous block <code>prev</code> and previous block header <code>prev.header</code>, the following checks must be <code>true</code>:</p>
<ol>
<li><code>lastCommit.height</code> == <code>prev.header.height</code>.</li>
<li><code>lastCommit.round</code> &gt;= <code>1</code>.</li>
<li><code>lastCommit.headerHash</code> == the <a href="specs/./data_structures.html#header">header hash</a> of <code>prev</code>.</li>
<li>Length of <code>lastCommit.signatures</code> &lt;= <a href="specs/consensus.html#constants"><code>MAX_VALIDATORS</code></a>.</li>
<li>Each of <code>lastCommit.signatures</code> must be a valid <a href="specs/./data_structures.html#commitsig">CommitSig</a></li>
<li>The sum of the votes for <code>prev</code> in <code>lastCommit</code> must be at least 2/3 (rounded up) of the voting power of <code>prev</code>'s next validator set.</li>
</ol>
<h3 id="blockavailabledata"><a class="header" href="#blockavailabledata"><code>block.availableData</code></a></h3>
<p>The block's <a href="specs/./data_structures.html#availabledata">available data</a> (analogous to transactions in contemporary blockchain designs) <code>block.availableData</code> (<code>availableData</code> for short) is finally processed. The <a href="specs/./networking.html#availabledata">list of share rows</a> is parsed into the <a href="specs/./data_structures.html#availabledata">actual data structures</a> using the reverse of <a href="specs/./data_structures.html#arranging-available-data-into-shares">the process to encode available data into shares</a>; if parsing fails here, the block is invalid.</p>
<p>Once parsed, the following checks must be <code>true</code>:</p>
<ol>
<li>The commitments of the <a href="specs/./data_structures.html#2d-reed-solomon-encoding-scheme">erasure-coded extended</a> <code>availableData</code> must match those in <code>header.availableDataHeader</code>. Implicitly, this means that both rows and columns must be ordered lexicographically by namespace since they are committed to in a <a href="specs/data_structures.html#namespace-merkle-tree">Namespace Merkle Tree</a>.</li>
<li>Length of <code>availableData.intermediateStateRootData</code> == length of <code>availableData.transactionData</code> + length of <code>availableData.payForBlobData</code> + 2. (Two additional state transitions are the <a href="specs/consensus.html#begin-block">begin</a> and <a href="specs/consensus.html#end-block">end block</a> implicit transitions.)</li>
</ol>
<h2 id="state-transitions"><a class="header" href="#state-transitions">State Transitions</a></h2>
<p>Once the basic structure of the block <a href="specs/consensus.html#block-structure">has been validated</a>, state transitions must be applied to compute the new state and state root.</p>
<p>For this section, the variable <code>state</code> represents the <a href="specs/./data_structures.html#state">state tree</a>, with <code>state.accounts[k]</code>, <code>state.inactiveValidatorSet[k]</code>, <code>state.activeValidatorSet[k]</code>, and <code>state.delegationSet[k]</code> being shorthand for the leaf in the state tree in the <a href="specs/./data_structures.html#state">accounts, inactive validator set, active validator set, and delegation set subtrees</a> with <a href="specs/./data_structures.html#state">pre-hashed key</a> <code>k</code>. E.g. <code>state.accounts[a]</code> is shorthand for <code>state[(ACCOUNTS_SUBTREE_ID &lt;&lt; 8*(32-STATE_SUBTREE_RESERVED_BYTES)) | ((-1 &gt;&gt; 8*STATE_SUBTREE_RESERVED_BYTES) &amp; hash(a))]</code>.</p>
<p>State transitions are applied in the following order:</p>
<ol>
<li><a href="specs/consensus.html#begin-block">Begin block</a>.</li>
<li><a href="specs/consensus.html#blockavailabledatatransactiondata">Transactions</a>.</li>
<li><a href="specs/consensus.html#end-block">End block</a>.</li>
</ol>
<h3 id="blockavailabledatatransactiondata"><a class="header" href="#blockavailabledatatransactiondata"><code>block.availableData.transactionData</code></a></h3>
<p>Transactions are applied to the state. Note that <em>transactions</em> mutate the state (essentially, the validator set and minimal balances), while <em>blobs</em> do not.</p>
<p><code>block.availableData.transactionData</code> is simply a list of <a href="specs/./data_structures.html#wrappedtransaction">WrappedTransaction</a>s. For each wrapped transaction in this list, <code>wrappedTransaction</code>, with index <code>i</code> (starting from <code>0</code>), the following checks must be <code>true</code>:</p>
<ol>
<li><code>wrappedTransaction.index</code> == <code>i</code>.</li>
</ol>
<p>For <code>wrappedTransaction</code>'s <a href="specs/./data_structures.html#transaction">transaction</a> <code>transaction</code>, the following checks must be <code>true</code>:</p>
<ol>
<li><code>transaction.signature</code> must be a <a href="specs/./data_structures.html#public-key-cryptography">valid signature</a> over <code>transaction.signedTransactionData</code>.</li>
</ol>
<p>Finally, each <code>wrappedTransaction</code> is processed depending on <a href="specs/./data_structures.html#signedtransactiondata">its transaction type</a>. These are specified in the next subsections, where <code>tx</code> is short for <code>transaction.signedTransactionData</code>, and <code>sender</code> is the recovered signing <a href="specs/./data_structures.html#address">address</a>. We will define a few helper functions:</p>
<pre><code class="language-py">tipCost(y, z) = y * z
totalCost(x, y, z) = x + tipCost(y, z)
</code></pre>
<p>where <code>x</code> above is the amount of coins sent by the transaction authorizer, <code>y</code> above is the tip rate set in the transaction, and <code>z</code> above is the measure of the block space used by the transaction (i.e. size in bytes).</p>
<p>Four additional helper functions are defined to manage the <a href="specs/./data_structures.html#validator">validator queue</a>:</p>
<ol>
<li><code>findFromQueue(power)</code>, which returns the address of the last validator in the <a href="specs/./data_structures.html#validator">validator queue</a> with voting power greater than or equal to <code>power</code>, or <code>0</code> if the queue is empty or no validators in the queue have at least <code>power</code> voting power.</li>
<li><code>parentFromQueue(address)</code>, which returns the address of the parent in the validator queue of the validator with address <code>address</code>, or <code>0</code> if <code>address</code> is not in the queue or is the head of the queue.</li>
<li><code>validatorQueueInsert</code>, defined as</li>
</ol>
<pre><code class="language-py">function validatorQueueInsert(validator)
    # Insert the new validator into the linked list
    parent = findFromQueue(validator.votingPower)
    if parent != 0
        if state.accounts[parent].status == AccountStatus.ValidatorBonded
            validator.next = state.activeValidatorSet[parent].next
            state.activeValidatorSet[parent].next = sender
        else
            validator.next = state.inactiveValidatorSet[parent].next
            state.inactiveValidatorSet[parent].next = sender
    else
        validator.next = state.validatorQueueHead
        state.validatorQueueHead = sender
</code></pre>
<!-- markdownlint-disable-next-line MD029 -->
<ol start="4">
<li><code>validatorQueueRemove</code>, defined as</li>
</ol>
<pre><code class="language-py">function validatorQueueRemove(validator, sender)
    # Remove existing validator from the linked list
    parent = parentFromQueue(sender)
    if parent != 0
        if state.accounts[parent].status == AccountStatus.ValidatorBonded
            state.activeValidatorSet[parent].next = validator.next
            validator.next = 0
        else
            state.inactiveValidatorSet[parent].next = validator.next
            validator.next = 0
    else
        state.validatorQueueHead = validator.next
        validator.next = 0
</code></pre>
<p>Note that light clients cannot perform a linear search through a linked list, and are instead provided logarithmic proofs (e.g. in the case of <code>parentFromQueue</code>, a proof to the parent is provided, which should have <code>address</code> as its next validator).</p>
<p>In addition, three helper functions to manage the <a href="specs/./data_structures.html#blobpaid">blob paid list</a>:</p>
<ol>
<li><code>findFromBlobPaidList(start)</code>, which returns the transaction ID of the last transaction in the <a href="specs/./data_structures.html#blobpaid">blob paid list</a> with <code>finish</code> greater than <code>start</code>, or <code>0</code> if the list is empty or no transactions in the list have at least <code>start</code> <code>finish</code>.</li>
<li><code>parentFromBlobPaidList(txid)</code>, which returns the transaction ID of the parent in the blob paid list of the transaction with ID <code>txid</code>, or <code>0</code> if <code>txid</code> is not in the list or is the head of the list.</li>
<li><code>blobPaidListInsert</code>, defined as</li>
</ol>
<pre><code class="language-py">function blobPaidListInsert(tx, txid)
    # Insert the new transaction into the linked list
    parent = findFromBlobPaidList(tx.blobStartIndex)
    state.blobsPaid[txid].start = tx.blobStartIndex
    numShares = ceil(tx.blobSize / SHARE_SIZE)
    state.blobsPaid[txid].finish = tx.blobStartIndex + numShares - 1
    if parent != 0
        state.blobsPaid[txid].next = state.blobsPaid[parent].next
        state.blobsPaid[parent].next = txid
    else
        state.blobsPaid[txid].next = state.blobPaidHead
        state.blobPaidHead = txid
</code></pre>
<p>We define a helper function to compute F1 entries:</p>
<pre><code class="language-py">function compute_new_entry(reward, power)
    if power == 0
        return 0
    return reward // power
</code></pre>
<p>After applying a transaction, the new state state root is computed.</p>
<h4 id="signedtransactiondatatransfer"><a class="header" href="#signedtransactiondatatransfer">SignedTransactionDataTransfer</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.Transfer</code></a>.</li>
<li><code>totalCost(tx.amount, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1

state.accounts[sender].balance -= totalCost(tx.amount, tx.fee.tipRate, bytesPaid)
state.accounts[tx.to].balance += tx.amount

state.activeValidatorSet.proposerBlockReward += tipCost(bytesPaid)
</code></pre>
<h4 id="signedtransactiondatamsgpayfordata"><a class="header" href="#signedtransactiondatamsgpayfordata">SignedTransactionDataMsgPayForData</a></h4>
<pre><code class="language-py">bytesPaid = len(tx) + tx.blobSize
currentStartFinish = state.blobsPaid[findFromBlobPaidList(tx.blobStartIndex)]
parentStartFinish = state.blobsPaid[parentFromBlobPaidList(findFromBlobPaidList(tx.blobStartIndex))]
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.MsgPayForData</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li>The <code>ceil(tx.blobSize / SHARE_SIZE)</code> shares starting at index <code>tx.blobStartIndex</code> must:
<ol>
<li>Have namespace <code>tx.blobNamespace</code>.</li>
</ol>
</li>
<li><code>tx.blobShareCommitment</code> == computed as described <a href="specs/./data_structures.html#signedtransactiondatamsgpayfordata">here</a>.</li>
<li><code>parentStartFinish.finish</code> &lt; <code>tx.blobStartIndex</code>.</li>
<li><code>currentStartFinish.start</code> == <code>0</code> or <code>currentStartFinish.start</code> &gt; <code>tx.blobStartIndex + ceil(tx.blobSize / SHARE_SIZE)</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(tx.amount, tx.fee.tipRate, bytesPaid)

blobPaidListInsert(tx, id(tx))

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondatacreatevalidator"><a class="header" href="#signedtransactiondatacreatevalidator">SignedTransactionDataCreateValidator</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.CreateValidator</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>tx.commissionRate.denominator &gt; 0</code>.</li>
<li><code>tx.commissionRate.numerator &lt;= tx.commissionRate.denominator</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.None</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = AccountStatus.ValidatorQueued

validator = new Validator
validator.commissionRate = tx.commissionRate
validator.delegatedCount = 0
validator.votingPower = 0
validator.pendingRewards = 0
validator.latestEntry = PeriodEntry(0)
validator.unbondingHeight = 0
validator.isSlashed = false

validatorQueueInsert(validator)

state.inactiveValidatorSet[sender] = validator

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondatabeginunbondingvalidator"><a class="header" href="#signedtransactiondatabeginunbondingvalidator">SignedTransactionDataBeginUnbondingValidator</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.BeginUnbondingValidator</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.ValidatorQueued</code> or <code>state.accounts[sender].status</code> == <code>AccountStatus.ValidatorBonded</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = ValidatorStatus.Unbonding

if state.accounts[sender].status == AccountStatus.ValidatorQueued
    validator = state.inactiveValidatorSet[sender]
else if state.accounts[sender].status == AccountStatus.ValidatorBonded
    validator = state.activeValidatorSet[sender]
    delete state.activeValidatorSet[sender]

validator.unbondingHeight = block.height + 1
validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0

validatorQueueRemove(validator, sender)

state.inactiveValidatorSet[sender] = validator

state.activeValidatorSet.activeVotingPower -= validator.votingPower

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondataunbondvalidator"><a class="header" href="#signedtransactiondataunbondvalidator">SignedTransactionDataUnbondValidator</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.UnbondValidator</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.ValidatorUnbonding</code>.</li>
<li><code>state.inactiveValidatorSet[sender].unbondingHeight + UNBONDING_DURATION</code> &lt; <code>block.height</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">validator = state.inactiveValidatorSet[sender]

state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = AccountStatus.ValidatorUnbonded

state.accounts[sender].balance += validator.commissionRewards

state.inactiveValidatorSet[sender] = validator

if validator.delegatedCount == 0
    state.accounts[sender].status = AccountStatus.None
    delete state.inactiveValidatorSet[sender]

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondatacreatedelegation"><a class="header" href="#signedtransactiondatacreatedelegation">SignedTransactionDataCreateDelegation</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.CreateDelegation</code></a>.</li>
<li><code>totalCost(tx.amount, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>state.accounts[tx.to].status</code> == <code>AccountStatus.ValidatorQueued</code> or <code>state.accounts[tx.to].status</code> == <code>AccountStatus.ValidatorBonded</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.None</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(tx.amount, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = AccountStatus.DelegationBonded

if state.accounts[tx.to].status == AccountStatus.ValidatorQueued
    validator = state.inactiveValidatorSet[tx.to]
else if state.accounts[tx.to].status == AccountStatus.ValidatorBonded
    validator = state.activeValidatorSet[tx.to]

delegation = new Delegation
delegation.status = DelegationStatus.Bonded
delegation.validator = tx.to
delegation.stakedBalance = tx.amount
delegation.beginEntry = validator.latestEntry
delegation.endEntry = PeriodEntry(0)
delegation.unbondingHeight = 0

validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0
validator.delegatedCount += 1
validator.votingPower += tx.amount

# Update the validator in the linked list by first removing then inserting
validatorQueueRemove(validator, delegation.validator)
validatorQueueInsert(validator)

state.delegationSet[sender] = delegation

if state.accounts[tx.to].status == AccountStatus.ValidatorQueued
    state.inactiveValidatorSet[tx.to] = validator
else if state.accounts[tx.to].status == AccountStatus.ValidatorBonded
    state.activeValidatorSet[tx.to] = validator
    state.activeValidatorSet.activeVotingPower += tx.amount

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondatabeginunbondingdelegation"><a class="header" href="#signedtransactiondatabeginunbondingdelegation">SignedTransactionDataBeginUnbondingDelegation</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.BeginUnbondingDelegation</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.DelegationBonded</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = AccountStatus.DelegationUnbonding

delegation = state.delegationSet[sender]

if state.accounts[delegation.validator].status == AccountStatus.ValidatorQueued ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonding ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonded
    validator = state.inactiveValidatorSet[delegation.validator]
else if state.accounts[delegation.validator].status == AccountStatus.ValidatorBonded
    validator = state.activeValidatorSet[delegation.validator]

delegation.status = DelegationStatus.Unbonding
delegation.endEntry = validator.latestEntry
delegation.unbondingHeight = block.height + 1

validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0
validator.delegatedCount -= 1
validator.votingPower -= delegation.stakedBalance

# Update the validator in the linked list by first removing then inserting
# Only do this if the validator is actually in the queue (i.e. bonded or queued)
if state.accounts[delegation.validator].status == AccountStatus.ValidatorBonded ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorQueued
    validatorQueueRemove(validator, delegation.validator)
    validatorQueueInsert(validator)

state.delegationSet[sender] = delegation

if state.accounts[delegation.validator].status == AccountStatus.ValidatorQueued ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonding ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonded
    state.inactiveValidatorSet[delegation.validator] = validator
else if state.accounts[delegation.validator].status == AccountStatus.ValidatorBonded
    state.activeValidatorSet[delegation.validator] = validator
    state.activeValidatorSet.activeVotingPower -= delegation.stakedBalance

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondataunbonddelegation"><a class="header" href="#signedtransactiondataunbonddelegation">SignedTransactionDataUnbondDelegation</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.UnbondDelegation</code></a>.</li>
<li><code>totalCost(0, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.DelegationUnbonding</code>.</li>
<li><code>state.delegationSet[sender].unbondingHeight + UNBONDING_DURATION</code> &lt; <code>block.height</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">delegation = state.accounts[sender].delegationInfo

state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)
state.accounts[sender].status = None

# Return the delegated stake
state.accounts[sender].balance += delegation.stakedBalance
# Also disperse rewards (commission has already been levied)
state.accounts[sender].balance += delegation.stakedBalance * (delegation.endEntry - delegation.beginEntry)

if state.accounts[delegation.validator].status == AccountStatus.ValidatorQueued ||
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonding
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonded
    validator = state.inactiveValidatorSet[delegation.validator]
else if state.accounts[delegation.validator].status == AccountStatus.ValidatorBonded
    validator = state.activeValidatorSet[delegation.validator]

if validator.delegatedCount == 0 &amp;&amp;
      state.accounts[delegation.validator].status == AccountStatus.ValidatorUnbonded
    state.accounts[delegation.validator].status = AccountStatus.None
    delete state.inactiveValidatorSet[delegation.validator]

delete state.accounts[sender].delegationInfo

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactiondataburn"><a class="header" href="#signedtransactiondataburn">SignedTransactionDataBurn</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.Burn</code></a>.</li>
<li><code>totalCost(tx.amount, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(tx.amount, tx.fee.tipRate, bytesPaid)

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactionredelegatecommission"><a class="header" href="#signedtransactionredelegatecommission">SignedTransactionRedelegateCommission</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.RedelegateCommission</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[tx.to].status</code> == <code>AccountStatus.DelegationBonded</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.ValidatorBonded</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)

delegation = state.delegationSet[tx.to]
validator = state.activeValidatorSet[delegation.validator]

# Force-redelegate pending rewards for delegation
pendingRewards = delegation.stakedBalance * (validator.latestEntry - delegation.beginEntry)
delegation.stakedBalance += pendingRewards
delegation.beginEntry = validator.latestEntry

validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0

# Assign pending commission rewards to delegation
commissionRewards = validator.commissionRewards
delegation.stakedBalance += commissionRewards
validator.commissionRewards = 0

# Update voting power
validator.votingPower += pendingRewards + commissionRewards
state.activeValidatorSet.activeVotingPower += pendingRewards + commissionRewards

state.delegationSet[tx.to] = delegation
state.activeValidatorSet[delegation.validator] = validator

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="signedtransactionredelegatereward"><a class="header" href="#signedtransactionredelegatereward">SignedTransactionRedelegateReward</a></h4>
<pre><code class="language-py">bytesPaid = len(tx)
</code></pre>
<p>The following checks must be <code>true</code>:</p>
<ol>
<li><code>tx.type</code> == <a href="specs/./data_structures.html#signedtransactiondata"><code>TransactionType.RedelegateReward</code></a>.</li>
<li><code>totalCost(0, tx.fee.tipRate, bytesPaid)</code> &lt;= <code>state.accounts[sender].balance</code>.</li>
<li><code>tx.nonce</code> == <code>state.accounts[sender].nonce + 1</code>.</li>
<li><code>state.accounts[sender].status</code> == <code>AccountStatus.DelegationBonded</code>.</li>
<li><code>state.accounts[state.delegationSet[sender].validator].status</code> == <code>AccountStatus.ValidatorBonded</code>.</li>
</ol>
<p>Apply the following to the state:</p>
<pre><code class="language-py">state.accounts[sender].nonce += 1
state.accounts[sender].balance -= totalCost(0, tx.fee.tipRate, bytesPaid)

delegation = state.delegationSet[sender]
validator = state.activeValidatorSet[delegation.validator]

# Redelegate pending rewards for delegation
pendingRewards = delegation.stakedBalance * (validator.latestEntry - delegation.beginEntry)
delegation.stakedBalance += pendingRewards
delegation.beginEntry = validator.latestEntry

validator.latestEntry += compute_new_entry(validator.pendingRewards, validator.votingPower)
validator.pendingRewards = 0

# Update voting power
validator.votingPower += pendingRewards
state.activeValidatorSet.activeVotingPower += pendingRewards

state.delegationSet[sender] = delegation
state.activeValidatorSet[delegation.validator] = validator

state.activeValidatorSet.proposerBlockReward += tipCost(tx.fee.tipRate, bytesPaid)
</code></pre>
<h4 id="begin-block"><a class="header" href="#begin-block">Begin Block</a></h4>
<p>At the beginning of the block, rewards are distributed to the block proposer.</p>
<p>Apply the following to the state:</p>
<pre><code class="language-py">proposer = state.activeValidatorSet[block.header.proposerAddress]

# Compute block subsidy and save to state for use in end block.
rewardFactor = (TARGET_ANNUAL_ISSUANCE * BLOCK_TIME) / (SECONDS_PER_YEAR * sqrt(GENESIS_COIN_COUNT))
blockReward = rewardFactor * sqrt(state.activeValidatorSet.activeVotingPower)
state.activeValidatorSet.proposerBlockReward = blockReward

# Save proposer's initial voting power to state for use in end block.
state.activeValidatorSet.proposerInitialVotingPower = proposer.votingPower

state.activeValidatorSet[block.header.proposerAddress] = proposer
</code></pre>
<h4 id="end-block"><a class="header" href="#end-block">End Block</a></h4>
<p>Apply the following to the state:</p>
<pre><code class="language-py">account = state.accounts[block.header.proposerAddress]

if account.status == AccountStatus.ValidatorUnbonding
      account.status == AccountStatus.ValidatorUnbonded
    proposer = state.inactiveValidatorSet[block.header.proposerAddress]
else if account.status == AccountStatus.ValidatorBonded
    proposer = state.activeValidatorSet[block.header.proposerAddress]

# Flush the outstanding pending rewards.
proposer.latestEntry += compute_new_entry(proposer.pendingRewards, proposer.votingPower)
proposer.pendingRewards = 0

blockReward = state.activeValidatorSet.proposerBlockReward
commissionReward = proposer.commissionRate.numerator * blockReward // proposer.commissionRate.denominator
proposer.commissionRewards += commissionReward
proposer.pendingRewards += blockReward - commissionReward

# Even though the voting power hasn't changed yet, we consider this a period change.
proposer.latestEntry += compute_new_entry(proposer.pendingRewards, state.activeValidatorSet.proposerInitialVotingPower)
proposer.pendingRewards = 0

if account.status == AccountStatus.ValidatorUnbonding
      account.status == AccountStatus.ValidatorUnbonded
    state.inactiveValidatorSet[block.header.proposerAddress] = proposer
else if account.status == AccountStatus.ValidatorBonded
    state.activeValidatorSet[block.header.proposerAddress] = proposer
</code></pre>
<p>At the end of a block, the top <code>MAX_VALIDATORS</code> validators by voting power with voting power <em>greater than</em> zero are or become active (bonded). For newly-bonded validators, the entire validator object is moved to the active validators subtree and their status is changed to bonded. For previously-bonded validators that are no longer in the top <code>MAX_VALIDATORS</code> validators begin unbonding.</p>
<p>Bonding validators is simply setting their status to <code>AccountStatus.ValidatorBonded</code>. The logic for validator unbonding is found <a href="specs/consensus.html#signedtransactiondatabeginunbondingvalidator">here</a>, minus transaction sender updates (nonce, balance, and fee).</p>
<p>This end block implicit state transition is a single state transition, and <a href="specs/consensus.html#blockavailabledata">only has a single intermediate state root</a> associated with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="honest-block-proposer"><a class="header" href="#honest-block-proposer">Honest Block Proposer</a></h1>
<!-- toc -->
<p>This document describes the tasks of an honest block proposer to assemble a new block. Performing these actions is not enforced by the <a href="specs/./consensus.html">consensus rules</a>, so long as a valid block is produced.</p>
<h2 id="deciding-on-a-block-size"><a class="header" href="#deciding-on-a-block-size">Deciding on a Block Size</a></h2>
<p>Before <a href="specs/./data_structures.html#arranging-available-data-into-shares">arranging available data into shares</a>, the size of the original data's square must be determined.</p>
<p>There are two restrictions on the original data's square size:</p>
<ol>
<li>It must be at most <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>.</li>
<li>It must be a power of 2.</li>
</ol>
<p>With these restrictions in mind, the block proposer performs the following actions:</p>
<ol>
<li>Collect as many transactions and blobs from the mempool as possible, such that the total number of shares is at most <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>.</li>
<li>Compute the smallest square size that is a power of 2 that can fit the number of shares.</li>
<li>Attempt to lay out the collected transactions and blobs in the current square.
<ol>
<li>If the square is too small to fit all transactions and blobs (which may happen <a href="specs/../specs/data_square_layout.html">due to needing to insert padding between blobs</a>) and the square size is smaller than <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>, double the size of the square and repeat the above step.</li>
<li>If the square is too small to fit all transactions and blobs (which may happen <a href="specs/../specs/data_square_layout.html">due to needing to insert padding between blobs</a>) and the square size is at <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX</code></a>, drop the transactions and blobs until the data fits within the square.</li>
</ol>
</li>
</ol>
<p>Note: the maximum padding shares between blobs should be at most twice the number of blob shares. Doubling the square size (i.e. quadrupling the number of shares in the square) should thus only have to happen at most once.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-validity-rules"><a class="header" href="#block-validity-rules">Block Validity Rules</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Unlike most blockchains, Celestia derives most of its functionality from
stateless commitments to data rather than stateful transitions. This means that
the protocol relies heavily on block validity rules. Notably, resource
constrained light clients must be able to detect when a subset of these validity
rules have not been followed in order to avoid making an honest majority
assumption on the consensus network. This has a significant impact on thier
design. More information on how light clients can check the invalidity of a
block can be foud in the <a href="specs/./fraud_proofs.html">Fraud Proofs</a> spec.</p>
<blockquote>
<p><strong>Note</strong> Celestia relies on CometBFT (formerly tendermint) for consensus,
meaning that it has single slot finality and is fork-free. Therefore, in order
to ensure that an invalid block is never committed to, each validator must
check that each block follows all validity rules before voting. If over two
thirds of the voting power colludes to break a validity rule, then fraud
proofs are created for light clients. After light clients verify fraud proofs,
they halt.</p>
</blockquote>
<h2 id="validity-rules"><a class="header" href="#validity-rules">Validity Rules</a></h2>
<p>Before any Celestia specific validation is performed, all CometBFT <a href="https://github.com/cometbft/cometbft/blob/v0.34.28/spec/core/data_structures.md#block">block
validation
rules</a>
must be followed.</p>
<p>Notably, this includes verifying data availability. Consensus nodes verify data
availabily by simply downloading the entire block.</p>
<blockquote>
<p><strong>Note</strong> Light clients only sample a fraction of the block. More details on
how sampling actually works can be found in the seminal <a href="https://arxiv.org/abs/1809.09044">&quot;Fraud and Data
Availability Proofs: Maximising Light Client Security and Scaling Blockchains
with Dishonest Majorities&quot;</a> and in the
<a href="https://github.com/celestiaorg/celestia-node"><code>celestia-node</code></a> repo.</p>
</blockquote>
<p>Celestia specifc validity rules can be categorized into two groups:</p>
<h3 id="transaction-validity-rules"><a class="header" href="#transaction-validity-rules">Transaction Validity Rules</a></h3>
<p>All <code>BlobTx</code> transactions must be valid according to the <a href="specs/../../../x/blob/README.html#validity-rules">BlobTx validity rules</a></p>
<p>All remaining transaction types do not have to by valid if included in a block. For a complete list of modules see <a href="specs/./state_machine_modules.html">state machine modules</a>.</p>
<h3 id="data-root-construction"><a class="header" href="#data-root-construction">Data Root Construction</a></h3>
<p>The data root must be calculated from a correctly constructed data square per the <a href="specs/./data_square_layout.html">data square layout rules</a></p>
<p><img src="specs/./figures/rs2d_extending.svg" alt="Figure 1: Erasure Encoding" width="400"/> <img
src="./figures/rs2d_quadrants.svg" alt="Figure 2: rsmt2d" width="400"/> <img src="specs/./figures/data_root.svg" alt="Figure 3: Data Root" width="400"/></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fraud-proofs"><a class="header" href="#fraud-proofs">Fraud Proofs</a></h1>
<h2 id="bad-encoding-fraud-proofs"><a class="header" href="#bad-encoding-fraud-proofs">Bad Encoding Fraud Proofs</a></h2>
<p>In order for data availability sampling to work, light clients must be convinced
that erasure encoded parity data was encoded correctly. For light clients, this
is ultimately enforced via <a href="https://github.com/celestiaorg/celestia-node/blob/v0.11.0-rc3/docs/adr/adr-006-fraud-service.md#detailed-design">bad encoding fraud proofs
(BEFPs)</a>.
Consensus nodes must verify this themselves before considering a block valid.
This is done automatically by verifying the data root of the header, since that
requires reconstructing the square from the block data, performing the erasure
encoding, calculating the data root using that representation, and then
comparing the data root found in the header.</p>
<h2 id="blob-inclusion"><a class="header" href="#blob-inclusion">Blob Inclusion</a></h2>
<p>TODO</p>
<h2 id="state-1"><a class="header" href="#state-1">State</a></h2>
<p>State fraud proofs allow light clients to avoid making an honest majority assumption for
state validity. While these are not incorporated into the protocol as of v1.0.0,
there are example implementations that can be found in
<a href="https://github.com/rollkit/rollkit">Rollkit</a>. More info in
<a href="https://github.com/rollkit/rollkit/blob/4fd97ba8b8352771f2e66454099785d06fd0c31b/docs/lazy-adr/adr-009-state-fraud-proofs.md">rollkit-ADR009</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking"><a class="header" href="#networking">Networking</a></h1>
<!-- toc -->
<h2 id="wire-format"><a class="header" href="#wire-format">Wire Format</a></h2>
<h3 id="availabledata-1"><a class="header" href="#availabledata-1">AvailableData</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>availableDataRows</code></td><td><a href="specs/networking.html#availabledatarow">AvailableDataRow</a><code>[]</code></td><td>List of rows.</td></tr>
</tbody></table>
</div>
<h3 id="availabledatarow"><a class="header" href="#availabledatarow">AvailableDataRow</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>shares</code></td><td><a href="specs/./data_structures.html#share">Share</a><code>[]</code></td><td>Shares in a row.</td></tr>
</tbody></table>
</div>
<h3 id="consensusproposal"><a class="header" href="#consensusproposal">ConsensusProposal</a></h3>
<p>Defined as <code>ConsensusProposal</code>:</p>
<pre><code class="language-protobuf">message ConsensusProposal {
  SignedMsgType type = 1;
  int32 round = 2;
  int32 pol_round = 3;
  // 32-byte hash
  // Proposed block header
  Header header = 4;
  AvailableDataHeader da_header = 5;
  // 64-byte signature
  bytes proposer_signature = 6;
}
</code></pre>
<p>When receiving a new block proposal <code>proposal</code> from the network, the following steps are performed in order. <em>Must</em> indicates that peers must be blacklisted (to prevent DoS attacks) and <em>should</em> indicates that the network blob can simply be ignored.</p>
<ol>
<li><code>proposal.type</code> must be a <code>SignedMsgType</code>.</li>
<li><code>proposal.round</code> is processed identically to Tendermint.</li>
<li><code>proposal.pol_round</code> is processed identically to Tendermint.</li>
<li><code>proposal.header</code> must be well-formed.</li>
<li><code>proposal.header.version.block</code> must be <a href="specs/./consensus.html#constants"><code>VERSION_BLOCK</code></a>.</li>
<li><code>proposal.header.version.app</code> must be <a href="specs/./consensus.html#constants"><code>VERSION_APP</code></a>.</li>
<li><code>proposal.header.height</code> should be previous known height + 1.</li>
<li><code>proposal.header.chain_id</code> must be <a href="specs/./consensus.html#constants"><code>CHAIN_ID</code></a>.</li>
<li><code>proposal.header.time</code> is processed identically to Tendermint.</li>
<li><code>proposal.header.last_header_hash</code> must be previous block's header hash.</li>
<li><code>proposal.header.last_commit_hash</code> must be the previous block's commit hash.</li>
<li><code>proposal.header.consensus_hash</code> must be the hash of <a href="specs/./data_structures.html#header">consensus parameters</a>.</li>
<li><code>proposal.header.state_commitment</code> must be the state root after applying the previous block's transactions.</li>
<li><code>proposal.header.available_data_original_shares_used</code> must be at most <a href="specs/./consensus.html#constants"><code>AVAILABLE_DATA_ORIGINAL_SQUARE_MAX ** 2</code></a>.</li>
<li><code>proposal.header.available_data_root</code> must be the <a href="specs/./data_structures.html#availabledataheader">root</a> of <code>proposal.da_header</code>.</li>
<li><code>proposal.header.proposer_address</code> must be the <a href="specs/./consensus.html#leader-selection">correct leader</a>.</li>
<li><code>proposal.da_header</code> must be well-formed.</li>
<li>The number of elements in <code>proposal.da_header.row_roots</code> and <code>proposal.da_header.row_roots</code> must be equal.</li>
<li>The number of elements in <code>proposal.da_header.row_roots</code> must be the same as computed <a href="specs/./data_structures.html#header">here</a>.</li>
<li><code>proposal.proposer_signature</code> must be a valid <a href="specs/./data_structures.html#public-key-cryptography">digital signature</a> over the header hash of <code>proposal.header</code> that recovers to <code>proposal.header.proposer_address</code>.</li>
<li>For full nodes, <code>proposal.da_header</code> must be the result of computing the roots of the shares (received separately).</li>
<li>For light nodes, <code>proposal.da_header</code> should be sampled from for availability.</li>
</ol>
<h3 id="msgwirepayfordata"><a class="header" href="#msgwirepayfordata">MsgWirePayForData</a></h3>
<p>Defined as <code>MsgWirePayForData</code>:</p>
<pre><code class="language-protobuf">message MsgWirePayForData {
  TransactionFee fee = 1;
  uint64 nonce = 2;
  // 8-byte namespace ID
  bytes message_namespace_id = 3;
  uint64 message_size = 4;
  bytes message = 5;
  repeated MessageCommitmentAndSignature message_commitment_and_signature = 6;
}
</code></pre>
<p>Accepting a <code>MsgWirePayForData</code> into the mempool requires different logic than other transactions in Celestia, since it leverages the paradigm of block proposers being able to malleate transaction data. Unlike <a href="specs/./data_structures.html#signedtransactiondatamsgpayfordata">SignedTransactionDataMsgPayForData</a> (the canonical data type that is included in blocks and committed to with a data root in the block header), each <code>MsgWirePayForData</code> (the over-the-wire representation of the same) has potentially multiple signatures.</p>
<p>Transaction senders who want to pay for a blob will create a <a href="specs/./data_structures.html#signedtransactiondatamsgpayfordata">SignedTransactionDataMsgPayForData</a> object, <code>stx</code>, filling in the <code>stx.blobShareCommitment</code> field <a href="specs/../specs/data_square_layout.html#blob-share-commitment-rules">based on the blob share commitmentrules</a>, then signing it to get a <a href="specs/./data_structures.html#transaction">transaction</a> <code>tx</code>.</p>
<p>Receiving a <code>MsgWirePayForData</code> object from the network follows the reverse process: verify using the <a href="specs/../specs/data_square_layout.html#blob-share-commitment-rules">blob share commitmentrules</a> that the signature is valid.</p>
<h2 id="invalid-erasure-coding"><a class="header" href="#invalid-erasure-coding">Invalid Erasure Coding</a></h2>
<p>If a malicious block producer incorrectly computes the 2D Reed-Solomon code for a block's data, a fraud proof for this can be presented. We assume that the light clients have the <a href="specs/./data_structures.html#availabledataheader">AvailableDataHeader</a> and the <a href="specs/./data_structures.html#header">Header</a> for each block. Hence, given a <a href="specs/networking.html#shareproof">ShareProof</a>, they can verify if the <code>rowRoot</code> or <code>colRoot</code> specified by <code>isCol</code> and <code>position</code> commits to the corresponding <a href="specs/./data_structures.html#share">Share</a>. Similarly, given the <code>height</code> of a block, they can access all elements within the <a href="specs/./data_structures.html#availabledataheader">AvailableDataHeader</a> and the <a href="specs/./data_structures.html#header">Header</a> of the block.</p>
<h3 id="shareproof"><a class="header" href="#shareproof">ShareProof</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>share</code></td><td><a href="specs/./data_structures.html#share">Share</a></td><td>The share.</td></tr>
<tr><td><code>proof</code></td><td><a href="specs/./data_structures.html#namespacemerkletreeinclusionproof">NamespaceMerkleTreeInclusionProof</a></td><td>The Merkle proof of the share in the offending row or column root.</td></tr>
<tr><td><code>isCol</code></td><td><code>bool</code></td><td>A Boolean indicating if the proof is from a row root or column root; <code>false</code> if it is a row root.</td></tr>
<tr><td><code>position</code></td><td><code>uint64</code></td><td>The index of the share in the offending row or column.</td></tr>
</tbody></table>
</div>
<h3 id="badencodingfraudproof"><a class="header" href="#badencodingfraudproof">BadEncodingFraudProof</a></h3>
<p>Defined as <code>BadEncodingFraudProof</code>:</p>
<pre><code class="language-protobuf">// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#badencodingfraudproof
message BadEncodingFraudProof {
  // height of the block with the offending row or column
  int64 height = 1;
  // the available shares in the offending row or column and their Merkle proofs
  // array of ShareProofs
  repeated ShareProof shareProofs = 2;
  // a Boolean indicating if it is an offending row or column; false if it is a row
  bool isCol = 3;
  // the index of the offending row or column in the square
  uint64 position = 4;
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>height</code></td><td><a href="specs/./data_structures.html#type-aliases">Height</a></td><td>Height of the block with the offending row or column.</td></tr>
<tr><td><code>shareProofs</code></td><td><a href="specs/networking.html#shareproof">ShareProof</a><code>[]</code></td><td>The available shares in the offending row or column.</td></tr>
<tr><td><code>isCol</code></td><td><code>bool</code></td><td>A Boolean indicating if it is an offending row or column; <code>false</code> if it is a row.</td></tr>
<tr><td><code>position</code></td><td><code>uint64</code></td><td>The index of the offending row or column in the square.</td></tr>
</tbody></table>
</div>
<h2 id="invalid-state-update"><a class="header" href="#invalid-state-update">Invalid State Update</a></h2>
<p>If a malicious block producer incorrectly computes the state, a fraud proof for this can be presented. We assume that the light clients have the <a href="specs/./data_structures.html#availabledataheader">AvailableDataHeader</a> and the <a href="specs/./data_structures.html#header">Header</a> for each block. Hence, given a <a href="specs/networking.html#shareproof">ShareProof</a>, they can verify if the <code>rowRoot</code> or <code>colRoot</code> specified by <code>isCol</code> and <code>position</code> commits to the corresponding <a href="specs/./data_structures.html#share">Share</a>. Similarly, given the <code>height</code> of a block, they can access all elements within the <a href="specs/./data_structures.html#availabledataheader">AvailableDataHeader</a> and the <a href="specs/./data_structures.html#header">Header</a> of the block.</p>
<h3 id="statefraudproof"><a class="header" href="#statefraudproof">StateFraudProof</a></h3>
<p>Defined as <code>StateFraudProof</code>:</p>
<pre><code class="language-protobuf">// https://github.com/celestiaorg/celestia-specs/blob/master/specs/networking.md#statefraudproof
message StateFraudProof {
  // height of the block with the intermediate state roots 
  // Subtracting one from height gives the height of the block with the transactions.
  int64 height = 1;
  // shares containing the transactions and their Merkle proofs
  // isCol within the ShareProof must be false.
  // array of ShareProofs
  repeated ShareProof transactionShareProofs = 2;
  // shares containing the intermediate state roots and their Merkle proofs
  // isCol within the ShareProof must be false.
  // array of ShareProofs
  repeated ShareProof isrShareProofs = 3;
  // index for connecting the WrappedIntermediateStateRoot and WrappedTransaction after shares are parsed
  uint64 index = 4;
  // state elements that were changed by the transactions
  // array of StateElements
  repeated StateElement intermediateStateElements = 5;
  // sparse Merkle tree inclusion proofs for the state elements
  // array of SparseMerkleTreeInclusionProofs
  repeated SparseMerkleTreeInclusionProof stateInclusionProofs = 6;
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td><code>height</code></td><td><a href="specs/./data_structures.html#type-aliases">Height</a></td><td>Height of the block with the intermediate state roots. Subtracting one from <code>height</code> gives the height of the block with the transactions.</td></tr>
<tr><td><code>transactionShareProofs</code></td><td><a href="specs/networking.html#shareproof">ShareProof</a><code>[]</code></td><td><code>isCol</code> of type <code>bool</code> must be <code>false</code>.</td></tr>
<tr><td><code>isrShareProofs</code></td><td><a href="specs/networking.html#shareproof">ShareProof</a><code>[]</code></td><td><code>isCol</code> of type <code>bool</code> must be <code>false</code>.</td></tr>
<tr><td><code>index</code></td><td><code>uint64</code></td><td>Index for connecting the <a href="specs/./data_structures.html#wrappedintermediatestateroot">WrappedIntermediateStateRoot</a> and <a href="specs/./data_structures.html#wrappedtransaction">WrappedTransaction</a> after shares are parsed.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="public-key-cryptography"><a class="header" href="#public-key-cryptography">Public-Key Cryptography</a></h1>
<!-- toc -->
<p>Consensus-critical data is authenticated using <a href="https://www.secg.org/sec1-v2.pdf">ECDSA</a> with the curves: <a href="https://en.bitcoin.it/wiki/Secp256k1">Secp256k1</a> or <a href="https://en.wikipedia.org/wiki/EdDSA#Ed25519">Ed25519</a>.</p>
<h2 id="secp256k1"><a class="header" href="#secp256k1">Secp256k1</a></h2>
<p>The Secp256k1 key type is used by accounts that submit transactions to be included in Celestia.</p>
<h3 id="libraries"><a class="header" href="#libraries">Libraries</a></h3>
<p>A highly-optimized library is available in C (<a href="https://github.com/bitcoin-core/secp256k1">https://github.com/bitcoin-core/secp256k1</a>), with wrappers in Go (<a href="https://pkg.go.dev/github.com/ethereum/go-ethereum/crypto/secp256k1">https://pkg.go.dev/github.com/ethereum/go-ethereum/crypto/secp256k1</a>) and Rust (<a href="https://docs.rs/crate/secp256k1">https://docs.rs/crate/secp256k1</a>).</p>
<h3 id="public-keys"><a class="header" href="#public-keys">Public-keys</a></h3>
<p>Secp256k1 public keys can be compressed to 257-bits (or 33 bytes) per the format described <a href="https://docs.cosmos.network/v0.46/basics/accounts.html#public-keys">here</a>.</p>
<h3 id="addresses"><a class="header" href="#addresses">Addresses</a></h3>
<p>Cosmos <a href="https://docs.cosmos.network/v0.46/basics/accounts.html#addresses">addresses</a> are 20 bytes in length.</p>
<h3 id="signatures"><a class="header" href="#signatures">Signatures</a></h3>
<p>Deterministic signatures (<a href="https://tools.ietf.org/rfc/rfc6979.txt">RFC-6979</a>) should be used when signing, but this is not enforced at the protocol level as it cannot be for Secp256k1 signatures.</p>
<p>Signatures are represented as the <code>r</code> and <code>s</code> (each 32 bytes) values of the signature. <code>r</code> and <code>s</code> take on their usual meaning (see: <a href="https://www.secg.org/sec1-v2.pdf">SEC 1, 4.1.3 Signing Operation</a>). Signatures are encoded with protobuf as described <a href="https://docs.cosmos.network/v0.46/core/encoding.html#transaction-encoding">here</a>.</p>
<h3 id="human-readable-encoding"><a class="header" href="#human-readable-encoding">Human Readable Encoding</a></h3>
<p>In front-ends addresses are prefixed with the <a href="https://en.bitcoin.it/wiki/Bech32">Bech32</a> prefix <code>celestia</code>. For example, a valid address is <code>celestia1kj39jkzqlr073t42am9d8pd40tgudc3e2kj9yf</code>.</p>
<h2 id="ed25519"><a class="header" href="#ed25519">Ed25519</a></h2>
<p>The Ed25519 key type is used by validators.</p>
<!-- markdownlint-disable-next-line MD024 -->
<h3 id="libraries-1"><a class="header" href="#libraries-1">Libraries</a></h3>
<ul>
<li><a href="https://pkg.go.dev/crypto/ed25519">crypto/ed25519</a></li>
<li><a href="https://pkg.go.dev/github.com/cometbft/cometbft@v0.37.0/crypto/ed25519">cometbft crypto/ed25519</a></li>
</ul>
<h3 id="public-keys-1"><a class="header" href="#public-keys-1">Public Keys</a></h3>
<p>Ed25519 public keys are 32 bytes in length. They often appear in validator configuration files (e.g. <code>genesis.json</code>) base64 encoded:</p>
<pre><code class="language-json">      &quot;pub_key&quot;: {
        &quot;type&quot;: &quot;tendermint/PubKeyEd25519&quot;,
        &quot;value&quot;: &quot;DMEMMj1+thrkUCGocbvvKzXeaAtRslvX9MWtB+smuIA=&quot;
      }
</code></pre>
<!-- markdownlint-disable-next-line MD024 -->
<h3 id="addresses-1"><a class="header" href="#addresses-1">Addresses</a></h3>
<p>Ed25519 addresses are the first 20-bytes of the SHA256 hash of the raw 32-byte public key:</p>
<pre><code class="language-go">address = SHA256(pubkey)[:20]
</code></pre>
<!-- markdownlint-disable-next-line MD024 -->
<h3 id="signatures-1"><a class="header" href="#signatures-1">Signatures</a></h3>
<p>Ed25519 signatures are 64 bytes in length.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-square-layout"><a class="header" href="#data-square-layout">Data Square Layout</a></h1>
<!-- toc -->
<h2 id="preamble"><a class="header" href="#preamble">Preamble</a></h2>
<p>Celestia uses <a href="https://arxiv.org/abs/1809.09044">a data availability scheme</a> that allows nodes to determine whether a block's data was published without downloading the whole block. The core of this scheme is arranging data in a two-dimensional matrix of <a href="specs/./shares.html">shares</a>, then applying erasure coding to each row and column. This document describes the rationale for how datatransactions, blobs, and other data<a href="specs/./data_structures.html#arranging-available-data-into-shares">is actually arranged</a>. Familiarity with the <a href="https://arxiv.org/abs/1809.09044">originally proposed data layout format</a> is assumed.</p>
<h2 id="layout-rationale"><a class="header" href="#layout-rationale">Layout Rationale</a></h2>
<p>Block data consists of:</p>
<ol>
<li>Standard cosmos-SDK transactions: (which are often represented internally as the <a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/types/tx_msg.go#L42-L50"><code>sdk.Tx</code> interface</a>) as described in <a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/docs/architecture/adr-020-protobuf-transaction-encoding.md">cosmos-sdk ADR020</a>
<ol>
<li>These transactions contain protobuf encoded <a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/types/tx_msg.go#L14-L26"><code>sdk.Msg</code></a>s, which get executed atomically (if one fails they all fail) to update the Celestia state. The complete list of modules, which define the <code>sdk.Msg</code>s that the state machine is capable of handling, can be found in the <a href="specs/../specs/state_machine_modules.html">state machine modules spec</a>. Examples include standard cosmos-sdk module messages such as <a href="https://github.com/cosmos/cosmos-sdk/blob/f71df80e93bffbf7ce5fbd519c6154a2ee9f991b/proto/cosmos/bank/v1beta1/tx.proto#L21-L32">MsgSend</a>), and celestia specific module messages such as <a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/proto/celestia/blob/v1/tx.proto#L16-L31"><code>MsgPayForBlobs</code></a></li>
</ol>
</li>
<li>Blobs: binary large objects which do not modify the Celestia state, but which are intended for a Celestia application identified with a provided namespace.</li>
</ol>
<p>We want to arrange this data into a <code>k * k</code> matrix of fixed-sized <a href="specs/../specs/shares.html">shares</a>, which will later be committed to in <a href="https://github.com/celestiaorg/nmt/blob/v0.16.0/docs/spec/nmt.md">Namespace Merkle Trees (NMTs)</a> so that individual shares in this matrix can be proven to belong to a single data root. <code>k</code> must always be a power of 2 (e.g. 1, 2, 4, 8, 16, 32, etc.) as this is optimal for the erasure coding algorithm.</p>
<p>The simplest way we can imagine arranging block data is to simply serialize it all in no particular order, split it into fixed-sized shares, then arrange those shares into the <code>k * k</code> matrix in row-major order. However, this naive scheme can be improved in a number of ways, described below.</p>
<p>First, we impose some ground rules:</p>
<ol>
<li>Data must be ordered by namespace. This makes queries into a NMT commitment of that data more efficient.</li>
<li>Since non-blob data are not naturally intended for particular namespaces, we assign <a href="specs/./consensus.html#Reservered-Namespaces">reserved namespaces</a> for them. A range of namespaces is reserved for this purpose, starting from the lowest possible namespace.</li>
<li>By construction, the above two rules mean that non-blob data always precedes blob data in the row-major matrix, even when considering single rows or columns.</li>
<li>Data with different namespaces must not be in the same share. This might cause a small amount of wasted block space, but makes the NMT easier to reason about in general since leaves are guaranteed to belong to a single namespace.</li>
</ol>
<p>Given these rules, a square may look as follows:</p>
<p><img src="specs/./figures/square_layout.svg" alt="square_layout" /></p>
<p>Padding is addressed in the <a href="specs/data_square_layout.html#padding">padding section</a>. Namespace C contains two blobs of two shares each while Namespace D contains one blob of three shares.</p>
<h3 id="ordering"><a class="header" href="#ordering">Ordering</a></h3>
<p>The order of blobs in a namespace is dictated by the priority of the PFBs that payed for the blob. A PFB with greater priority will have all blobs in that namespace strictly before a PFB with less priority. Priority is determined by the <code>gas-price</code> of the transaction (<code>fee</code>/<code>gas</code>).</p>
<h2 id="blob-share-commitment-rules"><a class="header" href="#blob-share-commitment-rules">Blob Share Commitment Rules</a></h2>
<p>Transactions can pay fees for a blob to be included in the same block as the transaction itself. It may seem natural to bundle the <code>MsgPayForBlobs</code> transaction that pays for a number of blobs with these blobs (which is the case in other blockchains with native execution, e.g. calldata in Ethereum transactions or OP_RETURN data in Bitcoin transactions), however this would mean that processes validating the state of the Celestia network would need to download all blob data. PayForBlob transactions must therefore only include a commitment to (i.e. some hash of) the blob they pay fees for. If implemented naively (e.g. with a simple hash of the blob, or a simple binary Merkle tree root of the blob), this can lead to a data availability problem, as there are no guarantees that the data behind these commitments is actually part of the block data.</p>
<p>To that end, we impose some additional rules onto <em>blobs only</em>: blobs must be placed is a way such that both the transaction sender and the block producer can be held accountablea necessary property for e.g. fee burning. Accountable in this context means that</p>
<ol>
<li>The transaction sender must pay sufficient fees for blob inclusion.</li>
<li>The block proposer cannot claim that a blob was included when it was not (which implies that a transaction and the blob it pays for must be included in the same block). In addition all blobs must be accompanied by a PayForBlob transaction.</li>
</ol>
<p>Specifically, a <code>MsgPayForBlobs</code> must include a <code>ShareCommitment</code> over the contents of each blob it is paying for. If the transaction sender knows 1) <code>k</code>, the size of the matrix, 2) the starting location of their blob in a row, and 3) the length of the blob (they know this since they are sending the blob), then they can actually compute a sequence of roots to <em>subtrees in the row NMTs</em>. Taking <em>the simple Merkle root of these subtree roots</em> provides us with the <code>ShareCommitment</code> that gets included in <code>MsgPayForBlobs</code>. Using subtree roots instead of all the leafs makes blob inclusion proofs smaller.</p>
<p><img src="specs/./figures/blob_share_commitment.svg" alt="subtree roots" /></p>
<p>Understanding 1) and 2) would usually require interaction with the block proposer. To make the possible starting locations of blobs sufficiently predictable and to make <code>ShareCommitment</code> independent of <code>k</code>, we impose an additional rule. The blob must start at a multiple of the <code>SubtreeWidth</code>.</p>
<p>The <code>SubtreeWidth</code> is calculated as the length of the blob in shares, divided by the <a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/pkg/appconsts/v1/app_consts.go#L6"><code>SubtreeRootThreshold</code></a> and rounded up to the nearest power of 2 (<a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/pkg/shares/non_interactive_defaults.go#L94-L116">implementation here</a>). If the output is greater than the minimum square size that the blob can fit in (i.e. a blob of 15 shares has a minimum square size of 4) then we take that minimum value. This <code>SubtreeWidth</code> is used as the width of the first mountain in the <a href="https://docs.grin.mw/wiki/chain-state/merkle-mountain-range/">Merkle Mountain Range</a> that would all together represent the <code>ShareCommitment</code> over the blob.</p>
<p><img src="specs/./figures/subtree_width.svg" alt="subtree root width" /></p>
<p>The <code>SubtreeRootThreshold</code> is an arbitrary versioned protocol constant that aims to put a soft limit on the number of subtree roots included in a blob inclusion proof, as described in <a href="specs/../../../docs/architecture/adr-013-non-interactive-default-rules-for-zero-padding.html">ADR013</a>. A higher <code>SubtreeRootThreshold</code> means less padding and more tightly packed squares but also means greater blob inclusion proof sizes.
With the above constraint, we can compute subtree roots deterministically. For example, a blob of 172 shares and <code>SubtreeRootThreshold</code> (SRT) = 64, must start on a share index that is a multiple of 4 because 172/64 = 3. 3 rounded up to the nearest power of 2 is 4. In this case, there will be a maximum of 3 shares of padding between blobs (more on padding below). The maximum subtree width in shares for the first mountain in the Merkle range will be 4 (The actual mountain range would be 43 subtree roots of 4 shares each). The <code>ShareCommitment</code> is then the Merkle tree over the peaks of the mountain range.</p>
<h2 id="padding-1"><a class="header" href="#padding-1">Padding</a></h2>
<p>Given these rules whereby blobs in their share format can't be directly appended one after the other, we use padding shares to fill the gaps. These are shares with a particular format (see <a href="specs/./shares.html#padding">padding</a>). Padding always comes after all the blobs in the namespace. The padding at the end of the reserved namespace and at the end of the square are special in that they belong to unique namespaces. All other padding shares use the namespace of the blob before it in the data square.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-machine-modules"><a class="header" href="#state-machine-modules">State Machine Modules</a></h1>
<p>Celestia app is built using the cosmos-sdk, and follows standard cosmos-sdk module structure.</p>
<h2 id="celestia-app-specific-modules"><a class="header" href="#celestia-app-specific-modules"><code>celestia-app</code> Specific Modules</a></h2>
<ul>
<li><a href="specs/../../../x/blob/README.html">blob</a></li>
<li><a href="specs/../../../x/qgb/README.html">qgb</a></li>
<li><a href="specs/../../../x/mint/README.html">mint</a></li>
<li><a href="specs/../../../x/paramfilter/README.html">paramfilter</a></li>
<li><a href="specs/../../../x/upgrade/README.html">upgrade</a></li>
<li><a href="specs/../../../x/tokenfilter/README.html">tokenfilter</a></li>
</ul>
<h2 id="standard-cosmos-sdk-modules"><a class="header" href="#standard-cosmos-sdk-modules">Standard <code>cosmos-sdk</code> Modules</a></h2>
<ul>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/auth/spec/README.md">auth</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/authz/spec/README.md">authz</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/bank/spec/README.md">bank</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/capability/spec/README.md">capability</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/crisis/spec/README.md">crisis</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/distribution/spec/README.md">distribution</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/evidence/spec/README.md">evidence</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/feegrant/spec/README.md">feegrant</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/tree/v1.14.0-sdk-v0.46.11/x/genutil">genutil</a> (no spec)</li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/gov/spec/README.md">gov</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/params/spec/README.md">params</a></li>
<li><a href="https://github.com/cosmos/ibc/blob/f990a7f96eb7753c2fabbd49ed50b64d3a807629/README.md">ibc</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/slashing/spec/README.md">slashing</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.14.0-sdk-v0.46.11/x/staking/spec/README.md">staking</a></li>
<li><a href="https://github.com/cosmos/ibc/blob/f990a7f96eb7753c2fabbd49ed50b64d3a807629/spec/app/ics-020-fungible-token-transfer/README.md">transfer</a></li>
<li><a href="https://github.com/celestiaorg/cosmos-sdk/tree/v1.14.0-sdk-v0.46.11/x/auth/vesting">vesting</a> (no spec)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xblob"><a class="header" href="#xblob"><code>x/blob</code></a></h1>
<h2 id="abstract-2"><a class="header" href="#abstract-2">Abstract</a></h2>
<p>The <code>x/blob</code> module enables users to pay for arbitrary data to be published to
the Celestia blockchain. Users create a single <code>BlobTx</code> that is composed of:</p>
<ol>
<li>Multiple <code>Blob</code>s (Binary Large OBjects): the data they wish to publish. A
single <code>Blob</code> is composed of:
<ol>
<li><code>NamespaceId  []byte</code>: the namespace this blob should be published to.</li>
<li><code>Data         []byte</code>: the data to be published.</li>
<li><code>ShareVersion uint32</code>: the version of the share format used to encode
this blob into a share.</li>
</ol>
</li>
<li>A single <a href="https://github.com/celestiaorg/cosmos-sdk/blob/v1.15.0-sdk-v0.46.13/docs/architecture/adr-020-protobuf-transaction-encoding.md"><code>sdk.Tx</code></a> which encapsulates a <code>MsgPayForBlobs</code> message that is composed of:
<ol>
<li><code>Signer string</code>: the transaction signer</li>
<li><code>NamespaceIds []byte</code>: the namespaces they wish to publish each blob to.
The namespaces here must match the namespaces in the <code>Blob</code>s.</li>
<li><code>ShareCommitments [][]byte</code>: a share commitment that is the root of a Merkle
tree where the leaves are share commitments to each blob associated with
this <code>BlobTx</code>.</li>
</ol>
</li>
</ol>
<p>After the <code>BlobTx</code> is submitted to the network, a block producer separates the
transaction i.e., <code>sdk.Tx</code> from the blob. Both components get included in the
data square in different namespaces: the <code>sdk.Tx</code> of the original <code>BlobTx</code>
together with some metadata about the separated blobs get included in the
PayForBlobNamespace (one of the <a href="../../x/blob/../../specs/src/specs/namespace.html#reserved-namespaces">reserved
namespaces</a>) and the
associated blob gets included in the namespace the user specified in the
original <code>BlobTx</code>. Further reading: <a href="../../x/blob/../../specs/src/specs/data_square_layout.html">Data Square
Layout</a></p>
<p>After a block has been created, the user can verify that their data was included
in a block via a blob inclusion proof. A blob inclusion proof uses the
<code>ShareCommitment</code> in the original <code>sdk.Tx</code> transaction and subtree roots of the
block's data square to prove to the user that the shares that compose their
original data do in fact exist in a particular block.</p>
<blockquote>
<p>TODO: link to blob inclusion (and fraud) proof</p>
</blockquote>
<h2 id="state-2"><a class="header" href="#state-2">State</a></h2>
<p>The blob module doesn't maintain it's own state outside of two params. Meaning
that the blob module only uses the params and auth module stores.</p>
<h3 id="params"><a class="header" href="#params">Params</a></h3>
<pre><code class="language-proto">// Params defines the parameters for the module.
message Params {
  option (gogoproto.goproto_stringer) = false;
  uint32 gas_per_blob_byte = 1
      [ (gogoproto.moretags) = &quot;yaml:\&quot;gas_per_blob_byte\&quot;&quot; ];
  uint64 gov_max_square_size = 2
      [ (gogoproto.moretags) = &quot;yaml:\&quot;gov_max_square_size\&quot;&quot; ];
}
</code></pre>
<h4 id="gasperblobbyte"><a class="header" href="#gasperblobbyte"><code>GasPerBlobByte</code></a></h4>
<p><code>GasPerBlobByte</code> is the amount of gas that is consumed per byte of blob data
when a <code>MsgPayForBlobs</code> is processed. Currently, the default value is 8. This
value is set below that of normal transaction gas consumption, which is 10.</p>
<h4 id="govmaxsquaresize"><a class="header" href="#govmaxsquaresize"><code>GovMaxSquareSize</code></a></h4>
<p><code>GovMaxSquareSize</code> is the maximum size of a data square that is considered valid
by the validator set. This value is superseded by the <code>MaxSquareSize</code>, which is
hardcoded and cannot change without hardforking the chain. See
<a href="../../x/blob/../../docs/architecture/adr-021-restricted-block-size.html">ADR021</a> for more
details.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<ul>
<li><a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/proto/celestia/blob/v1/tx.proto#L16-L31"><code>MsgPayForBlobs</code></a>
pays for a set of blobs to be included in the block. Blob transactions that contain
this <code>sdk.Msg</code> are also referred to as &quot;PFBs&quot;.</li>
</ul>
<pre><code class="language-proto">message MsgPayForBlobs {
  string signer = 1;
  repeated bytes namespaces = 2;
  repeated uint32 blob_sizes = 3;
  repeated bytes share_commitments = 4;
  repeated uint32 share_versions = 8;
}
</code></pre>
<p><code>MsgPayForBlobs</code> pays for the inclusion of blobs in the block and consists of the
following fields:</p>
<ul>
<li>signer: bech32 encoded signer address</li>
<li>namespace: namespace is a byte slice of length 29 where the first byte is the
namespaceVersion and the subsequent 28 bytes are the namespaceId.</li>
<li>blob_sizes: sizes of each blob in bytes.</li>
<li>share_commitments is a list of share commitments (one per blob).</li>
<li>share_versions are the versions of the share format that the blobs associated
with this message should use when included in a block. The share_versions
specified must match the share_versions used to generate the share_commitment
in this message. See
<a href="../../x/blob/../../docs/architecture/adr-007-universal-share-prefix.html">ADR007</a> for more
details on how this effects the share encoding and when it is updated.</li>
</ul>
<p>Note that while the shares version in each protobuf encoded PFB are uint32s, the
internal represantation of shares versions is always uint8s. This is because
protobuf doesn't support uint8s.</p>
<h3 id="generating-the-sharecommitment"><a class="header" href="#generating-the-sharecommitment">Generating the <code>ShareCommitment</code></a></h3>
<p>The share commitment is the commitment to share encoded blobs. It can be used
for cheap inclusion checks for some data by light clients. More information and
rational can be found in the <a href="../../x/blob/../../specs/src/specs/data_square_layout.html">data square layout
specs</a>.</p>
<ol>
<li>Split the blob into shares of size <a href="../../x/blob/../../specs/src/specs/data_structures.html#consensus-parameters"><code>shareSize</code></a></li>
<li>Determine the
<a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/pkg/shares/non_interactive_defaults.go#L94-L116"><code>SubtreeWidth</code></a>
by dividing the length in shares by the <code>SubtreeRootThreshold</code>.</li>
<li>Generate each subtree root by diving the blob shares into <code>SubtreeWidth</code>
sized sets, then take the binary <a href="https://github.com/celestiaorg/nmt/blob/v0.16.0/docs/spec/nmt.md">namespaced merkle tree
(NMT)</a> root
of each set of shares.</li>
<li>Calculate the final share commitment by taking the merkle root (note: not an
NMT, just a normal binary merkle root) of the subtree roots from the previous
step.</li>
</ol>
<p>See
<a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/x/blob/types/payforblob.go#L169-L236"><code>CreateCommitment</code></a>
for an implementation. See <a href="../../x/blob/../../specs/src/specs/data_square_layout.html">data square
layout</a> and
<a href="../../x/blob/../../docs/architecture/adr-013-non-interactive-default-rules-for-zero-padding.html">ADR013</a>
for details on the rational of the square layout.</p>
<h2 id="validity-rules-1"><a class="header" href="#validity-rules-1">Validity Rules</a></h2>
<p>In order for a proposal block to be considered valid, each <code>BlobTx</code>, and thus
each PFB, to be included in a block must follow a set of validity rules.</p>
<ol>
<li>Signatures: All blob transactions must have valid signatures. This is
state-dependent because correct signatures require using the correct sequence
number(aka nonce).</li>
<li>Single SDK.Msg: There must be only a single sdk.Msg encoded in the <code>sdk.Tx</code>
field of the blob transaction <code>BlobTx</code>.</li>
<li>Namespace Validity: The namespace of each blob in a blob transaction <code>BlobTx</code>
must be valid. This validity is determined by the following sub-rules:
<ol>
<li>The namepsace of each blob must match the respective (same index)
namespace in the <code>MsgPayForBlobs</code> <code>sdk.Msg</code> field <code>namespaces</code>.</li>
<li>The namespace is not lexicographically less than the <a href="../../x/blob/../../specs/src/specs/consensus.html#constants">MAX_RESERVED_NAMESPACE</a> range.</li>
<li>The namespace is not the
<a href="../../x/blob/../../specs/src/specs/consensus.html#constants">TAIL_PADDING_NAMESPACE</a>
or <a href="../../x/blob/../../specs/src/specs/consensus.html#constants">RESERVED_PADDING_NAMESPACE</a>.</li>
</ol>
</li>
<li>Blob Size: No blob can have a size of 0.</li>
<li>Blob Count: There must be one or more blobs included in the transaction.</li>
<li>Share Commitment Validity: Each share commitment must be valid.
<ol>
<li>The size of each of the share commitments must be equal to the digest of
the hash function used (sha256 so 32 bytes).</li>
<li>The share commitment must be calculated using the steps specified above
in <a href="../../x/blob/./README.html#generating-the-sharecommitment">Generating the Share
Commitment</a></li>
</ol>
</li>
<li>Share Versions: The versions of the shares must be supported.</li>
<li>Signer Address: The signer address must be a valid Celestia address.</li>
<li>Proper Encoding: The blob transactions must be properly encoded.</li>
<li>Size Consistency: The sizes included in the PFB field <code>blob_sizes</code>, and each
must match the actual size of the respective (same index) blob in bytes.</li>
</ol>
<h2 id="indexwrappedtx"><a class="header" href="#indexwrappedtx"><code>IndexWrappedTx</code></a></h2>
<p>When a block producer is preparing a block, they must perform an extra step for
<code>BlobTx</code>s so that end-users can find the blob shares relevant to their submitted
<code>BlobTx</code>. In particular, block proposers wrap the <code>BlobTx</code> in the PFB namespace
with the index of the first share of the blob in the data square. See <a href="../../x/blob/../../specs/src/specs/data_square_layout.html#blob-share-commitment-rules">Blob
share commitment
rules</a>
for more details.</p>
<p>Since <code>BlobTx</code>s can contain multiple blobs, the <code>sdk.Tx</code> portion of the <code>BlobTx</code>
is wrapped with one share index per blob in the transaction. The index wrapped
transaction is called an
<a href="https://github.com/celestiaorg/celestia-core/blob/2d2a65f59eabf1993804168414b86d758f30c383/proto/tendermint/types/types.proto#L192-L198">IndexWrapper</a>
and this is the struct that gets marshalled and written to the
PayForBlobNamespace.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>The blob module emits the following events:</p>
<h3 id="blob-events"><a class="header" href="#blob-events">Blob Events</a></h3>
<h4 id="eventpayforblob"><a class="header" href="#eventpayforblob"><code>EventPayForBlob</code></a></h4>
<div class="table-wrapper"><table><thead><tr><th>Attribute Key</th><th>Attribute Value</th></tr></thead><tbody>
<tr><td>signer</td><td>{bech32 encoded signer address}</td></tr>
<tr><td>blob_sizes</td><td>{sizes of blobs in bytes}</td></tr>
<tr><td>namespace_ids</td><td>{namespaces the blobs should be published to}</td></tr>
</tbody></table>
</div>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Type</th><th>Default</th></tr></thead><tbody>
<tr><td>GasPerBlobByte</td><td>uint32</td><td>8</td></tr>
</tbody></table>
</div>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-shell">celestia-app tx blob PayForBlobs &lt;hex encoded namespace&gt; &lt;hex encoded data&gt; [flags]
</code></pre>
<p>For submitting PFB transaction via a light client's rpc, see <a href="https://docs.celestia.org/developers/rpc-tutorial/#submitpayforblob-arguments">celestia-node's
documention</a>.</p>
<p>The steps in the
<a href="https://github.com/celestiaorg/celestia-app/blob/v1.0.0-rc2/x/blob/payforblob.go#L15-L54"><code>SubmitPayForBlobs</code></a>
function can be reverse engineered to submit blobs programmatically.</p>
<!-- markdownlint-enable MD010 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="xqgb"><a class="header" href="#xqgb"><code>x/qgb</code></a></h1>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<p>This module contains the <a href="https://blog.celestia.org/celestiums/">Quantum Gravity Bridge</a> (QGB) state machine implementation.</p>
<p>The QGB state machine is responsible for creating attestations which are signed by <a href="https://github.com/celestiaorg/orchestrator-relayer/blob/main/docs/orchestrator.md">orchestrators</a>, and submitted to EVM chains by <a href="https://github.com/celestiaorg/orchestrator-relayer/blob/main/docs/relayer.md">relayers</a>.</p>
<h3 id="attestations-types"><a class="header" href="#attestations-types">Attestations types</a></h3>
<p><a href="https://github.com/celestiaorg/celestia-app/blob/main/x/qgb/types/attestation.go#L10-L18">Attestations</a> are requests for signatures generated by the state machine during the <code>EndBlock</code> phase. They facilitate alignment between orchestrators and relayers on which data to sign, and when to relay it.</p>
<p>There are two types of attestations, <a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/proto/celestia/qgb/v1/types.proto#L18-L33">valsets</a> and <a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/proto/celestia/qgb/v1/types.proto#L35-L55">data commitments</a>.</p>
<h3 id="valsets"><a class="header" href="#valsets">Valsets</a></h3>
<p>A valset is an attestation type representing a validator set change. It allows for the validator set to change over heights which in turn defines which orchestrator should sign the attestations.</p>
<p>When an orchestrator sees a newly generated valset published by the Celestia state machine, it queries the previous valset and checks whether it's part of its validator set. Then, the orchestrator signs the new valset and submits that signature to the <a href="https://github.com/celestiaorg/orchestrator-relayer/pull/66">QGB P2P network</a>. Otherwise, it ignores it and waits for new attestations.</p>
<p>A valset is comprised of the following fields:</p>
<pre><code class="language-protobuf">// Valset is the EVM Bridge Multsig Set, each qgb validator also
// maintains an ETH key to sign messages, these are used to check signatures on
// ETH because of the significant gas savings
message Valset {
  option (cosmos_proto.implements_interface) = &quot;AttestationRequestI&quot;;
  // Universal nonce defined under:
  // https://github.com/celestiaorg/celestia-app/pull/464
  uint64 nonce = 1;
  // List of BridgeValidator containing the current validator set.
  repeated BridgeValidator members = 2 [ (gogoproto.nullable) = false ];
  // Current chain height
  uint64 height = 3;
  // Block time where this valset was created
  google.protobuf.Timestamp time = 4
      [ (gogoproto.nullable) = false, (gogoproto.stdtime) = true ];
}
</code></pre>
<p>With <code>BridgeValidator</code> representing a validator EVM address and its power:</p>
<pre><code class="language-protobuf">// BridgeValidator represents a validator's ETH address and its power
message BridgeValidator {
  // Voting power of the validator.
  uint64 power = 1;
  // EVM address that will be used by the validator to sign messages.
  string evm_address = 2;
}
</code></pre>
<ol>
<li><code>nonce</code>: is the universal nonce of the attestation. It is used to prevent front running attacks in the QGB smart contract. More details can be found in <a href="https://github.com/celestiaorg/celestia-app/blob/main/docs/architecture/adr-004-qgb-relayer-security.md">ADR-004</a>.</li>
<li><code>members</code>: contains the current validator set.</li>
<li><code>height</code>: is the height at which the valset was created.</li>
<li><code>time</code>: is the timestamp of the height at which the valset was created.</li>
</ol>
<h4 id="validator-power-normalization"><a class="header" href="#validator-power-normalization">Validator power normalization</a></h4>
<p>The <a href="https://github.com/celestiaorg/celestia-app/blob/6243f26fc419c32940d5dc4eb60b0e0aaf08eaa7/proto/celestia/qgb/v1/types.proto#L12-L13">QGB bridge power</a> is obtained by <a href="https://github.com/celestiaorg/celestia-app/blob/6243f26fc419c32940d5dc4eb60b0e0aaf08eaa7/x/qgb/keeper/keeper_valset.go#L125-L150">normalizing</a> the validators' voting power using the <a href="https://en.wikipedia.org/wiki/Feature_scaling">min-max normalization</a> formula. This formula takes into account the ratio of each validator's voting power to the total voting power in the block and scales it to a value between <code>0</code> and <code>2^32</code>.</p>
<p>By normalizing the voting power, we can significantly reduce the frequency of generating new validator set updates. For example, if there is a small increase in the total on-chain voting power due to inflation, there is no need to create a new validator set. This is because the relative proportions of the validators remain the same, and the normalized QGB power doesn't show any significant difference.</p>
<p>To ensure that the normalization process doesn't encounter overflow errors, the function normalizeValidatorPower uses <a href="https://github.com/celestiaorg/celestia-app/blob/6243f26fc419c32940d5dc4eb60b0e0aaf08eaa7/x/qgb/keeper/keeper_valset.go#LL142C1-L142C1"><code>BigInt</code></a> operations. It scales the raw power value with respect to the total validator power, making sure the result falls within the range of 0 to <code>2^32</code>.</p>
<p>This mechanism allows to increase/decrease the frequency at which validator set updates get created via increasing/decreasing the value of the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L15-L18"><code>SignificantPowerDifferenceThreshold</code></a> constant (more details on it below).</p>
<h4 id="power-diff"><a class="header" href="#power-diff">Power diff</a></h4>
<p><a href="https://github.com/celestiaorg/celestia-app/blob/6243f26fc419c32940d5dc4eb60b0e0aaf08eaa7/x/qgb/types/validator.go#L100-L141"><code>PowerDiff(...)</code></a> is a function that calculates the difference in power between two sets of bridge validators. It's important to note that the power being compared is not the regular voting power in the Celestia consensus network, but a specific type called QGB bridge power (explained above).</p>
<h3 id="data-commitments"><a class="header" href="#data-commitments">Data commitments</a></h3>
<p>A data commitment is an attestation type representing a request to commit over a set of blocks. It provides an end exclusive range of blocks for orchestrators to sign over and propagate in the QGB P2P network. The range is defined by the param <a href="https://github.com/celestiaorg/celestia-app/blob/fc83b04c3a5638ac8d415770e38a4046b84fa128/x/qgb/keeper/keeper_data_commitment.go#L44-L50"><code>DataCommitmentWindow</code></a>, more on this below.</p>
<p>When an orchestrator sees a newly generated data commitment, it queries the previous valset and checks whether it's part of its validator set. Then, the orchestrator signs the new data commitment and submits that signature to the <a href="https://github.com/celestiaorg/orchestrator-relayer/pull/66">QGB P2P network</a>. Otherwise, it ignores it and waits for new attestations.</p>
<p>A data commitment is comprised of the following fields:</p>
<pre><code class="language-protobuf">// DataCommitment is the data commitment request message that will be signed
// using orchestrators.
// It does not contain a `commitment` field as this message will be created
// inside the state machine and it doesn't make sense to ask tendermint for the
// commitment there.
// The range defined by begin_block and end_block is end exclusive.
message DataCommitment {
  option (cosmos_proto.implements_interface) = &quot;AttestationRequestI&quot;;
  // Universal nonce defined under:
  // https://github.com/celestiaorg/celestia-app/pull/464
  uint64 nonce = 1;
  // First block defining the ordered set of blocks used to create the
  // commitment.
  uint64 begin_block = 2;
  // End exclusive last block defining the ordered set of blocks used to create
  // the commitment.
  uint64 end_block = 3;
  // Block time where this data commitment was created
  google.protobuf.Timestamp time = 4
      [ (gogoproto.nullable) = false, (gogoproto.stdtime) = true ];
}
</code></pre>
<ol>
<li><code>nonce</code>: is the universal nonce of the attestation. It is used to prevent front running attacks in the QGB smart contract. More details can be found in <a href="https://github.com/celestiaorg/celestia-app/blob/main/docs/architecture/adr-004-qgb-relayer-security.md">ADR-004</a>.</li>
<li><code>begin_block</code>: the data commitment range first block.</li>
<li><code>end_block</code>: the data commitment range last block. The range is end exclusive. Thus, the commitment will be over the set of blocks defined by <code>[begin_block, end_block)</code>.</li>
<li><code>time</code>: is the timestamp of the height at which the data commitment was created.</li>
</ol>
<p>A commitment, aka <a href="https://github.com/celestiaorg/quantum-gravity-bridge/blob/03f0ab6f6eceba7a7c74a46b2c2a1fd1e390010c/src/QuantumGravityBridge.sol#L165-L180"><code>DataRootTupleRoot</code></a>, is an RFC-6962 <a href="https://github.com/celestiaorg/celestia-core/blob/d280f37a8376ed54ae03b10896fa25a4cbbc6d5b/rpc/core/blocks.go#L344-L361">merkle tree commitment</a> over the set of <a href="https://github.com/celestiaorg/quantum-gravity-bridge/blob/03f0ab6f6eceba7a7c74a46b2c2a1fd1e390010c/src/DataRootTuple.sol#L4-L17"><code>DataRootTuples</code></a> defined by a data commitment range.</p>
<p>A data root tuple contains the following fields:</p>
<pre><code class="language-solidity">/// @notice A tuple of data root with metadata. Each data root is associated
///  with a Celestia block height.
/// @dev `availableDataRoot` in
///  https://github.com/celestiaorg/celestia-specs/blob/master/src/specs/data_structures.md#header
struct DataRootTuple {
    // Celestia block height the data root was included in.
    // Genesis block is height = 0.
    // First queryable block is height = 1.
    uint256 height;
    // Data root.
    bytes32 dataRoot;
    // Celestia block original square size.
    uint256 squareSize;
}
</code></pre>
<ol>
<li><code>height</code>: the height of the block.</li>
<li><code>dataRoot</code>: the data root, aka data hash, of the block.</li>
<li><code>squareSize</code>: the <a href="https://celestiaorg.github.io/celestia-app/specs/data_structures.html#arranging-available-data-into-shares">square</a> size of the block.</li>
</ol>
<p>These commitments are queried by orchestrators from <a href="https://github.com/celestiaorg/celestia-core/blob/d280f37a8376ed54ae03b10896fa25a4cbbc6d5b/rpc/core/blocks.go#L178-L195">Celestia-core</a>, signed, then submitted to the QGB P2P network as described <a href="https://github.com/celestiaorg/orchestrator-relayer/blob/35b5df94c1602eb5e93a32d1bc6e5c8a4b5861e5/orchestrator/orchestrator.go#L331-L357">here</a>.</p>
<h2 id="state-3"><a class="header" href="#state-3">State</a></h2>
<h3 id="attestations"><a class="header" href="#attestations">Attestations</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Key</th></tr></thead><tbody>
<tr><td>Valset</td><td><a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/types/keys.go#L40-L45"><code>[AttestationRequestKey][nonce]</code></a></td></tr>
<tr><td>Data Commitments</td><td><a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/types/keys.go#L40-L45"><code>[AttestationRequestKey][nonce]</code></a></td></tr>
</tbody></table>
</div>
<p>Both types of attestations are set using the <a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/keeper/keeper_attestation.go#L10-L24"><code>SetAttestationRequest(...)</code></a> method and retrieved using the <a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/keeper/keeper_attestation.go#L112-L126"><code>GetAttestationByNonce(...)</code></a> method.</p>
<h3 id="latest-attestation-nonce"><a class="header" href="#latest-attestation-nonce">Latest attestation nonce</a></h3>
<p>The latest attestation nonce represents the most recently generated nonce in the QGB state machine store. It is <a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/genesis.go#L12">initialized to 0</a> in genesis, and gets incremented at block 1.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Key</th></tr></thead><tbody>
<tr><td>LatestAttestationNonce</td><td><a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/types/keys.go#L32-L33"><code>[LatestAttestationNonce]</code></a></td></tr>
</tbody></table>
</div>
<p>The latest attestation nonce can be set to the QGB state machine store using the <a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/keeper/keeper_attestation.go#L44-L57"><code>SetLatestAttestationNonce(...)</code></a> method and retrieved using the <a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/keeper/keeper_attestation.go#L67-L79"><code>GetLatestAttestationNonce(...)</code></a>.</p>
<p>To check if the latest attestation nonce is defined in store, use the <a href="https://github.com/celestiaorg/celestia-app/blob/376a1d4c0f321f12ba78279d2bd34fc6cb5e6dc2/x/qgb/keeper/keeper_attestation.go#L59-L65"><code>CheckLatestAttestationNonce(...)</code></a> method.</p>
<h3 id="latest-unbonding-height"><a class="header" href="#latest-unbonding-height">Latest unbonding height</a></h3>
<p>The latest unbonding height indicates the most recent height at which some validator started unbdonding. It is not initialized in genesis, and the keeper getter
<a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/keeper/keeper_valset.go#L66-L77"><code>GetLatestUnBondingBlockHeight(...)</code></a> returns <strong>0</strong> if the value is still not defined.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Key</th></tr></thead><tbody>
<tr><td>LatestUnBondingBlockHeight</td><td><a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/types/keys.go#L28-L30"><code>[LatestUnBondingBlockHeight]</code></a></td></tr>
</tbody></table>
</div>
<p>The latest unbonding height can be set to the QGB state machine store using the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/keeper/keeper_valset.go#L58-L64"><code>SetLatestUnBondingBlockHeight(...)</code></a> method, and it is called in a <code>hook</code> when a validator starts unbonding. More details on hooks are below.</p>
<h3 id="earliest-attestation-nonce"><a class="header" href="#earliest-attestation-nonce">Earliest attestation nonce</a></h3>
<p>The earliest attestation nonce corresponds to the nonce of the earliest generated attestation in the QGB state machine store. It is <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/genesis.go#L13-L17">initialized to 1</a> in genesis, and gets incremented updated when <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L184-L185">pruning</a>.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Key</th></tr></thead><tbody>
<tr><td>EarliestAvailableAttestationNonce</td><td><a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/types/keys.go#L35-L37"><code>[EarliestAvailableAttestationNonce]</code></a></td></tr>
</tbody></table>
</div>
<p>The earliest attestation nonce can be set to the QGB state machine store using the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/keeper/keeper_attestation.go#L104-L110"><code>SetEarliestAvailableAttestationNonce(...)</code></a> method, and retrieved using the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/keeper/keeper_attestation.go#L89-L102"><code>GetEarliestAvailableAttestationNonce(...)</code></a>.</p>
<p>To check if the earliest attestation nonce is defined in store, use the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/keeper/keeper_attestation.go#L81-L87"><code>CheckEarliestAvailableAttestationNonce(...)</code></a> method.</p>
<h2 id="state-transitions-1"><a class="header" href="#state-transitions-1">State Transitions</a></h2>
<h3 id="end-block-1"><a class="header" href="#end-block-1">End Block</a></h3>
<p>During the <code>EndBlock</code> step, we're executing the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L28-L35">logic</a> that handles the generating new valsets, new data commitments, and prunes when needed.</p>
<h3 id="valset-handler"><a class="header" href="#valset-handler">Valset handler</a></h3>
<p>A new valset is generated by the valset <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L84-L135"><code>handler</code></a> in the following cases:</p>
<h4 id="no-valset-in-store"><a class="header" href="#no-valset-in-store">No valset in store</a></h4>
<p>When <code>EndBlock</code> is executed straight after genesis, the store doesn't have any valset created yet. So, it <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L85-L93">checks</a> wether there is any valset in store, and <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L123-L134">generates</a> a new one afterwards representing the initial validator set.</p>
<h4 id="validator-starts-unbonding"><a class="header" href="#validator-starts-unbonding">Validator starts unbonding</a></h4>
<p>When a validator starts unbonding, the <code>LatestUnbondingBlockHeight</code> gets updated in a hook with the current block number. Then, inside <code>EndBlock</code>, we <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L123">check</a> whether the <code>LatestUnbondingBlockHeight</code> corresponds to the current block height. If so, then we generate a new valset that doesn't contain that unbonding validator.</p>
<h4 id="significant-power-change"><a class="header" href="#significant-power-change">Significant power change</a></h4>
<p>The third scenario where a valset gets created is when there is a significant power change. As stated above, valsets contain an <code>evmAddress -&gt; power</code> mapping for the validator sets they represent. When a <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L99-L120">significant power change</a> happens, a new valset gets created. The significant power threshold is defined by the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L15-L18"><code>SignificantPowerDifferenceThreshold</code></a> constant.</p>
<p>A significant power change can happen if a validator's delegation got reduced or increased significantly, or the powers of multiple validators changed in a way that the whole validator set variation is higher than the threshold. This calculus is done inside the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/types/validator.go#L100-L140"><code>PowerDiff(...)</code></a> method.</p>
<h3 id="data-commitment-handler"><a class="header" href="#data-commitment-handler">Data commitment handler</a></h3>
<p>The data commitment <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L37-L82"><code>handler</code></a> generates a new data commitment when a sufficient number of blocks have passed since the previous one.</p>
<p>The ranges of blocks, for which new data commitments are generated, are defined via the <code>DataCommitmentWindow</code> <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/types/genesis.go#L22">param</a>. This latter is initialized in <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/types/genesis.go#L28">genesis</a> and can be updated via governance votes or upgrades.</p>
<p>The data commitment window ranges from a minimum defined by <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/types/genesis.go#L16-L18"><code>MinimumDataCommitmentWindow</code></a> to a maximum specified by the <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/pkg/appconsts/global_consts.go#L77-L78"><code>DataCommitmentBlocksLimit</code></a>. This range is validated when initializing the <code>DataCommitmentWindow</code> value or when updating it via the <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/types/genesis.go#L56-L75"><code>validateDataCommitmentWindow</code></a> method.</p>
<p>After a range update, the <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L37-L82"><code>handler</code></a> tries to <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/abci.go#L51-L81">generate</a> any needed data commitment to catchup to the current height. An example of how these ranges are created can be found in <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/abci_test.go#L412-L520">tests</a>. Thus, in the same height, multiple data commitments can be generated and added to the store.</p>
<h3 id="pruning"><a class="header" href="#pruning">Pruning</a></h3>
<p>The third action done during the QGB <a href="https://github.com/celestiaorg/celestia-app/blob/9bf0cf1dd9ce31a3fecb51310c3913820b21a8c2/x/qgb/abci.go#L28-L35"><code>EndBlock</code></a> step is pruning.</p>
<p>The QGB state machine prunes old attestations up to the specified <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/abci.go#L22-L25"><code>AttestationExpiryTime</code></a>, which is currently set to 3 weeks, matching the consensus unbonding time.</p>
<p>So, on every block height, the state machine <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/abci.go#L140-L157">checks</a> whether there are any <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/abci.go#L22-L25"><code>expired</code></a> attestations. Then, it starts <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/abci.go#L161-L182">pruning</a> via calling the <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/keeper/keeper_attestation.go#L128-L139"><code>DeleteAttestation(...)</code></a> method. Then, it <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/abci.go#L186-L194"><code>prints</code></a> a log message specifying the number of pruned attestations.</p>
<p>If the all the attestations in store are expired, which is an edge case that should never occur, the QGB state machine <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/abci.go#L161">doesn't prune</a> the latest attestation.</p>
<h3 id="hooks"><a class="header" href="#hooks">Hooks</a></h3>
<h4 id="validator-unbonding-hook"><a class="header" href="#validator-unbonding-hook">Validator unbonding hook</a></h4>
<p>When a validator starts unbonding, a <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/keeper/hooks.go#L23-L34">hook</a> is executed that <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/keeper/hooks.go#LL33C2-L33C2">sets</a> the <code>LatestUnBondingBlockHeight</code> to the current block height. This allows creating a new valset that removes that validator from the valset members so that he doesn't need to sign attestations afterwards.</p>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<h3 id="new-attestation-event"><a class="header" href="#new-attestation-event">New attestation event</a></h3>
<p>After creating a new attestation, and adding it to the QGB store, an event is <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/keeper/keeper_attestation.go#L16-L22">emitted</a> containing its nonce.</p>
<h2 id="client"><a class="header" href="#client">Client</a></h2>
<h3 id="query-attestation-command"><a class="header" href="#query-attestation-command">Query attestation command</a></h3>
<p>The QGB query attestation command is part of the <code>celestia-appd</code> binary. It allows the user to query specific attestations by their corresponding nonce.</p>
<pre><code class="language-shell">$ celestia-appd query qgb attestation --help
query an attestation by nonce

Usage:
  celestia-appd query qgb attestation &lt;nonce&gt; [flags]

Aliases:
  attestation, att
</code></pre>
<h3 id="verification-command"><a class="header" href="#verification-command">Verification command</a></h3>
<p>The QGB verification command is part of the <code>celestia-appd</code> binary. It allows the user to verify that a set of shares has been posted to a specific QGB contract.</p>
<pre><code class="language-shell">$ celestia-appd verify --help

Verifies that a transaction hash, a range of shares, or a blob referenced by its transaction hash were committed to by the QGB contract

Usage:
  celestia-appd verify [command]

Available Commands:
  blob        Verifies that a blob, referenced by its transaction hash, in hex format, has been committed to by the QGB contract.
  shares      Verifies that a range of shares has been committed to by the QGB contract
  tx          Verifies that a transaction hash, in hex format, has been committed to by the QGB contract

Flags:
  -h, --help   help for verify

Use &quot;celestia-appd verify [command] --help&quot; for more information about a command.
</code></pre>
<p>It currently supports three sub-commands:</p>
<ul>
<li><code>blob</code>: Takes a transaction hash, in hex format, and verifies that the blob paid for by the transaction has been committed to by the QGB contract. It only supports one blob for now.</li>
<li><code>shares</code>: Takes a range of shares and a height, and verifies that these shares have been committed to by the QGB contract.</li>
<li><code>tx</code>: Takes a transaction hash, in hex format, and verifies that it has been committed to by the QGB contract.</li>
</ul>
<h2 id="params-1"><a class="header" href="#params-1">Params</a></h2>
<h3 id="data-commitment-window"><a class="header" href="#data-commitment-window">Data commitment window</a></h3>
<p>The data commitment window, which is explained above, is defined as a parameter in <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/types/genesis.go#L48-L54">here</a>.</p>
<p>This param is validated using the <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/types/genesis.go#L56-L75"><code>validateDataCommitmentWindow(...)</code></a> method.</p>
<h2 id="panics"><a class="header" href="#panics">Panics</a></h2>
<p>During EndBlock step, the state machine generates new attestations if needed. During this generation, the state machine could panic.</p>
<h3 id="valset-panics"><a class="header" href="#valset-panics">Valset panics</a></h3>
<p>When checking if the state machine needs to generate a new valset, the state machine might panic if it finds invalid state. This can happen in the following cases:</p>
<ul>
<li>When checking that a previous valset has been emitted, but it is unable to get it:</li>
</ul>
<pre><code class="language-golang">if k.CheckLatestAttestationNonce(ctx) &amp;&amp; k.GetLatestAttestationNonce(ctx) != 0 {
   var err error
   latestValset, err = k.GetLatestValset(ctx)
   if err != nil {
      panic(err)
   }
}
</code></pre>
<ul>
<li>When getting the current valset:</li>
</ul>
<pre><code class="language-golang">vs, err := k.GetCurrentValset(ctx)
if err != nil {
   // this condition should only occur in the simulator
   // ref : https://github.com/Gravity-Bridge/Gravity-Bridge/issues/35
   if errors.Is(err, types.ErrNoValidators) {
      ctx.Logger().Error(&quot;no bonded validators&quot;,
         &quot;cause&quot;, err.Error(),
      )
      return
   }
   panic(err)
}
</code></pre>
<ul>
<li>When creating the internal validator struct, i.e. mapping the validators EVM addresses to their powers:</li>
</ul>
<pre><code class="language-golang">intLatestMembers, err := types.BridgeValidators(latestValset.Members).ToInternal()
if err != nil {
   panic(sdkerrors.Wrap(err, &quot;invalid latest valset members&quot;))
}
</code></pre>
<h3 id="attestations-panics"><a class="header" href="#attestations-panics">Attestations panics</a></h3>
<p>When storing a new attestation, the state machine can panic if it finds invalid state. This latter can happen in the following cases:</p>
<ul>
<li>The attestation request created is a duplicate of an existing attestation:</li>
</ul>
<pre><code class="language-golang">key := []byte(types.GetAttestationKey(nonce))
store := ctx.KVStore(k.storeKey)

if store.Has(key) {
   panic(&quot;trying to overwrite existing attestation request&quot;)
}
</code></pre>
<ul>
<li>An error happened while marshalling the interface:</li>
</ul>
<pre><code class="language-golang">b, err := k.cdc.MarshalInterface(at)
if err != nil {
   panic(err)
}
</code></pre>
<ul>
<li>The universal nonce wasn't incremented correctly by 1:</li>
</ul>
<pre><code class="language-golang">if k.CheckLatestAttestationNonce(ctx) &amp;&amp; k.GetLatestAttestationNonce(ctx)+1 != nonce {
   panic(&quot;not incrementing latest attestation nonce correctly&quot;)
}
</code></pre>
<h3 id="hooks-initialization-panic"><a class="header" href="#hooks-initialization-panic">Hooks initialization panic</a></h3>
<p>When initializing the QGB hooks, if the QGB store key is not setup correctly, the state machine will <a href="https://github.com/celestiaorg/celestia-app/blob/0629c757ef35a24187a8d7a4c706c7cdc894c8b6/x/qgb/keeper/hooks.go#L14-L19">panic</a>:</p>
<pre><code class="language-golang">// if startup is mis-ordered in app.go this hook will halt the chain when
// called. Keep this check to make such a mistake obvious
if k.storeKey == nil {
   panic(&quot;hooks initialized before QGBKeeper&quot;)
}
</code></pre>
<h2 id="appendix"><a class="header" href="#appendix">Appendix</a></h2>
<p>The smart contract implementation is in <a href="https://github.com/celestiaorg/quantum-gravity-bridge/">quantum-gravity-bridge</a>.</p>
<p>The orchestrator and relayer implementations are in the <a href="https://github.com/celestiaorg/orchestrator-relayer">orchestrator-relayer</a> repo.</p>
<p>QGB ADRs are in the <a href="https://github.com/celestiaorg/celestia-app/tree/main/docs/architecture">docs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xmint"><a class="header" href="#xmint"><code>x/mint</code></a></h1>
<h2 id="abstract-3"><a class="header" href="#abstract-3">Abstract</a></h2>
<p>celestia-app's <code>x/mint</code> is a fork of the Cosmos SDK <a href="https://github.com/cosmos/cosmos-sdk/tree/5cd0b2316a7103468af38eab5d886f9f069c9cd7/x/mint"><code>x/mint</code></a> module that makes some changes to the inflation mechanism. The changes were motivated by a desire for Celestia to have a pre-determined inflation schedule. See <a href="../../x/mint/../../docs/architecture/adr-019-strict-inflation-schedule.html">ADR-019</a> for more details.</p>
<h3 id="inflation-schedule"><a class="header" href="#inflation-schedule">Inflation Schedule</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Year</th><th>Inflation (%)</th></tr></thead><tbody>
<tr><td>0</td><td>8.00</td></tr>
<tr><td>1</td><td>7.20</td></tr>
<tr><td>2</td><td>6.48</td></tr>
<tr><td>3</td><td>5.832</td></tr>
<tr><td>4</td><td>5.2488</td></tr>
<tr><td>5</td><td>4.72392</td></tr>
<tr><td>6</td><td>4.251528</td></tr>
<tr><td>7</td><td>3.8263752</td></tr>
<tr><td>8</td><td>3.44373768</td></tr>
<tr><td>9</td><td>3.099363912</td></tr>
<tr><td>10</td><td>2.7894275208</td></tr>
<tr><td>11</td><td>2.51048476872</td></tr>
<tr><td>12</td><td>2.259436291848</td></tr>
<tr><td>13</td><td>2.0334926626632</td></tr>
<tr><td>14</td><td>1.83014339639688</td></tr>
<tr><td>15</td><td>1.647129056757192</td></tr>
<tr><td>16</td><td>1.50</td></tr>
<tr><td>17</td><td>1.50</td></tr>
<tr><td>18</td><td>1.50</td></tr>
<tr><td>19</td><td>1.50</td></tr>
<tr><td>20</td><td>1.50</td></tr>
</tbody></table>
</div>
<ul>
<li><strong>Year</strong> indicates the number of years elapsed since chain genesis.</li>
<li><strong>Inflation (%)</strong> indicates the percentage of the total supply that will be minted in the next year.</li>
</ul>
<h2 id="terms-1"><a class="header" href="#terms-1">Terms</a></h2>
<ul>
<li><strong>Inflation Rate</strong>: The percentage of the total supply that will be minted each year. The inflation rate is calculated once per year on the anniversary of chain genesis based on the number of years elapsed since genesis. The inflation rate is calculated as <code>InitialInflationRate * ((1 - DisinflationRate) ^ YearsSinceGenesis)</code>. See <a href="../../x/mint/./types/constants.go">./types/constants.go</a> for the constants used in this module.</li>
<li><strong>Annual Provisions</strong>: The total amount of tokens that will be minted each year. Annual provisions are calculated once per year on the anniversary of chain genesis based on the total supply and the inflation rate. Annual provisions are calculated as <code>TotalSupply * InflationRate</code></li>
<li><strong>Block Provision</strong>: The amount of tokens that will be minted in the current block. Block provisions are calculated once per block based on the annual provisions and the number of nanoseconds elapsed between the current block and the previous block. Block provisions are calculated as <code>AnnualProvisions * (NanosecondsSincePreviousBlock / NanosecondsPerYear)</code></li>
</ul>
<h2 id="state-4"><a class="header" href="#state-4">State</a></h2>
<p>See <a href="../../x/mint/./types/minter.go">./types/minter.go</a> for the <code>Minter</code> struct which contains this module's state.</p>
<h2 id="state-transitions-2"><a class="header" href="#state-transitions-2">State Transitions</a></h2>
<p>The <code>Minter</code> struct is updated every block via <code>BeginBlocker</code>.</p>
<h3 id="begin-block-1"><a class="header" href="#begin-block-1">Begin Block</a></h3>
<p>See <code>BeginBlocker</code> in <a href="../../x/mint/./abci.go">./abci.go</a>.</p>
<h3 id="events-2"><a class="header" href="#events-2">Events</a></h3>
<p>An event is emitted every block when a block provision is minted. See <code>mintBlockProvision</code> in <a href="../../x/mint/./abci.go">./abci.go</a>.</p>
<h2 id="client-1"><a class="header" href="#client-1">Client</a></h2>
<h3 id="cli"><a class="header" href="#cli">CLI</a></h3>
<pre><code class="language-shell">$ celestia-appd query mint annual-provisions
80235005639941.760000000000000000
</code></pre>
<pre><code class="language-shell">$ celestia-appd query mint genesis-time
2023-05-09 00:56:15.59304 +0000 UTC
</code></pre>
<pre><code class="language-shell">$ celestia-appd query mint inflation
0.080000000000000000
</code></pre>
<h2 id="genesis-state"><a class="header" href="#genesis-state">Genesis State</a></h2>
<p>The genesis state is defined in <a href="../../x/mint/./types/genesis.go">./types/genesis.go</a>.</p>
<h2 id="params-2"><a class="header" href="#params-2">Params</a></h2>
<p>All params have been removed from this module because they should not be modifiable via governance.</p>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>See <a href="../../x/mint/./test/mint_test.go">./test/mint_test.go</a> for an integration test suite for this module.</p>
<h2 id="assumptions-and-considerations-2"><a class="header" href="#assumptions-and-considerations-2">Assumptions and Considerations</a></h2>
<blockquote>
<p>For the Gregorian calendar, the average length of the calendar year (the mean year) across the complete leap cycle of 400 years is 365.2425 days (97 out of 400 years are leap years).</p>
</blockquote>
<p>Source: <a href="https://en.wikipedia.org/wiki/Year#Calendar_year">https://en.wikipedia.org/wiki/Year#Calendar_year</a></p>
<p>This module assumes <code>DaysPerYear = 365.2425</code>  so when modifying tests, developers must define durations based on this assumption because ordinary durations won't return the expected results. In other words:</p>
<pre><code class="language-go">// oneYear is 31,556,952 seconds which will likely return expected results in tests
oneYear := time.Duration(minttypes.NanosecondsPerYear)

// oneYear is 31,536,000 seconds which will likely return unexpected results in tests
oneYear := time.Hour * 24 * 365
</code></pre>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>See <a href="../../x/mint/../../x/mint">x/mint</a> for the implementation of this module.</p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ol>
<li><a href="../../x/mint/../../docs/architecture/adr-019-strict-inflation-schedule.html">ADR-019</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xparamfilter"><a class="header" href="#xparamfilter"><code>x/paramfilter</code></a></h1>
<h2 id="abstract-4"><a class="header" href="#abstract-4">Abstract</a></h2>
<p>The paramfilter module allows for specific parameters to be added to a block
list, so that they cannot be changed by governance proposals. If a proposal
contains a single blocked parameter change, then none of the parameters are
updated.</p>
<p>This is useful for forcing hardforks to change parameters that are
critical to the network's operation that are also part of the cosmos-sdk's
standard modules. New modules should not use this module, and instead use
hardcoded constants.</p>
<h2 id="state-5"><a class="header" href="#state-5">State</a></h2>
<p>The state consists only of the parameters that are protected by the paramfilter.
All state is immutable and stored in memory during the application's
initialization.</p>
<pre><code class="language-go">// ParamBlockList keeps track of parameters that cannot be changed by governance
// proposals
type ParamBlockList struct {
	params map[string]bool
}

// NewParamBlockList creates a new ParamBlockList that can be used to block gov
// proposals that attempt to change hard-coded parameters.
func NewParamBlockList(blockedParams ...[2]string) ParamBlockList {
	consolidatedParams := make(map[string]bool, len(blockedParams))
	for _, param := range blockedParams {
		consolidatedParams[fmt.Sprintf(&quot;%s-%s&quot;, param[0], param[1])] = true
	}
	return ParamBlockList{params: consolidatedParams}
}
</code></pre>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Pass a list of the blocked subspace key pairs that describe each parameter to
the block list, then register the param change handler with the governance
module.</p>
<pre><code class="language-go">func (*App) Blocked() [][2]string {
	return [][2]string{
		{banktypes.ModuleName, string(banktypes.KeySendEnabled)},
		{stakingtypes.ModuleName, string(stakingtypes.KeyUnbondingTime)},
		{stakingtypes.ModuleName, string(stakingtypes.KeyBondDenom)},
		{baseapp.Paramspace, string(baseapp.ParamStoreKeyValidatorParams)},
	}
}

func NewApp(...) *App {
    ...
    paramBlockList := paramfilter.NewParamBlockList(app.BlockedParams()...)

	// register the proposal types
	govRouter := oldgovtypes.NewRouter()
	govRouter.AddRoute(paramproposal.RouterKey, paramBlockList.GovHandler(app.ParamsKeeper))
    ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xupgrade"><a class="header" href="#xupgrade"><code>x/upgrade</code></a></h1>
<h2 id="abstract-5"><a class="header" href="#abstract-5">Abstract</a></h2>
<p>The upgrade module removes the entrypoints to the standard upgrade module by not
registering a message server. It registers the standard upgrade module types to
preserve the ability to marshal them. Note that the keeper of the standard
upgrade module is still added to the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ibc-token-filter"><a class="header" href="#ibc-token-filter">IBC Token Filter</a></h1>
<h2 id="abstract-6"><a class="header" href="#abstract-6">Abstract</a></h2>
<p>The IBC token filter prevents non-native tokens from being transferred through the IBC transfer module from a counterparty chain to the host chain. This is useful if a chain wishes to only permit
their native token within their state machine.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>When tokens are transferred through the IBC transfer module, the denomination of that token is modified at each hop. It's more accurate to think of the tokens transferring to another network to actually remain held in escrow at the origin chain and the destination chain minting a &quot;wrapped&quot; equivalent. Thus tokens moved to a non-native state machine are beholdent to the security of both chains. The denomination is denoted as the path it's taken from the origin chain. To provide an example, imagine 3 chains: A, B and C with native tokens &quot;a&quot;, &quot;b&quot;, &quot;c&quot;. With IBC's transfer module, when a user transfers token &quot;a&quot; from A to B, the wrapped token is prefixed with the source port and source channel (i.e. <code>portidone/channel-0/a</code>), this is Ba. If the token is further transferred to C it becomes BCa (or <code>portidtwo/channel-1/portidone/channel-0/a</code>). This token is now beholdent to the security of B, C and A. Also note that this is different if &quot;a&quot; were to go directly to C. In other words: <code>Ca != BCa</code>.</p>
<p>This context is important in recognising when a native token is returning to its origin state machine. Each IBC packet contains metadata including the source port and channel. Therefore if the denomination of the token is prefixed with the same source port and channel as detailed in the packet, we can conclude that the denomination originally came from the receiving chain.</p>
<p>This logic is employed for path unwinding. Reversing the tokens through the path it came will eventually strip the denomination until it reaches the base denomination it started with.</p>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>The protocol targets inbound packets only. Outbound transfer messages are left unmodified. When a packet is sent to the IBC transfer module (denoted by the <code>transfer</code> port id), the token filter intercepts the message and attempts to unmarshal it as a <code>FungibleTokenPacketData</code>. If unmarshalling fails, the protocol should simply pass it down the stack for it to be handled elsewhere.</p>
<p>When tokens are transferred the token filter checks if the denomination is prefixed with the source port and channel of the packet. If so it passes the packet along for the transfer module to handle, else it returns a new error acknowledgement which will be returned to the sending chain.</p>
<p>The protocol does not check the length of the path that prefixes the base denomination i.e. it may still contain multiple ports and channels like <code>portidtwo/channel-1/portidone/channel-0/a</code>. This means that it may not be the native token but any other token that had previously passed through the state machine. This means if a chain were to adopt the middleware with existing state, the prior tokens may still unwind through that chain. For chains that commence using this middleware, no other token but the native denominations will be present.</p>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<p>The token filter is implemented as IBC middleware. It wraps the IBC transfer module. All other methods get routed directly to the underlying transfer module except for <code>OnRecvPacket</code> which adds extra logic before calling the <code>OnRecvPacket</code> method of the transfer module.</p>
<p>The transfer module already includes a <code>ReceiverChainIsSource</code> method. The basic logic is therefore:</p>
<pre><code class="language-go">if transfertypes.ReceiverChainIsSource(packet.GetSourcePort(), packet.GetSourceChannel(), data.Denom) {
	return m.IBCModule.OnRecvPacket(ctx, packet, relayer)
}
return channeltypes.NewErrorAcknowledgement(&quot;denomination not accepted by this chain&quot;)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
